{"idx": 194999, "original_item": {"idx": 194999, "project": "hhvm", "commit_id": "08193b7f0cd3910256e00d599f0f3eb2519c44ca", "project_url": "https://github.com/facebook/hhvm", "commit_url": "https://github.com/facebook/hhvm/commit/08193b7f0cd3910256e00d599f0f3eb2519c44ca", "commit_message": "security fixes\n\nhttps://hhvm.com/blog/2021/02/25/security-update.html", "target": 1, "func": "String preg_quote(const String& str,\n                  const String& delimiter /* = null_string */) {\n  const char* in_str = str.data();\n  const char* in_str_end = in_str + str.size();\n\n  /* Nothing to do if we got an empty string */\n  if (in_str == in_str_end) {\n    return str;\n  }\n\n  char delim_char = 0;      /* Delimiter character to be quoted */\n  bool quote_delim = false; /* Whether to quote additional delim char */\n  if (!delimiter.empty()) {\n    delim_char = delimiter.charAt(0);\n    quote_delim = true;\n  }\n\n  /* Allocate enough memory so that even if each character\n     is quoted, we won't run out of room */\n  String ret(4 * str.size() + 1, ReserveString);\n  char* out_str = ret.mutableData();\n\n  /* Go through the string and quote necessary characters */\n  const char* p;\n  char* q;\n  for (p = in_str, q = out_str; p != in_str_end; p++) {\n    char c = *p;\n    switch (c) {\n    case '.': case '\\\\': case '+': case '*': case '?':\n    case '[': case '^':  case ']': case '$': case '(':\n    case ')': case '{':  case '}': case '=': case '!':\n    case '>': case '<':  case '|': case ':': case '-':\n    case '#':\n      *q++ = '\\\\';\n      *q++ = c;\n      break;\n\n    case '\\0':\n      *q++ = '\\\\';\n      *q++ = '0';\n      *q++ = '0';\n      *q++ = '0';\n      break;\n\n    default:\n      if (quote_delim && c == delim_char)\n        *q++ = '\\\\';\n      *q++ = c;\n      break;\n    }\n  }\n  *q = '\\0';\n\n  return ret.setSize(q - out_str);\n}", "func_hash": 238223164532786533215583452209843695586, "file_name": "preg.cpp", "file_hash": 285507481464794574944910815142691250961, "cwe": ["CWE-190"], "cve": "CVE-2020-1918", "cve_desc": "In-memory file operations (ie: using fopen on a data URI) did not properly restrict negative seeking, allowing for the reading of memory prior to the in-memory buffer. This issue affects HHVM versions prior to 4.56.3, all versions between 4.57.0 and 4.80.1, all versions between 4.81.0 and 4.93.1, and versions 4.94.0, 4.95.0, 4.96.0, 4.97.0, 4.98.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-1918"}, "consensus_nodes": [{"type": "C_", "name": "Empty Input Check", "code_reference": "if (in_str == in_str_end)", "line_start": 5, "line_end": 7, "rationale": "Prevents unnecessary processing of empty strings, a defensive programming practice with no direct security impact but improves robustness.", "average_confidence": 0.9, "individual_confidences": [0.9, 0.9], "confidence_std": 0.0, "source_models": ["DeepSeek", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "C_:if(in_strin_str_end):0-0"}], "consensus_statistics": {"total_nodes_before_filtering": 1, "total_nodes_after_filtering": 1, "confidence_threshold": 0.85, "average_confidence": 0.9, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 195007, "original_item": {"idx": 195007, "project": "hhvm", "commit_id": "08193b7f0cd3910256e00d599f0f3eb2519c44ca", "project_url": "https://github.com/facebook/hhvm", "commit_url": "https://github.com/facebook/hhvm/commit/08193b7f0cd3910256e00d599f0f3eb2519c44ca", "commit_message": "security fixes\n\nhttps://hhvm.com/blog/2021/02/25/security-update.html", "target": 1, "func": "static int xbuf_format_converter(char **outbuf, const char *fmt, va_list ap)\n{\n  register char *s = nullptr;\n  char *q;\n  int s_len;\n\n  register int min_width = 0;\n  int precision = 0;\n  enum {\n    LEFT, RIGHT\n  } adjust;\n  char pad_char;\n  char prefix_char;\n\n  double fp_num;\n  wide_int i_num = (wide_int) 0;\n  u_wide_int ui_num;\n\n  char num_buf[NUM_BUF_SIZE];\n  char char_buf[2];      /* for printing %% and %<unknown> */\n\n#ifdef HAVE_LOCALE_H\n  struct lconv *lconv = nullptr;\n#endif\n\n  /*\n   * Flag variables\n   */\n  length_modifier_e modifier;\n  boolean_e alternate_form;\n  boolean_e print_sign;\n  boolean_e print_blank;\n  boolean_e adjust_precision;\n  boolean_e adjust_width;\n  int is_negative;\n\n  int size = 240;\n  char *result = (char *)malloc(size);\n  int outpos = 0;\n\n  while (*fmt) {\n    if (*fmt != '%') {\n      appendchar(&result, &outpos, &size, *fmt);\n    } else {\n      /*\n       * Default variable settings\n       */\n      adjust = RIGHT;\n      alternate_form = print_sign = print_blank = NO;\n      pad_char = ' ';\n      prefix_char = NUL;\n\n      fmt++;\n\n      /*\n       * Try to avoid checking for flags, width or precision\n       */\n      if (isascii((int)*fmt) && !islower((int)*fmt)) {\n        /*\n         * Recognize flags: -, #, BLANK, +\n         */\n        for (;; fmt++) {\n          if (*fmt == '-')\n            adjust = LEFT;\n          else if (*fmt == '+')\n            print_sign = YES;\n          else if (*fmt == '#')\n            alternate_form = YES;\n          else if (*fmt == ' ')\n            print_blank = YES;\n          else if (*fmt == '0')\n            pad_char = '0';\n          else\n            break;\n        }\n\n        /*\n         * Check if a width was specified\n         */\n        if (isdigit((int)*fmt)) {\n          STR_TO_DEC(fmt, min_width);\n          adjust_width = YES;\n        } else if (*fmt == '*') {\n          min_width = va_arg(ap, int);\n          fmt++;\n          adjust_width = YES;\n          if (min_width < 0) {\n            adjust = LEFT;\n            min_width = -min_width;\n          }\n        } else\n          adjust_width = NO;\n\n        /*\n         * Check if a precision was specified\n         *\n         * XXX: an unreasonable amount of precision may be specified\n         * resulting in overflow of num_buf. Currently we\n         * ignore this possibility.\n         */\n        if (*fmt == '.') {\n          adjust_precision = YES;\n          fmt++;\n          if (isdigit((int)*fmt)) {\n            STR_TO_DEC(fmt, precision);\n          } else if (*fmt == '*') {\n            precision = va_arg(ap, int);\n            fmt++;\n            if (precision < 0)\n              precision = 0;\n          } else\n            precision = 0;\n        } else\n          adjust_precision = NO;\n      } else\n        adjust_precision = adjust_width = NO;\n\n      /*\n       * Modifier check\n       */\n      switch (*fmt) {\n        case 'L':\n          fmt++;\n          modifier = LM_LONG_DOUBLE;\n          break;\n        case 'I':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == '6' && *(fmt+1) == '4') {\n            fmt += 2;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            if (*fmt == '3' && *(fmt+1) == '2') {\n              fmt += 2;\n              modifier = LM_LONG;\n            } else {\n#ifdef _WIN64\n              modifier = LM_LONG_LONG;\n#else\n              modifier = LM_LONG;\n#endif\n            }\n          break;\n        case 'l':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == 'l') {\n            fmt++;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            modifier = LM_LONG;\n          break;\n        case 'z':\n          fmt++;\n          modifier = LM_SIZE_T;\n          break;\n        case 'j':\n          fmt++;\n#if SIZEOF_INTMAX_T\n          modifier = LM_INTMAX_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 't':\n          fmt++;\n#if SIZEOF_PTRDIFF_T\n          modifier = LM_PTRDIFF_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 'h':\n          fmt++;\n          if (*fmt == 'h') {\n            fmt++;\n          }\n          /* these are promoted to int, so no break */\n        default:\n          modifier = LM_STD;\n          break;\n      }\n\n      /*\n       * Argument extraction and printing.\n       * First we determine the argument type.\n       * Then, we convert the argument to a string.\n       * On exit from the switch, s points to the string that\n       * must be printed, s_len has the length of the string\n       * The precision requirements, if any, are reflected in s_len.\n       *\n       * NOTE: pad_char may be set to '0' because of the 0 flag.\n       *   It is reset to ' ' by non-numeric formats\n       */\n      switch (*fmt) {\n        case 'u':\n          switch(modifier) {\n            default:\n              i_num = (wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              i_num = (wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              i_num = (wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              i_num = (wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              i_num = (wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              i_num = (wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          /*\n           * The rest also applies to other integer formats, so fall\n           * into that case.\n           */\n        case 'd':\n        case 'i':\n          /*\n           * Get the arg if we haven't already.\n           */\n          if ((*fmt) != 'u') {\n            switch(modifier) {\n              default:\n                i_num = (wide_int) va_arg(ap, int);\n                break;\n              case LM_LONG_DOUBLE:\n                goto fmt_error;\n              case LM_LONG:\n                i_num = (wide_int) va_arg(ap, long int);\n                break;\n              case LM_SIZE_T:\n#if SIZEOF_SSIZE_T\n                i_num = (wide_int) va_arg(ap, ssize_t);\n#else\n                i_num = (wide_int) va_arg(ap, size_t);\n#endif\n                break;\n#if SIZEOF_LONG_LONG\n              case LM_LONG_LONG:\n                i_num = (wide_int) va_arg(ap, wide_int);\n                break;\n#endif\n#if SIZEOF_INTMAX_T\n              case LM_INTMAX_T:\n                i_num = (wide_int) va_arg(ap, intmax_t);\n                break;\n#endif\n#if SIZEOF_PTRDIFF_T\n              case LM_PTRDIFF_T:\n                i_num = (wide_int) va_arg(ap, ptrdiff_t);\n                break;\n#endif\n            }\n          }\n          s = ap_php_conv_10(i_num, (*fmt) == 'u', &is_negative,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n\n          if (*fmt != 'u') {\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'o':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 3, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && *s != '0') {\n            *--s = '0';\n            s_len++;\n          }\n          break;\n\n\n        case 'x':\n        case 'X':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 4, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && i_num != 0) {\n            *--s = *fmt;  /* 'x' or 'X' */\n            *--s = '0';\n            s_len += 2;\n          }\n          break;\n\n\n        case 's':\n        case 'v':\n          s = va_arg(ap, char *);\n          if (s != nullptr) {\n            s_len = strlen(s);\n            if (adjust_precision && precision < s_len)\n              s_len = precision;\n          } else {\n            s = const_cast<char*>(s_null);\n            s_len = S_NULL_LEN;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case 'f':\n        case 'F':\n        case 'e':\n        case 'E':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n            s = const_cast<char*>(\"nan\");\n            s_len = 3;\n          } else if (std::isinf(fp_num)) {\n            s = const_cast<char*>(\"inf\");\n            s_len = 3;\n          } else {\n#ifdef HAVE_LOCALE_H\n            if (!lconv) {\n              lconv = localeconv();\n            }\n#endif\n            s = php_conv_fp((*fmt == 'f')?'F':*fmt, fp_num, alternate_form,\n             (adjust_precision == NO) ? FLOAT_DIGITS : precision,\n             (*fmt == 'f')?LCONV_DECIMAL_POINT:'.',\n                  &is_negative, &num_buf[1], &s_len);\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'g':\n        case 'k':\n        case 'G':\n        case 'H':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n             s = const_cast<char*>(\"NAN\");\n             s_len = 3;\n             break;\n           } else if (std::isinf(fp_num)) {\n             if (fp_num > 0) {\n               s = const_cast<char*>(\"INF\");\n               s_len = 3;\n             } else {\n               s = const_cast<char*>(\"-INF\");\n               s_len = 4;\n             }\n             break;\n           }\n\n          if (adjust_precision == NO)\n            precision = FLOAT_DIGITS;\n          else if (precision == 0)\n            precision = 1;\n          /*\n           * * We use &num_buf[ 1 ], so that we have room for the sign\n           */\n#ifdef HAVE_LOCALE_H\n          if (!lconv) {\n            lconv = localeconv();\n          }\n#endif\n          s = php_gcvt(fp_num, precision,\n                       (*fmt=='H' || *fmt == 'k') ? '.' : LCONV_DECIMAL_POINT,\n                       (*fmt == 'G' || *fmt == 'H')?'E':'e', &num_buf[1]);\n          if (*s == '-')\n            prefix_char = *s++;\n          else if (print_sign)\n            prefix_char = '+';\n          else if (print_blank)\n            prefix_char = ' ';\n\n          s_len = strlen(s);\n\n          if (alternate_form && (q = strchr(s, '.')) == nullptr)\n            s[s_len++] = '.';\n          break;\n\n\n        case 'c':\n          char_buf[0] = (char) (va_arg(ap, int));\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case '%':\n          char_buf[0] = '%';\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case 'n':\n          *(va_arg(ap, int *)) = outpos;\n          goto skip_output;\n\n          /*\n           * Always extract the argument as a \"char *\" pointer. We\n           * should be using \"void *\" but there are still machines\n           * that don't understand it.\n           * If the pointer size is equal to the size of an unsigned\n           * integer we convert the pointer to a hex number, otherwise\n           * we print \"%p\" to indicate that we don't handle \"%p\".\n           */\n        case 'p':\n          if (sizeof(char *) <= sizeof(u_wide_int)) {\n            ui_num = (u_wide_int)((size_t) va_arg(ap, char *));\n            s = ap_php_conv_p2(ui_num, 4, 'x',\n                &num_buf[NUM_BUF_SIZE], &s_len);\n            if (ui_num != 0) {\n              *--s = 'x';\n              *--s = '0';\n              s_len += 2;\n            }\n          } else {\n            s = const_cast<char*>(\"%p\");\n            s_len = 2;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case NUL:\n          /*\n           * The last character of the format string was %.\n           * We ignore it.\n           */\n          continue;\n\n\nfmt_error:\n        throw Exception(\"Illegal length modifier specified '%c'\", *fmt);\n\n          /*\n           * The default case is for unrecognized %'s.\n           * We print %<char> to help the user identify what\n           * option is not understood.\n           * This is also useful in case the user wants to pass\n           * the output of format_converter to another function\n           * that understands some other %<char> (like syslog).\n           * Note that we can't point s inside fmt because the\n           * unknown <char> could be preceded by width etc.\n           */\n        default:\n          char_buf[0] = '%';\n          char_buf[1] = *fmt;\n          s = char_buf;\n          s_len = 2;\n          pad_char = ' ';\n          break;\n      }\n\n      if (prefix_char != NUL) {\n        *--s = prefix_char;\n        s_len++;\n      }\n      if (adjust_width && adjust == RIGHT && min_width > s_len) {\n        if (pad_char == '0' && prefix_char != NUL) {\n          appendchar(&result, &outpos, &size, *s);\n          s++;\n          s_len--;\n          min_width--;\n        }\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n      /*\n       * Print the (for now) non-null terminated string s.\n       */\n      appendsimplestring(&result, &outpos, &size, s, s_len);\n\n      if (adjust_width && adjust == LEFT && min_width > s_len) {\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n    }\nskip_output:\n    fmt++;\n  }\n  /*\n   * Add the terminating null here since it wasn't added incrementally above\n   * once the whole string has been composed.\n   */\n  result[outpos] = NUL;\n  *outbuf = result;\n  return outpos;\n}", "func_hash": 123878033373043862530376781820859980563, "file_name": "zend-printf.cpp", "file_hash": 92196731070771540321178301198615589471, "cwe": ["CWE-190"], "cve": "CVE-2020-1918", "cve_desc": "In-memory file operations (ie: using fopen on a data URI) did not properly restrict negative seeking, allowing for the reading of memory prior to the in-memory buffer. This issue affects HHVM versions prior to 4.56.3, all versions between 4.57.0 and 4.80.1, all versions between 4.81.0 and 4.93.1, and versions 4.94.0, 4.95.0, 4.96.0, 4.97.0, 4.98.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-1918"}, "consensus_nodes": [{"type": "M_", "name": "Input Validation", "code_reference": "N/A", "line_start": 0, "line_end": 0, "rationale": "Missing validation for format string contents and numeric bounds", "average_confidence": 0.907, "individual_confidences": [0.95, 0.98, 0.9, 0.8], "confidence_std": 0.079, "source_models": ["DeepSeek", "DeepSeek", "DeepSeek", "Gemini-2.0-Flash"], "model_count": 4, "node_key": "M_:na:0-0"}], "consensus_statistics": {"total_nodes_before_filtering": 1, "total_nodes_after_filtering": 1, "confidence_threshold": 0.85, "average_confidence": 0.907, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 195020, "original_item": {"idx": 195020, "project": "xbmc", "commit_id": "80c8138c09598e88b4ddb6dbb279fa193bbb3237", "project_url": "https://github.com/fuzzard/xbmc", "commit_url": "https://github.com/fuzzard/xbmc/commit/80c8138c09598e88b4ddb6dbb279fa193bbb3237", "commit_message": "[Playlist] dont use istream directly to a tinyxml structure\n\nTurn istream into a std::string to handle large buffers (#20305)", "target": 1, "func": "bool CPlayListASX::LoadData(std::istream& stream)\n{\n  CLog::Log(LOGINFO, \"Parsing ASX\");\n\n  if(stream.peek() == '[')\n  {\n    return LoadAsxIniInfo(stream);\n  }\n  else\n  {\n    CXBMCTinyXML xmlDoc;\n    stream >> xmlDoc;\n\n    if (xmlDoc.Error())\n    {\n      CLog::Log(LOGERROR, \"Unable to parse ASX info Error: {}\", xmlDoc.ErrorDesc());\n      return false;\n    }\n\n    TiXmlElement *pRootElement = xmlDoc.RootElement();\n\n    // lowercase every element\n    TiXmlNode *pNode = pRootElement;\n    TiXmlNode *pChild = NULL;\n    std::string value;\n    value = pNode->Value();\n    StringUtils::ToLower(value);\n    pNode->SetValue(value);\n    while(pNode)\n    {\n      pChild = pNode->IterateChildren(pChild);\n      if(pChild)\n      {\n        if (pChild->Type() == TiXmlNode::TINYXML_ELEMENT)\n        {\n          value = pChild->Value();\n          StringUtils::ToLower(value);\n          pChild->SetValue(value);\n\n          TiXmlAttribute* pAttr = pChild->ToElement()->FirstAttribute();\n          while(pAttr)\n          {\n            value = pAttr->Name();\n            StringUtils::ToLower(value);\n            pAttr->SetName(value);\n            pAttr = pAttr->Next();\n          }\n        }\n\n        pNode = pChild;\n        pChild = NULL;\n        continue;\n      }\n\n      pChild = pNode;\n      pNode = pNode->Parent();\n    }\n    std::string roottitle;\n    TiXmlElement *pElement = pRootElement->FirstChildElement();\n    while (pElement)\n    {\n      value = pElement->Value();\n      if (value == \"title\" && !pElement->NoChildren())\n      {\n        roottitle = pElement->FirstChild()->ValueStr();\n      }\n      else if (value == \"entry\")\n      {\n        std::string title(roottitle);\n\n        TiXmlElement *pRef = pElement->FirstChildElement(\"ref\");\n        TiXmlElement *pTitle = pElement->FirstChildElement(\"title\");\n\n        if(pTitle && !pTitle->NoChildren())\n          title = pTitle->FirstChild()->ValueStr();\n\n        while (pRef)\n        { // multiple references may appear for one entry\n          // duration may exist on this level too\n          value = XMLUtils::GetAttribute(pRef, \"href\");\n          if (!value.empty())\n          {\n            if(title.empty())\n              title = value;\n\n            CLog::Log(LOGINFO, \"Adding element {}, {}\", title, value);\n            CFileItemPtr newItem(new CFileItem(title));\n            newItem->SetPath(value);\n            Add(newItem);\n          }\n          pRef = pRef->NextSiblingElement(\"ref\");\n        }\n      }\n      else if (value == \"entryref\")\n      {\n        value = XMLUtils::GetAttribute(pElement, \"href\");\n        if (!value.empty())\n        { // found an entryref, let's try loading that url\n          std::unique_ptr<CPlayList> playlist(CPlayListFactory::Create(value));\n          if (nullptr != playlist)\n            if (playlist->Load(value))\n              Add(*playlist);\n        }\n      }\n      pElement = pElement->NextSiblingElement();\n    }\n  }\n\n  return true;\n}", "func_hash": 129199039044343218280540573116603539534, "file_name": "PlayListPLS.cpp", "file_hash": 322007883831105198298453502916963773077, "cwe": ["CWE-120"], "cve": "CVE-2021-42917", "cve_desc": "Buffer overflow vulnerability in Kodi xbmc up to 19.0, allows attackers to cause a denial of service due to improper length of values passed to istream.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-42917"}, "consensus_nodes": [{"type": "M_", "name": "Input Validation", "code_reference": "N/A", "line_start": 0, "line_end": 0, "rationale": "The lack of input validation on XML structure, URLs, and file paths is a major vulnerability. Missing input validation allows attackers to inject malicious data, bypass security checks, and trigger various vulnerabilities. Represents a fundamental missing security mechanism.", "average_confidence": 0.97, "individual_confidences": [0.99, 0.95], "confidence_std": 0.028, "source_models": ["Gemini-2.0-Flash", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "M_:na:0-0"}, {"type": "F_", "name": "Unsafe XML Parsing", "code_reference": "stream >> xmlDoc", "line_start": 10, "line_end": 14, "rationale": "Direct XML parsing without security configurations enables XXE attacks and entity expansion vulnerabilities.", "average_confidence": 0.95, "individual_confidences": [0.95, 0.95], "confidence_std": 0.0, "source_models": ["DeepSeek", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "F_:streamxmldoc:10-10"}, {"type": "F_", "name": "CPlayListFactory::Create(value)", "code_reference": "std::unique_ptr<CPlayList> playlist(CPlayListFactory::Create(value));", "line_start": 76, "line_end": 76, "rationale": "This function creates a new playlist object based on the URL from the `href` attribute of `<entryref>`. If `CPlayListFactory::Create` doesn't validate the URL, it can lead to recursive playlist loading, code injection (via controlled filename extensions), and other vulnerabilities. This is a critical propagation point for attacks via crafted URLs.", "average_confidence": 0.925, "individual_confidences": [0.9, 0.95], "confidence_std": 0.035, "source_models": ["Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "F_:stdunique_ptrcplaylistplaylist(cplaylistfactorycreate(value)):70-70"}, {"type": "F_", "name": "playlist->Load(value)", "code_reference": "if (playlist->Load(value))", "line_start": 77, "line_end": 77, "rationale": "This call recursively loads another playlist using the potentially attacker-controlled URL, exacerbating the risk of denial-of-service due to recursive loading and other vulnerabilities in the playlist loading process itself. Represents a secondary vulnerability propagation point.", "average_confidence": 0.9, "individual_confidences": [0.85, 0.95], "confidence_std": 0.071, "source_models": ["Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "F_:if(playlistload(value)):70-70"}], "consensus_statistics": {"total_nodes_before_filtering": 5, "total_nodes_after_filtering": 4, "confidence_threshold": 0.85, "average_confidence": 0.93625, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 195042, "original_item": {"idx": 195042, "project": "tensorflow", "commit_id": "6c0b2b70eeee588591680f5b7d5d38175fd7cdf6", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/6c0b2b70eeee588591680f5b7d5d38175fd7cdf6", "commit_message": "[lite] add validation check for sparse fully connected\n\nPiperOrigin-RevId: 417629354\nChange-Id: If96171c4bd4f5fdb01d6368d6deab19d1c9beca7", "target": 1, "func": "TfLiteStatus EvalFloat(TfLiteContext* context, TfLiteNode* node,\n                       TfLiteFullyConnectedParams* params, OpData* data,\n                       const TfLiteTensor* input, const TfLiteTensor* filter,\n                       const TfLiteTensor* bias, TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params->activation, &output_activation_min,\n                           &output_activation_max);\n  if (kernel_type == kReference) {\n    FullyConnectedParams op_params;\n    op_params.float_activation_min = output_activation_min;\n    op_params.float_activation_max = output_activation_max;\n    if (filter->sparsity != nullptr) {\n      const auto& sparsity = *filter->sparsity;\n      reference_ops::FullyConnectedSparseWeight(\n          sparsity, op_params, GetTensorShape(input),\n          GetTensorData<float>(input), GetTensorShape(filter),\n          GetTensorData<float>(filter), GetTensorShape(bias),\n          GetTensorData<float>(bias), GetTensorShape(output),\n          GetTensorData<float>(output));\n    } else {\n      reference_ops::FullyConnected(\n          op_params, GetTensorShape(input), GetTensorData<float>(input),\n          GetTensorShape(filter), GetTensorData<float>(filter),\n          GetTensorShape(bias), GetTensorData<float>(bias),\n          GetTensorShape(output), GetTensorData<float>(output));\n    }\n  } else if (kernel_type == kLegacyPie) {\n    return EvalPie(context, node, params, data, input, filter, bias, output);\n  } else {\n    FullyConnectedParams op_params;\n    op_params.float_activation_min = output_activation_min;\n    op_params.float_activation_max = output_activation_max;\n    if (filter->sparsity != nullptr) {\n      const auto& sparsity = *filter->sparsity;\n      if (!SupportedSparsityFormat(sparsity)) {\n        TF_LITE_KERNEL_LOG(context,\n                           \"Unsupported sparse fully-connected weight format.\");\n        return kTfLiteError;\n      }\n\n      if (sparsity.dim_metadata_size == kDimMetadataSizeRandomSparse) {\n        // Random sparse.\n        optimized_ops::FullyConnectedSparseWeight(\n            sparsity, op_params, GetTensorShape(input),\n            GetTensorData<float>(input), GetTensorShape(filter),\n            GetTensorData<float>(filter), GetTensorShape(bias),\n            GetTensorData<float>(bias), GetTensorShape(output),\n            GetTensorData<float>(output));\n      } else if (sparsity.dim_metadata_size == kDimMetadataSizeBlockSparse &&\n                 sparsity.dim_metadata[2].dense_size == 4) {\n        // Block sparse with block size of 1x4.\n        optimized_ops::FullyConnectedSparseWeight1x4(\n            sparsity, op_params, GetTensorShape(input),\n            GetTensorData<float>(input), GetTensorShape(filter),\n            GetTensorData<float>(filter), GetTensorShape(bias),\n            GetTensorData<float>(bias), GetTensorShape(output),\n            GetTensorData<float>(output),\n            CpuBackendContext::GetFromContext(context));\n      } else {\n        TF_LITE_KERNEL_LOG(context,\n                           \"Unsupported sparse fully-connected weight format.\");\n        return kTfLiteError;\n      }\n\n    } else {\n      op_params.lhs_cacheable = IsConstantTensor(filter);\n      op_params.rhs_cacheable = IsConstantTensor(input);\n      optimized_ops::FullyConnected(\n          op_params, GetTensorShape(input), GetTensorData<float>(input),\n          GetTensorShape(filter), GetTensorData<float>(filter),\n          GetTensorShape(bias), GetTensorData<float>(bias),\n          GetTensorShape(output), GetTensorData<float>(output),\n          CpuBackendContext::GetFromContext(context));\n    }\n  }\n\n  return kTfLiteOk;\n}", "func_hash": 62355110582225554577873492287231441253, "file_name": "fully_connected.cc", "file_hash": 336723537786498894160827433697879115254, "cwe": ["CWE-787"], "cve": "CVE-2022-23561", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause a write outside of bounds of an array in TFLite. In fact, the attacker can override the linked list used by the memory allocator. This can be leveraged for an arbitrary write primitive under certain conditions. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23561"}, "consensus_nodes": [{"type": "F_", "name": "Raw tensor data access", "code_reference": "GetTensorData<float>()", "line_start": 11, "line_end": 59, "rationale": "High-risk direct memory accesses without bounds checking, creating potential buffer overflow vulnerabilities.", "average_confidence": 0.98, "individual_confidences": [0.98], "confidence_std": 0.0, "source_models": ["DeepSeek"], "model_count": 1, "node_key": "F_:gettensordatafloat():10-50"}, {"type": "F_", "name": "Sparse Weight Handling", "code_reference": "SupportedSparsityFormat(sparsity)", "line_start": 39, "line_end": 39, "rationale": "Checks if the sparsity format is supported, preventing undefined behavior or crashes due to unsupported formats, acting as a protective measure.", "average_confidence": 0.98, "individual_confidences": [0.98], "confidence_std": 0.0, "source_models": ["Qwen2.5-Coder-32B"], "model_count": 1, "node_key": "F_:supportedsparsityformat(sparsity):30-30"}, {"type": "V_", "name": "input", "code_reference": "input", "line_start": 4, "line_end": 4, "rationale": "Untrusted input data. Incorrect shape or type can lead to out-of-bounds reads/writes when accessing tensor data, directly affecting memory safety. Acts as a potential trigger for vulnerabilities.", "average_confidence": 0.95, "individual_confidences": [0.95], "confidence_std": 0.0, "source_models": ["Gemini-2.0-Flash"], "model_count": 1, "node_key": "V_:input:0-0"}], "consensus_statistics": {"total_nodes_before_filtering": 3, "total_nodes_after_filtering": 3, "confidence_threshold": 0.85, "average_confidence": 0.97, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 195057, "original_item": {"idx": 195057, "project": "keepkey-firmware", "commit_id": "e49d45594002d4d3fbc1f03488e6dfc0a0a65836", "project_url": "https://github.com/keepkey/keepkey-firmware", "commit_url": "https://github.com/keepkey/keepkey-firmware/commit/e49d45594002d4d3fbc1f03488e6dfc0a0a65836", "commit_message": "710 merge", "target": 1, "func": "uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg,\n                                          char *buffer) {\n  // Swap data begins 164 chars into data buffer:\n  // offset = deposit function hash + address + address + uint256\n  uint16_t offset = 4 + (5 * 32);\n  int16_t len = msg->data_length - offset;\n  if (msg->has_data_length && len > 0) {\n    memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);\n    // String length must be < 255 characters\n    return len < 256 ? (uint8_t)len : 0;\n  }\n  return 0;\n}", "func_hash": 62617281911012576687050684518892834758, "file_name": "ethereum.c", "file_hash": 270938923042963122350351912532736990905, "cwe": ["CWE-787"], "cve": "CVE-2021-31616", "cve_desc": "Insufficient length checks in the ShapeShift KeepKey hardware wallet firmware before 7.1.0 allow a stack buffer overflow via crafted messages. The overflow in ethereum_extractThorchainSwapData() in ethereum.c can circumvent stack protections and lead to code execution. The vulnerable interface is reachable remotely over WebUSB.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-31616"}, "consensus_nodes": [{"type": "F_", "name": "Unsafe Memory Copy", "code_reference": "memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);", "line_start": 7, "line_end": 7, "rationale": "No buffer size validation; potential buffer overflow if len exceeds buffer capacity or if msg->data_initial_chunk.bytes is malformed.", "average_confidence": 0.96, "individual_confidences": [0.98, 0.95, 0.95], "confidence_std": 0.017, "source_models": ["DeepSeek", "Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 3, "node_key": "F_:memcpy(buffer,msgdata_initial_chunkbytesoffset,len):0-0"}, {"type": "V_", "name": "Hardcoded ABI Data Offset", "code_reference": "uint16_t offset = 4 + (5 * 32);", "line_start": 4, "line_end": 4, "rationale": "Hardcoded offset assumes fixed ABI structure; incorrect offset leads to data corruption or extraction of wrong Thorchain swap details.", "average_confidence": 0.95, "individual_confidences": [0.95, 0.95], "confidence_std": 0.0, "source_models": ["DeepSeek", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "V_:uint16_toffset4(532):0-0"}, {"type": "M_", "name": "Size check on buffer", "code_reference": "N/A", "line_start": 0, "line_end": 0, "rationale": "The complete absence of a size check on the destination `buffer` before the `memcpy` operation is a critical missing element that creates a clear and direct path to a buffer overflow vulnerability. This is a fundamental flaw.", "average_confidence": 0.95, "individual_confidences": [0.95, 0.95, 0.95], "confidence_std": 0.0, "source_models": ["Gemini-2.0-Flash", "Qwen2.5-Coder-32B", "Qwen2.5-Coder-32B"], "model_count": 3, "node_key": "M_:na:0-0"}, {"type": "V_", "name": "len", "code_reference": "int16_t len = msg->data_length - offset;", "line_start": 6, "line_end": 6, "rationale": "If `msg->data_length` is smaller than `offset`, `len` will become negative due to signed integer arithmetic, potentially bypassing the `len > 0` check and leading to out-of-bounds read on memcpy. The signed nature of this variable type is critical.", "average_confidence": 0.925, "individual_confidences": [0.9, 0.95], "confidence_std": 0.035, "source_models": ["Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "V_:int16_tlenmsgdata_lengthoffset:0-0"}, {"type": "C_", "name": "Input Data Length Check", "code_reference": "if (msg->has_data_length && len > 0)", "line_start": 6, "line_end": 6, "rationale": "Missing null check on msg->data_initial_chunk.bytes could lead to null-pointer dereference; insufficient validation of input bounds.", "average_confidence": 0.875, "individual_confidences": [0.9, 0.8, 0.85, 0.95], "confidence_std": 0.065, "source_models": ["DeepSeek", "Gemini-2.0-Flash", "Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 4, "node_key": "C_:if(msghas_data_lengthlen0):0-0"}], "consensus_statistics": {"total_nodes_before_filtering": 5, "total_nodes_after_filtering": 5, "confidence_threshold": 0.85, "average_confidence": 0.9319999999999999, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 195084, "original_item": {"idx": 195084, "project": "faad2", "commit_id": "1b71a6ba963d131375f5e489b3b25e36f19f3f24", "project_url": "https://github.com/knik0/faad2", "commit_url": "https://github.com/knik0/faad2/commit/1b71a6ba963d131375f5e489b3b25e36f19f3f24", "commit_message": "fix heap-buffer-overflow in mp4read.c\n\nThis originated from an integer overflow: If mp4config.frame.ents\nwould be read-in with a value of (uint32t)(-1), it would overflow to 0\nin the size calculation for the allocation in the next line. The\nmalloc() function would then successfully return a pointer to a memory\nregion of size 0, which will cause a segfault when written to.\n\nFixes #57.", "target": 1, "func": "static int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n\n    // version/flags\n    u32in();\n    // Sample size\n    u32in();\n    // Number of entries\n    mp4config.frame.ents = u32in();\n    // fixme: check atom size\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n\n        mp4config.frame.data[cnt + 1] = ofs;\n\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n\n    return size;\n}", "func_hash": 182699574576129672282989775834999797945, "file_name": "None", "file_hash": null, "cwe": ["CWE-787"], "cve": "CVE-2021-32272", "cve_desc": "An issue was discovered in faad2 before 2.10.0. A heap-buffer-overflow exists in the function stszin located in mp4read.c. It allows an attacker to cause Code Execution.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-32272"}, "consensus_nodes": [{"type": "M_", "name": "Missing Size Limit for `fsize`", "code_reference": "N/A", "line_start": 0, "line_end": 0, "rationale": "Absence of a size check for `fsize` before adding it to `ofs`.  Allows excessively large `fsize` values to be used in offset calculations, increasing the likelihood of triggering integer overflows and subsequent vulnerabilities. A size limit would provide defense-in-depth.", "average_confidence": 0.9, "individual_confidences": [0.9, 0.9], "confidence_std": 0.0, "source_models": ["Gemini-2.0-Flash", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "M_:na:0-0"}, {"type": "F_", "name": "u32in() (version/flags)", "code_reference": "u32in()", "line_start": 5, "line_end": 5, "rationale": "External input function.  If `u32in` reads from a stream/file, errors in stream processing (e.g. unexpected EOF) can lead to incorrect state and later vulnerabilities. Further, the returned value, while unused here, could affect overall control flow of the program.", "average_confidence": 0.85, "individual_confidences": [0.8, 0.8, 0.95], "confidence_std": 0.087, "source_models": ["Gemini-2.0-Flash", "Gemini-2.0-Flash", "Gemini-2.0-Flash"], "model_count": 3, "node_key": "F_:u32in():0-0"}], "consensus_statistics": {"total_nodes_before_filtering": 3, "total_nodes_after_filtering": 2, "confidence_threshold": 0.85, "average_confidence": 0.875, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 195217, "original_item": {"idx": 195217, "project": "mruby", "commit_id": "28ccc664e5dcd3f9d55173e9afde77c4705a9ab6", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/28ccc664e5dcd3f9d55173e9afde77c4705a9ab6", "commit_message": "proc.c: should not reference `irep` when copying failed.\n\nIt may cause broken reference count numbers.", "target": 1, "func": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}", "func_hash": 141188842630049204876287625075629935243, "file_name": "proc.c", "file_hash": 25312707254065398661522821980007315136, "cwe": ["CWE-122"], "cve": "CVE-2022-0080", "cve_desc": "mruby is vulnerable to Heap-based Buffer Overflow", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0080"}, "consensus_nodes": [{"type": "M_", "name": "NULL Pointer Validation", "code_reference": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)", "line_start": 0, "line_end": 0, "rationale": "Missing NULL checks on input procs a and b risk segmentation faults (DoS).", "average_confidence": 0.99, "individual_confidences": [1.0, 0.98], "confidence_std": 0.014, "source_models": ["DeepSeek", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "M_:mrb_proc_copy(mrb_statemrb,structrproca,structrprocb):0-0"}, {"type": "C_", "name": "Initialized Proc Check", "code_reference": "if (a->body.irep)", "line_start": 0, "line_end": 0, "rationale": "Prevents redundant copies but lacks validation of proc integrity, risking bypass if memory is corrupted.", "average_confidence": 0.925, "individual_confidences": [0.9, 0.95], "confidence_std": 0.035, "source_models": ["DeepSeek", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "C_:if(abodyirep):0-0"}, {"type": "F_", "name": "IREP Reference Increment", "code_reference": "mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);", "line_start": 0, "line_end": 0, "rationale": "Incorrect reference counting due to unvalidated irep could lead to memory leaks or use-after-free.", "average_confidence": 0.915, "individual_confidences": [0.85, 0.98], "confidence_std": 0.092, "source_models": ["DeepSeek", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "F_:mrb_irep_incref(mrb,(mrb_irep)abodyirep):0-0"}], "consensus_statistics": {"total_nodes_before_filtering": 4, "total_nodes_after_filtering": 3, "confidence_threshold": 0.85, "average_confidence": 0.9433333333333334, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 195244, "original_item": {"idx": 195244, "project": "tensorflow", "commit_id": "c2426bba00a01de6913738df8fa78e0215fcce02", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/c2426bba00a01de6913738df8fa78e0215fcce02", "commit_message": "Use `PartialTensorShape` instead of `TensorShape`.\n\n`TensorShape` constructor throws a CHECK-fail if shape is partial/overflows which the other doesn't. We are only determining the number of elements in the shape and partial shape should be used as it returns negative number when needed.\n\nPiperOrigin-RevId: 409205384\nChange-Id: Ia56542ff9ec758f2c9ffc7e4dcc9fa7eecd86e7b", "target": 1, "func": "int64_t TensorByteSize(const TensorProto& t) {\n  // num_elements returns -1 if shape is not fully defined.\n  int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();\n  return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());\n}", "func_hash": 4480814010538664140540142741999865506, "file_name": "attr_value_util.cc", "file_hash": 86426759929974438313973525221473193689, "cwe": ["CWE-617"], "cve": "CVE-2022-23582", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that `TensorByteSize` would trigger `CHECK` failures. `TensorShape` constructor throws a `CHECK`-fail if shape is partial or has a number of elements that would overflow the size of an `int`. The `PartialTensorShape` constructor instead does not cause a `CHECK`-abort if the shape is partial, which is exactly what this function needs to be able to return `-1`. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23582"}, "consensus_nodes": [{"type": "F_", "name": "num_elems * DataTypeSize(t.dtype())", "code_reference": "num_elems * DataTypeSize(t.dtype())", "line_start": 3, "line_end": 3, "rationale": "High-risk integer multiplication prone to overflow, leading to incorrect memory allocation.", "average_confidence": 0.977, "individual_confidences": [1.0, 0.98, 0.95], "confidence_std": 0.025, "source_models": ["DeepSeek", "Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 3, "node_key": "F_:num_elemsdatatypesize(tdtype()):0-0"}, {"type": "F_", "name": "TensorShape::num_elements()", "code_reference": "TensorShape(t.tensor_shape()).num_elements()", "line_start": 2, "line_end": 3, "rationale": "Critical for validating tensor shape integrity; incorrect results may lead to unsafe memory operations downstream.", "average_confidence": 0.933, "individual_confidences": [0.9, 0.95, 0.95], "confidence_std": 0.029, "source_models": ["DeepSeek", "Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 3, "node_key": "F_:tensorshape(ttensor_shape())num_elements():0-0"}, {"type": "P_", "name": "const TensorProto& t", "code_reference": "t", "line_start": 1, "line_end": 1, "rationale": "Untrusted input source; malformed data could propagate to critical calculations.", "average_confidence": 0.925, "individual_confidences": [0.9, 0.95], "confidence_std": 0.035, "source_models": ["DeepSeek", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "P_:t:0-0"}, {"type": "F_", "name": "DataTypeSize()", "code_reference": "DataTypeSize(t.dtype())", "line_start": 3, "line_end": 3, "rationale": "Directly impacts byte size calculation; invalid dtype could cause incorrect sizing and memory corruption.", "average_confidence": 0.883, "individual_confidences": [0.8, 0.9, 0.95], "confidence_std": 0.076, "source_models": ["DeepSeek", "Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 3, "node_key": "F_:datatypesize(tdtype()):0-0"}], "consensus_statistics": {"total_nodes_before_filtering": 4, "total_nodes_after_filtering": 4, "confidence_threshold": 0.85, "average_confidence": 0.9295, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 195247, "original_item": {"idx": 195247, "project": "tensorflow", "commit_id": "e5b0eec199c2d03de54fd6a7fd9275692218e2bc", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/e5b0eec199c2d03de54fd6a7fd9275692218e2bc", "commit_message": "[lite] Add validation check for dilation height/width to be positive integers.\n\nPiperOrigin-RevId: 416429178\nChange-Id: If7cdcddca54486434d9b2f06e7e2b401d7c3ee25", "target": 1, "func": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthwiseConvParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  bool has_bias = NumInputs(node) == 3;\n\n  TF_LITE_ENSURE(context, has_bias || NumInputs(node) == 2);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* filter;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kFilterTensor, &filter));\n  const TfLiteTensor* bias = nullptr;\n\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 4);\n\n  const TfLiteType data_type = input->type;\n\n  const TfLiteType filter_type = filter->type;\n  const bool is_hybrid =\n      data_type == kTfLiteFloat32 && filter_type == kTfLiteInt8;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt16);\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, data_type);\n  if (!is_hybrid) {\n    TF_LITE_ENSURE(context,\n                   filter->type == data_type || data_type == kTfLiteInt16);\n  }\n\n  if (data_type == kTfLiteInt16) {\n    TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0);\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n  }\n\n  // Filter in DepthwiseConv is expected to be [1, H, W, O].\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 0), 1);\n\n  if (has_bias) {\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBiasTensor, &bias));\n    if (data_type == kTfLiteUInt8 || data_type == kTfLiteInt8) {\n      TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt32);\n      TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);\n    } else if (data_type == kTfLiteInt16) {\n      TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt64);\n      TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);\n    } else {\n      TF_LITE_ENSURE_TYPES_EQ(context, bias->type, data_type);\n    }\n    TF_LITE_ENSURE_EQ(context, NumDimensions(bias), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 3),\n                      SizeOfDimension(bias, 0));\n  }\n\n  int channels_out = SizeOfDimension(filter, 3);\n  int width = SizeOfDimension(input, 2);\n  int height = SizeOfDimension(input, 1);\n  int filter_width = SizeOfDimension(filter, 2);\n  int filter_height = SizeOfDimension(filter, 1);\n  int batches = SizeOfDimension(input, 0);\n\n  // Matching GetWindowedOutputSize in TensorFlow.\n  auto padding = params->padding;\n  int out_width, out_height;\n\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width,\n      params->dilation_height_factor, params->dilation_width_factor, height,\n      width, filter_height, filter_width, padding, &out_height, &out_width);\n\n  // Note that quantized inference requires that all tensors have their\n  // parameters set. This is usually done during quantized training or\n  // calibration.\n  if (data_type != kTfLiteFloat32) {\n    TF_LITE_ENSURE_EQ(context, filter->quantization.type,\n                      kTfLiteAffineQuantization);\n    TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);\n    const auto* affine_quantization =\n        reinterpret_cast<TfLiteAffineQuantization*>(\n            filter->quantization.params);\n    TF_LITE_ENSURE(context, affine_quantization);\n    TF_LITE_ENSURE(context, affine_quantization->scale);\n    TF_LITE_ENSURE(context, (affine_quantization->scale->size == 1 ||\n                             affine_quantization->scale->size == channels_out));\n\n    data->per_channel_output_multiplier.resize(channels_out);\n    data->per_channel_output_shift.resize(channels_out);\n    TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(\n        context, input, filter, bias, output, params->activation,\n        &data->output_multiplier, &data->output_shift,\n        &data->output_activation_min, &data->output_activation_max,\n        data->per_channel_output_multiplier.data(),\n        data->per_channel_output_shift.data(), channels_out));\n  }\n\n  if (is_hybrid) {\n    TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);\n    const auto* affine_quantization =\n        reinterpret_cast<TfLiteAffineQuantization*>(\n            filter->quantization.params);\n    TF_LITE_ENSURE(context, affine_quantization);\n    TF_LITE_ENSURE(context, affine_quantization->scale);\n    TF_LITE_ENSURE_EQ(\n        context, affine_quantization->scale->size,\n        filter->dims->data[affine_quantization->quantized_dimension]);\n\n    int temporaries_count = 0;\n    data->input_quantized_index = temporaries_count;\n    if (data->input_quantized_id == kTensorNotAllocated) {\n      TF_LITE_ENSURE_OK(\n          context, context->AddTensors(context, 1, &data->input_quantized_id));\n    }\n    ++temporaries_count;\n    data->scaling_factors_index = temporaries_count;\n    if (data->scaling_factors_id == kTensorNotAllocated) {\n      TF_LITE_ENSURE_OK(\n          context, context->AddTensors(context, 1, &data->scaling_factors_id));\n    }\n    ++temporaries_count;\n    data->input_offset_index = temporaries_count;\n    if (data->input_offset_id == kTensorNotAllocated) {\n      TF_LITE_ENSURE_OK(\n          context, context->AddTensors(context, 1, &data->input_offset_id));\n    }\n    ++temporaries_count;\n\n    TfLiteIntArrayFree(node->temporaries);\n    node->temporaries = TfLiteIntArrayCreate(temporaries_count);\n\n    node->temporaries->data[data->input_quantized_index] =\n        data->input_quantized_id;\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, data->input_quantized_index,\n                                  &input_quantized));\n    input_quantized->type = kTfLiteInt8;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n    node->temporaries->data[data->scaling_factors_index] =\n        data->scaling_factors_id;\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, data->scaling_factors_index,\n                                  &scaling_factors));\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    const int batch_size = SizeOfDimension(input, 0);\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n    node->temporaries->data[data->input_offset_index] = data->input_offset_id;\n    TfLiteTensor* input_offsets;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, data->input_offset_index,\n                                       &input_offsets));\n    input_offsets->type = kTfLiteInt32;\n    input_offsets->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, scaling_dims)) {\n      TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1);\n      input_offsets_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets,\n                                                       input_offsets_size));\n    }\n  }\n\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(4);\n  outputSize->data[0] = batches;\n  outputSize->data[1] = out_height;\n  outputSize->data[2] = out_width;\n  outputSize->data[3] = channels_out;\n  return context->ResizeTensor(context, output, outputSize);\n}", "func_hash": 158191376502861052790903162927100796429, "file_name": "depthwise_conv.cc", "file_hash": 254210893506480532293472494017662319300, "cwe": ["CWE-369"], "cve": "CVE-2022-21741", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. ### Impact An attacker can craft a TFLite model that would trigger a division by zero in the implementation of depthwise convolutions. The parameters of the convolution can be user controlled and are also used within a division operation to determine the size of the padding that needs to be added before applying the convolution. There is no check before this division that the divisor is strictly positive. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-21741"}, "consensus_nodes": [{"type": "C_", "name": "Tensor Dimension Checks", "code_reference": "TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4)", "line_start": 26, "line_end": 27, "rationale": "Ensures tensors are 4D (NHWC format), preventing buffer overflow.", "average_confidence": 0.97, "individual_confidences": [0.97, 0.97], "confidence_std": 0.0, "source_models": ["DeepSeek", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "C_:tf_lite_ensure_eq(context,numdimensions(input),4):20-20"}, {"type": "F_", "name": "GetInputSafe", "code_reference": "GetInputSafe(context, node, kInputTensor, &input)", "line_start": 10, "line_end": 10, "rationale": "GetInputSafe acts as a defensive security mechanism by ensuring the input tensor is valid before it's used. This prevents potential crashes or undefined behavior that could result from processing invalid or uninitialized input data, protecting against malicious or corrupted input.", "average_confidence": 0.965, "individual_confidences": [0.95, 0.98], "confidence_std": 0.021, "source_models": ["Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "F_:getinputsafe(context,node,kinputtensor,input):10-10"}, {"type": "C_", "name": "Input Count Check", "code_reference": "TF_LITE_ENSURE(context, has_bias || NumInputs(node) == 2)", "line_start": 10, "line_end": 10, "rationale": "Ensures correct number of inputs to prevent invalid memory access or incorrect processing.", "average_confidence": 0.95, "individual_confidences": [0.95, 0.95], "confidence_std": 0.0, "source_models": ["DeepSeek", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "C_:tf_lite_ensure(context,has_biasnuminputs(node)2):10-10"}], "consensus_statistics": {"total_nodes_before_filtering": 3, "total_nodes_after_filtering": 3, "confidence_threshold": 0.85, "average_confidence": 0.9616666666666667, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 195337, "original_item": {"idx": 195337, "project": "linux", "commit_id": "bcd0f93353326954817a4f9fa55ec57fb38acbb0", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/bcd0f93353326954817a4f9fa55ec57fb38acbb0", "commit_message": "phonet: refcount leak in pep_sock_accep\n\nsock_hold(sk) is invoked in pep_sock_accept(), but __sock_put(sk) is not\ninvoked in subsequent failure branches(pep_accept_conn() != 0).\n\nSigned-off-by: Hangyu Hua <hbh25y@gmail.com>\nLink: https://lore.kernel.org/r/20211209082839.33985-1-hbh25y@gmail.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>", "target": 1, "func": "static struct sock *pep_sock_accept(struct sock *sk, int flags, int *errp,\n\t\t\t\t    bool kern)\n{\n\tstruct pep_sock *pn = pep_sk(sk), *newpn;\n\tstruct sock *newsk = NULL;\n\tstruct sk_buff *skb;\n\tstruct pnpipehdr *hdr;\n\tstruct sockaddr_pn dst, src;\n\tint err;\n\tu16 peer_type;\n\tu8 pipe_handle, enabled, n_sb;\n\tu8 aligned = 0;\n\n\tskb = skb_recv_datagram(sk, 0, flags & O_NONBLOCK, errp);\n\tif (!skb)\n\t\treturn NULL;\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto drop;\n\t}\n\tsk_acceptq_removed(sk);\n\n\terr = -EPROTO;\n\tif (!pskb_may_pull(skb, sizeof(*hdr) + 4))\n\t\tgoto drop;\n\n\thdr = pnp_hdr(skb);\n\tpipe_handle = hdr->pipe_handle;\n\tswitch (hdr->state_after_connect) {\n\tcase PN_PIPE_DISABLE:\n\t\tenabled = 0;\n\t\tbreak;\n\tcase PN_PIPE_ENABLE:\n\t\tenabled = 1;\n\t\tbreak;\n\tdefault:\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_INVALID_PARAM,\n\t\t\t\tGFP_KERNEL);\n\t\tgoto drop;\n\t}\n\tpeer_type = hdr->other_pep_type << 8;\n\n\t/* Parse sub-blocks (options) */\n\tn_sb = hdr->data[3];\n\twhile (n_sb > 0) {\n\t\tu8 type, buf[1], len = sizeof(buf);\n\t\tconst u8 *data = pep_get_sb(skb, &type, &len, buf);\n\n\t\tif (data == NULL)\n\t\t\tgoto drop;\n\t\tswitch (type) {\n\t\tcase PN_PIPE_SB_CONNECT_REQ_PEP_SUB_TYPE:\n\t\t\tif (len < 1)\n\t\t\t\tgoto drop;\n\t\t\tpeer_type = (peer_type & 0xff00) | data[0];\n\t\t\tbreak;\n\t\tcase PN_PIPE_SB_ALIGNED_DATA:\n\t\t\taligned = data[0] != 0;\n\t\t\tbreak;\n\t\t}\n\t\tn_sb--;\n\t}\n\n\t/* Check for duplicate pipe handle */\n\tnewsk = pep_find_pipe(&pn->hlist, &dst, pipe_handle);\n\tif (unlikely(newsk)) {\n\t\t__sock_put(newsk);\n\t\tnewsk = NULL;\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE, GFP_KERNEL);\n\t\tgoto drop;\n\t}\n\n\t/* Create a new to-be-accepted sock */\n\tnewsk = sk_alloc(sock_net(sk), PF_PHONET, GFP_KERNEL, sk->sk_prot,\n\t\t\t kern);\n\tif (!newsk) {\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_OVERLOAD, GFP_KERNEL);\n\t\terr = -ENOBUFS;\n\t\tgoto drop;\n\t}\n\n\tsock_init_data(NULL, newsk);\n\tnewsk->sk_state = TCP_SYN_RECV;\n\tnewsk->sk_backlog_rcv = pipe_do_rcv;\n\tnewsk->sk_protocol = sk->sk_protocol;\n\tnewsk->sk_destruct = pipe_destruct;\n\n\tnewpn = pep_sk(newsk);\n\tpn_skb_get_dst_sockaddr(skb, &dst);\n\tpn_skb_get_src_sockaddr(skb, &src);\n\tnewpn->pn_sk.sobject = pn_sockaddr_get_object(&dst);\n\tnewpn->pn_sk.dobject = pn_sockaddr_get_object(&src);\n\tnewpn->pn_sk.resource = pn_sockaddr_get_resource(&dst);\n\tsock_hold(sk);\n\tnewpn->listener = sk;\n\tskb_queue_head_init(&newpn->ctrlreq_queue);\n\tnewpn->pipe_handle = pipe_handle;\n\tatomic_set(&newpn->tx_credits, 0);\n\tnewpn->ifindex = 0;\n\tnewpn->peer_type = peer_type;\n\tnewpn->rx_credits = 0;\n\tnewpn->rx_fc = newpn->tx_fc = PN_LEGACY_FLOW_CONTROL;\n\tnewpn->init_enable = enabled;\n\tnewpn->aligned = aligned;\n\n\terr = pep_accept_conn(newsk, skb);\n\tif (err) {\n\t\tsock_put(newsk);\n\t\tnewsk = NULL;\n\t\tgoto drop;\n\t}\n\tsk_add_node(newsk, &pn->hlist);\ndrop:\n\trelease_sock(sk);\n\tkfree_skb(skb);\n\t*errp = err;\n\treturn newsk;\n}", "func_hash": 98147170872893789319599497635563701391, "file_name": "pep.c", "file_hash": 271547007658605746827847008815001385986, "cwe": ["CWE-200"], "cve": "CVE-2021-45095", "cve_desc": "pep_sock_accept in net/phonet/pep.c in the Linux kernel through 5.15.8 has a refcount leak.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45095"}, "consensus_nodes": [{"type": "F_", "name": "pskb_may_pull", "code_reference": "pskb_may_pull(skb, sizeof(*hdr) + 4)", "line_start": 25, "line_end": 26, "rationale": "Minimum header length validation protecting against buffer over-read vulnerabilities.", "average_confidence": 0.95, "individual_confidences": [0.92, 0.98], "confidence_std": 0.042, "source_models": ["DeepSeek", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "F_:pskb_may_pull(skb,sizeof(hdr)4):20-20"}, {"type": "F_", "name": "pep_get_sb", "code_reference": "const u8 *data = pep_get_sb(skb, &type, &len, buf)", "line_start": 47, "line_end": 47, "rationale": "This function is a critical point for parsing sub-blocks. Incorrect length handling or insufficient bounds checking within this function directly leads to out-of-bounds reads or writes, triggering memory corruption or information leaks. Its correct functioning is paramount.", "average_confidence": 0.95, "individual_confidences": [0.95, 0.95], "confidence_std": 0.0, "source_models": ["Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "F_:constu8datapep_get_sb(skb,type,len,buf):40-40"}, {"type": "F_", "name": "skb_recv_datagram", "code_reference": "skb_recv_datagram(sk, 0, flags & O_NONBLOCK, errp)", "line_start": 15, "line_end": 16, "rationale": "Primary network input reception point; attacker-controlled data entry point with no rate limiting.", "average_confidence": 0.925, "individual_confidences": [0.95, 0.9], "confidence_std": 0.035, "source_models": ["DeepSeek", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "F_:skb_recv_datagram(sk,0,flagso_nonblock,errp):10-10"}, {"type": "F_", "name": "pep_accept_conn", "code_reference": "err = pep_accept_conn(newsk, skb)", "line_start": 103, "line_end": 103, "rationale": "This function encapsulates protocol-specific acceptance logic. Any vulnerabilities within the PEP protocol itself will manifest here, making it a critical point for security review and testing. It represents a trust boundary, and its implementation must be robust.", "average_confidence": 0.925, "individual_confidences": [0.9, 0.95], "confidence_std": 0.035, "source_models": ["Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "F_:errpep_accept_conn(newsk,skb):100-100"}, {"type": "F_", "name": "pep_find_pipe", "code_reference": "newsk = pep_find_pipe(&pn->hlist, &dst, pipe_handle)", "line_start": 65, "line_end": 65, "rationale": "This function checks for duplicate pipe handles using a hash table. A weak hash function or inadequate collision handling can expose the system to denial-of-service attacks by causing excessive hash collisions and slowing down lookups.", "average_confidence": 0.91, "individual_confidences": [0.85, 0.97], "confidence_std": 0.085, "source_models": ["Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "F_:newskpep_find_pipe(pnhlist,dst,pipe_handle):60-60"}, {"type": "M_", "name": "Input Sanitization", "code_reference": "N/A", "line_start": 0, "line_end": 0, "rationale": "Missing validation of skb->len vs claimed header length.", "average_confidence": 0.865, "individual_confidences": [0.9, 0.85, 0.88, 0.83], "confidence_std": 0.031, "source_models": ["DeepSeek", "DeepSeek", "DeepSeek", "DeepSeek"], "model_count": 4, "node_key": "M_:na:0-0"}, {"type": "F_", "name": "pn_skb_get_dst_sockaddr", "code_reference": "pn_skb_get_dst_sockaddr(skb, &dst)", "line_start": 86, "line_end": 86, "rationale": "This function parses the destination sockaddr from the skb. Insufficient validation can lead to address spoofing, where malicious actors can impersonate legitimate users or redirect traffic. The security of address assignment rests on the integrity of this function.", "average_confidence": 0.855, "individual_confidences": [0.75, 0.96], "confidence_std": 0.148, "source_models": ["Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "F_:pn_skb_get_dst_sockaddr(skb,dst):80-80"}, {"type": "F_", "name": "pn_skb_get_src_sockaddr", "code_reference": "pn_skb_get_src_sockaddr(skb, &src)", "line_start": 87, "line_end": 87, "rationale": "This function parses the source sockaddr from the skb. Insufficient validation can lead to address spoofing, where malicious actors can impersonate legitimate users or redirect traffic. The security of address assignment rests on the integrity of this function.", "average_confidence": 0.855, "individual_confidences": [0.75, 0.96], "confidence_std": 0.148, "source_models": ["Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "F_:pn_skb_get_src_sockaddr(skb,src):80-80"}], "consensus_statistics": {"total_nodes_before_filtering": 9, "total_nodes_after_filtering": 8, "confidence_threshold": 0.85, "average_confidence": 0.904375, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
