{"idx": 0, "original_item": {"idx": 0, "project": "openssl", "commit_id": "ca989269a2876bae79393bd54c3e72d49975fc75", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=ca989269a2876bae79393bd54c3e72d49975fc75", "commit_message": "Use version in SSL_METHOD not SSL structure.\n\nWhen deciding whether to use TLS 1.2 PRF and record hash algorithms\nuse the version number in the corresponding SSL_METHOD structure\ninstead of the SSL structure. The SSL structure version is sometimes\ninaccurate. Note: OpenSSL 1.0.2 and later effectively do this already.\n(CVE-2013-6449)", "target": 1, "func": " long ssl_get_algorithm2(SSL *s)\n        {\n        long alg2 = s->s3->tmp.new_cipher->algorithm2;\n       if (TLS1_get_version(s) >= TLS1_2_VERSION &&\n            alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))\n                return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;\n        return alg2;\n\t}\n", "func_hash": 255087747659226932756944884868284698117, "file_name": null, "file_hash": null, "cwe": ["CWE-310"], "cve": "CVE-2013-6449", "cve_desc": "The ssl_get_algorithm2 function in ssl/s3_lib.c in OpenSSL before 1.0.2 obtains a certain version number from an incorrect data structure, which allows remote attackers to cause a denial of service (daemon crash) via crafted traffic from a TLS 1.2 client.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6449", "extracted_cve": "CVE-2013-6449"}, "consensus_nodes": [{"type": "P_", "name": "SSL *s", "code_reference": "SSL *s", "line_start": 1, "line_end": 1, "rationale": "The SSL session pointer is a critical parameter; missing NULL checks could lead to NULL dereference and DoS.", "average_confidence": 0.9, "individual_confidences": [0.95, 0.8, 0.95], "confidence_std": 0.087, "source_models": ["DeepSeek", "Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 3, "node_key": "P_:ssls:0-0"}, {"type": "C_", "name": "TLS version comparison", "code_reference": "TLS1_get_version(s) >= TLS1_2_VERSION", "line_start": 4, "line_end": 4, "rationale": "Critical control flow for cryptographic strength; incorrect version checks could enable downgrade attacks.", "average_confidence": 0.9, "individual_confidences": [0.85, 0.9, 0.95], "confidence_std": 0.05, "source_models": ["DeepSeek", "Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 3, "node_key": "C_:tls1_get_version(s)tls1_2_version:0-0"}, {"type": "C_", "name": "Default algorithm comparison", "code_reference": "alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF)", "line_start": 4, "line_end": 4, "rationale": "Determines if SHA-256 upgrade is needed; tampering could weaken handshake security.", "average_confidence": 0.867, "individual_confidences": [0.8, 0.85, 0.95], "confidence_std": 0.076, "source_models": ["DeepSeek", "Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 3, "node_key": "C_:alg2(ssl_handshake_mac_defaulttls1_prf):0-0"}], "consensus_statistics": {"total_nodes_before_filtering": 3, "total_nodes_after_filtering": 3, "confidence_threshold": 0.85, "average_confidence": 0.889, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 1, "original_item": {"idx": 1, "project": "savannah", "commit_id": "190cef6eed37d0e73a73c1e205eb31d45ab60a3c", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=190cef6eed37d0e73a73c1e205eb31d45ab60a3c", "commit_message": "None", "target": 1, "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n       gnutls_assert ();\n       return ret;\n     }\n  *session_data_size = psession.size;\n \n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n \n   if (session_data != NULL)\n     memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}\n", "func_hash": 266005388725654386397960628110885023158, "file_name": null, "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-4128", "cve_desc": "Buffer overflow in the gnutls_session_get_data function in lib/gnutls_session.c in GnuTLS 2.12.x before 2.12.14 and 3.x before 3.0.7, when used on a client that performs nonstandard session resumption, allows remote TLS servers to cause a denial of service (application crash) via a large SessionTicket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4128", "extracted_cve": null}, "consensus_nodes": [{"type": "C_", "name": "Resumption Validity Check", "code_reference": "session->internals.resumable == RESUME_FALSE", "line_start": 5, "line_end": 6, "rationale": "Prevents processing of non-resumable sessions, mitigating session replay and invalid state access.", "average_confidence": 0.95, "individual_confidences": [0.95, 0.95], "confidence_std": 0.0, "source_models": ["DeepSeek", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "C_:sessioninternalsresumableresume_false:0-0"}, {"type": "F_", "name": "Session Data Copy", "code_reference": "memcpy(session_data, psession.data, psession.size)", "line_start": 22, "line_end": 23, "rationale": "Direct memory operation; failure in prior checks could lead to overflow or data leakage.", "average_confidence": 0.917, "individual_confidences": [0.8, 0.99, 0.96], "confidence_std": 0.102, "source_models": ["DeepSeek", "Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 3, "node_key": "F_:memcpy(session_data,psessiondata,psessionsize):20-20"}], "consensus_statistics": {"total_nodes_before_filtering": 3, "total_nodes_after_filtering": 2, "confidence_threshold": 0.85, "average_confidence": 0.9335, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 2, "original_item": {"idx": 2, "project": "savannah", "commit_id": "e82ef4545e9e98cbcb032f55d7c750b81e3a0450", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=e82ef4545e9e98cbcb032f55d7c750b81e3a0450", "commit_message": "None", "target": 1, "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n \n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n\n  if (session_data != NULL)\n    memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}\n", "func_hash": 162619476999663411812822607346255778028, "file_name": null, "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-4128", "cve_desc": "Buffer overflow in the gnutls_session_get_data function in lib/gnutls_session.c in GnuTLS 2.12.x before 2.12.14 and 3.x before 3.0.7, when used on a client that performs nonstandard session resumption, allows remote TLS servers to cause a denial of service (application crash) via a large SessionTicket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4128", "extracted_cve": null}, "consensus_nodes": [{"type": "C_", "name": "Resumption Validity Check", "code_reference": "session->internals.resumable == RESUME_FALSE", "line_start": 6, "line_end": 7, "rationale": "Prevents processing non-resumable sessions, critical for session integrity. Bypass could lead to invalid session resumption.", "average_confidence": 0.95, "individual_confidences": [0.95, 0.95], "confidence_std": 0.0, "source_models": ["DeepSeek", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "C_:sessioninternalsresumableresume_false:0-0"}, {"type": "F_", "name": "Session Serialization", "code_reference": "_gnutls_session_pack(session, &psession)", "line_start": 10, "line_end": 14, "rationale": "Handles sensitive session state serialization. Insecure implementation could leak or tamper with session secrets.", "average_confidence": 0.95, "individual_confidences": [0.9, 1.0], "confidence_std": 0.071, "source_models": ["DeepSeek", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "F_:_gnutls_session_pack(session,psession):10-10"}, {"type": "C_", "name": "Buffer Bounds Check", "code_reference": "psession.size > *session_data_size", "line_start": 16, "line_end": 19, "rationale": "Mitigates buffer overflow during memcpy. Failure could lead to memory corruption.", "average_confidence": 0.925, "individual_confidences": [0.85, 1.0], "confidence_std": 0.106, "source_models": ["DeepSeek", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "C_:psessionsizesession_data_size:10-10"}, {"type": "F_", "name": "Session Data Copy", "code_reference": "memcpy(session_data, psession.data, psession.size)", "line_start": 21, "line_end": 22, "rationale": "Copies sensitive session data. Relies on prior size checks; insecure buffer could lead to exposure.", "average_confidence": 0.923, "individual_confidences": [0.8, 1.0, 0.97], "confidence_std": 0.108, "source_models": ["DeepSeek", "Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 3, "node_key": "F_:memcpy(session_data,psessiondata,psessionsize):20-20"}, {"type": "F_", "name": "Resource Deallocation", "code_reference": "_gnutls_free_datum(&psession)", "line_start": 25, "line_end": 25, "rationale": "Frees temporary session data. Lack of zeroization could leave secrets in memory.", "average_confidence": 0.865, "individual_confidences": [0.75, 0.98], "confidence_std": 0.163, "source_models": ["DeepSeek", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "F_:_gnutls_free_datum(psession):20-20"}], "consensus_statistics": {"total_nodes_before_filtering": 6, "total_nodes_after_filtering": 5, "confidence_threshold": 0.85, "average_confidence": 0.9226, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 3, "original_item": {"idx": 3, "project": "savannah", "commit_id": "075d7556964f5a871a73c22ac4b69f5361295099", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/wget.git/commit/?id=075d7556964f5a871a73c22ac4b69f5361295099", "commit_message": "None", "target": 1, "func": "getftp (struct url *u, wgint passed_expected_bytes, wgint *qtyread,\n        wgint restval, ccon *con, int count, wgint *last_expected_bytes,\n        FILE *warc_tmp)\n{\n  int csock, dtsock, local_sock, res;\n  uerr_t err = RETROK;          /* appease the compiler */\n  FILE *fp;\n   char *respline, *tms;\n   const char *user, *passwd, *tmrate;\n   int cmd = con->cmd;\n  bool pasv_mode_open = false;\n   wgint expected_bytes = 0;\n   bool got_expected_bytes = false;\n   bool rest_failed = false;\n  bool rest_failed = false;\n  int flags;\n  wgint rd_size, previous_rd_size = 0;\n  char type_char;\n  bool try_again;\n  bool list_a_used = false;\n\n  assert (con != NULL);\n  assert (con->target != NULL);\n\n  /* Debug-check of the sanity of the request by making sure that LIST\n     and RETR are never both requested (since we can handle only one\n     at a time.  */\n  assert (!((cmd & DO_LIST) && (cmd & DO_RETR)));\n  /* Make sure that at least *something* is requested.  */\n  assert ((cmd & (DO_LIST | DO_CWD | DO_RETR | DO_LOGIN)) != 0);\n\n  *qtyread = restval;\n\n  user = u->user;\n  passwd = u->passwd;\n  search_netrc (u->host, (const char **)&user, (const char **)&passwd, 1);\n  user = user ? user : (opt.ftp_user ? opt.ftp_user : opt.user);\n  if (!user) user = \"anonymous\";\n  passwd = passwd ? passwd : (opt.ftp_passwd ? opt.ftp_passwd : opt.passwd);\n  if (!passwd) passwd = \"-wget@\";\n\n  dtsock = -1;\n  local_sock = -1;\n  con->dltime = 0;\n\n  if (!(cmd & DO_LOGIN))\n    csock = con->csock;\n  else                          /* cmd & DO_LOGIN */\n    {\n      char    *host = con->proxy ? con->proxy->host : u->host;\n      int      port = con->proxy ? con->proxy->port : u->port;\n\n      /* Login to the server: */\n\n      /* First: Establish the control connection.  */\n\n      csock = connect_to_host (host, port);\n      if (csock == E_HOST)\n          return HOSTERR;\n      else if (csock < 0)\n          return (retryable_socket_connect_error (errno)\n                  ? CONERROR : CONIMPOSSIBLE);\n\n      if (cmd & LEAVE_PENDING)\n        con->csock = csock;\n      else\n        con->csock = -1;\n\n      /* Second: Login with proper USER/PASS sequence.  */\n      logprintf (LOG_VERBOSE, _(\"Logging in as %s ... \"),\n                 quotearg_style (escape_quoting_style, user));\n      if (opt.server_response)\n        logputs (LOG_ALWAYS, \"\\n\");\n      if (con->proxy)\n        {\n          /* If proxy is in use, log in as username@target-site. */\n          char *logname = concat_strings (user, \"@\", u->host, (char *) 0);\n          err = ftp_login (csock, logname, passwd);\n          xfree (logname);\n        }\n      else\n        err = ftp_login (csock, user, passwd);\n\n      /* FTPRERR, FTPSRVERR, WRITEFAILED, FTPLOGREFUSED, FTPLOGINC */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPSRVERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"Error in server greeting.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPLOGREFUSED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"The server refuses login.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return FTPLOGREFUSED;\n        case FTPLOGINC:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"Login incorrect.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return FTPLOGINC;\n        case FTPOK:\n          if (!opt.server_response)\n            logputs (LOG_VERBOSE, _(\"Logged in!\\n\"));\n          break;\n        default:\n          abort ();\n        }\n      /* Third: Get the system type */\n      if (!opt.server_response)\n        logprintf (LOG_VERBOSE, \"==> SYST ... \");\n      err = ftp_syst (csock, &con->rs, &con->rsu);\n      /* FTPRERR */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPSRVERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Server error, can't determine system type.\\n\"));\n          break;\n        case FTPOK:\n          /* Everything is OK.  */\n          break;\n        default:\n          abort ();\n        }\n      if (!opt.server_response && err != FTPSRVERR)\n        logputs (LOG_VERBOSE, _(\"done.    \"));\n\n      /* 2013-10-17 Andrea Urbani (matfanjol)\n         According to the system type I choose which\n         list command will be used.\n         If I don't know that system, I will try, the\n         first time of each session, \"LIST -a\" and\n         \"LIST\". (see __LIST_A_EXPLANATION__ below) */\n      switch (con->rs)\n        {\n        case ST_VMS:\n          /* About ST_VMS there is an old note:\n             2008-01-29  SMS.  For a VMS FTP server, where \"LIST -a\" may not\n             fail, but will never do what is desired here,\n             skip directly to the simple \"LIST\" command\n             (assumed to be the last one in the list).  */\n          DEBUGP ((\"\\nVMS: I know it and I will use \\\"LIST\\\" as standard list command\\n\"));\n          con->st |= LIST_AFTER_LIST_A_CHECK_DONE;\n          con->st |= AVOID_LIST_A;\n          break;\n        case ST_UNIX:\n          if (con->rsu == UST_MULTINET)\n            {\n              DEBUGP ((\"\\nUNIX MultiNet: I know it and I will use \\\"LIST\\\" \"\n                       \"as standard list command\\n\"));\n              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;\n              con->st |= AVOID_LIST_A;\n            }\n          else if (con->rsu == UST_TYPE_L8)\n            {\n              DEBUGP ((\"\\nUNIX TYPE L8: I know it and I will use \\\"LIST -a\\\" \"\n                       \"as standard list command\\n\"));\n              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;\n              con->st |= AVOID_LIST;\n            }\n          break;\n        default:\n          break;\n        }\n\n      /* Fourth: Find the initial ftp directory */\n\n      if (!opt.server_response)\n        logprintf (LOG_VERBOSE, \"==> PWD ... \");\n      err = ftp_pwd (csock, &con->id);\n      /* FTPRERR */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPSRVERR :\n          /* PWD unsupported -- assume \"/\". */\n          xfree (con->id);\n          con->id = xstrdup (\"/\");\n          break;\n        case FTPOK:\n          /* Everything is OK.  */\n          break;\n        default:\n          abort ();\n        }\n\n#if 0\n      /* 2004-09-17 SMS.\n         Don't help me out.  Please.\n         A reasonably recent VMS FTP server will cope just fine with\n         UNIX file specifications.  This code just spoils things.\n         Discarding the device name, for example, is not a wise move.\n         This code was disabled but left in as an example of what not\n         to do.\n      */\n\n      /* VMS will report something like \"PUB$DEVICE:[INITIAL.FOLDER]\".\n         Convert it to \"/INITIAL/FOLDER\" */\n      if (con->rs == ST_VMS)\n        {\n          char *path = strchr (con->id, '[');\n          char *pathend = path ? strchr (path + 1, ']') : NULL;\n          if (!path || !pathend)\n            DEBUGP ((\"Initial VMS directory not in the form [...]!\\n\"));\n          else\n            {\n              char *idir = con->id;\n              DEBUGP ((\"Preprocessing the initial VMS directory\\n\"));\n              DEBUGP ((\"  old = '%s'\\n\", con->id));\n              /* We do the conversion in-place by copying the stuff\n                 between [ and ] to the beginning, and changing dots\n                 to slashes at the same time.  */\n              *idir++ = '/';\n              for (++path; path < pathend; path++, idir++)\n                *idir = *path == '.' ? '/' : *path;\n              *idir = '\\0';\n              DEBUGP ((\"  new = '%s'\\n\\n\", con->id));\n            }\n        }\n#endif /* 0 */\n\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.\\n\"));\n\n      /* Fifth: Set the FTP type.  */\n      type_char = ftp_process_type (u->params);\n      if (!opt.server_response)\n        logprintf (LOG_VERBOSE, \"==> TYPE %c ... \", type_char);\n      err = ftp_type (csock, type_char);\n      /* FTPRERR, WRITEFAILED, FTPUNKNOWNTYPE */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPUNKNOWNTYPE:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logprintf (LOG_NOTQUIET,\n                     _(\"Unknown type `%c', closing control connection.\\n\"),\n                     type_char);\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPOK:\n          /* Everything is OK.  */\n          break;\n        default:\n          abort ();\n        }\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.  \"));\n    } /* do login */\n\n  if (cmd & DO_CWD)\n    {\n      if (!*u->dir)\n        logputs (LOG_VERBOSE, _(\"==> CWD not needed.\\n\"));\n      else\n        {\n          const char *targ = NULL;\n          int cwd_count;\n          int cwd_end;\n          int cwd_start;\n\n          char *target = u->dir;\n\n          DEBUGP ((\"changing working directory\\n\"));\n\n          /* Change working directory.  To change to a non-absolute\n             Unix directory, we need to prepend initial directory\n             (con->id) to it.  Absolute directories \"just work\".\n\n             A relative directory is one that does not begin with '/'\n             and, on non-Unix OS'es, one that doesn't begin with\n             \"[a-z]:\".\n\n             This is not done for OS400, which doesn't use\n             \"/\"-delimited directories, nor does it support directory\n             hierarchies.  \"CWD foo\" followed by \"CWD bar\" leaves us\n             in \"bar\", not in \"foo/bar\", as would be customary\n             elsewhere.  */\n\n            /* 2004-09-20 SMS.\n               Why is this wise even on UNIX?  It certainly fouls VMS.\n               See below for a more reliable, more universal method.\n            */\n\n            /* 2008-04-22 MJC.\n               I'm not crazy about it either. I'm informed it's useful\n               for misconfigured servers that have some dirs in the path\n               with +x but -r, but this method is not RFC-conformant. I\n               understand the need to deal with crappy server\n               configurations, but it's far better to use the canonical\n               method first, and fall back to kludges second.\n            */\n\n          if (target[0] != '/'\n              && !(con->rs != ST_UNIX\n                   && c_isalpha (target[0])\n                   && target[1] == ':')\n              && (con->rs != ST_OS400)\n              && (con->rs != ST_VMS))\n            {\n              int idlen = strlen (con->id);\n              char *ntarget, *p;\n\n              /* Strip trailing slash(es) from con->id. */\n              while (idlen > 0 && con->id[idlen - 1] == '/')\n                --idlen;\n              p = ntarget = (char *)alloca (idlen + 1 + strlen (u->dir) + 1);\n              memcpy (p, con->id, idlen);\n              p += idlen;\n              *p++ = '/';\n              strcpy (p, target);\n\n              DEBUGP ((\"Prepended initial PWD to relative path:\\n\"));\n              DEBUGP ((\"   pwd: '%s'\\n   old: '%s'\\n  new: '%s'\\n\",\n                       con->id, target, ntarget));\n              target = ntarget;\n            }\n\n#if 0\n          /* 2004-09-17 SMS.\n             Don't help me out.  Please.\n             A reasonably recent VMS FTP server will cope just fine with\n             UNIX file specifications.  This code just spoils things.\n             Discarding the device name, for example, is not a wise\n             move.\n             This code was disabled but left in as an example of what\n             not to do.\n          */\n\n          /* If the FTP host runs VMS, we will have to convert the absolute\n             directory path in UNIX notation to absolute directory path in\n             VMS notation as VMS FTP servers do not like UNIX notation of\n             absolute paths.  \"VMS notation\" is [dir.subdir.subsubdir]. */\n\n          if (con->rs == ST_VMS)\n            {\n              char *tmpp;\n              char *ntarget = (char *)alloca (strlen (target) + 2);\n              /* We use a converted initial dir, so directories in\n                 TARGET will be separated with slashes, something like\n                 \"/INITIAL/FOLDER/DIR/SUBDIR\".  Convert that to\n                 \"[INITIAL.FOLDER.DIR.SUBDIR]\".  */\n              strcpy (ntarget, target);\n              assert (*ntarget == '/');\n              *ntarget = '[';\n              for (tmpp = ntarget + 1; *tmpp; tmpp++)\n                if (*tmpp == '/')\n                  *tmpp = '.';\n              *tmpp++ = ']';\n              *tmpp = '\\0';\n              DEBUGP ((\"Changed file name to VMS syntax:\\n\"));\n              DEBUGP ((\"  Unix: '%s'\\n  VMS: '%s'\\n\", target, ntarget));\n              target = ntarget;\n            }\n#endif /* 0 */\n\n          /* 2004-09-20 SMS.\n             A relative directory is relative to the initial directory.\n             Thus, what _is_ useful on VMS (and probably elsewhere) is\n             to CWD to the initial directory (ideally, whatever the\n             server reports, _exactly_, NOT badly UNIX-ixed), and then\n             CWD to the (new) relative directory.  This should probably\n             be restructured as a function, called once or twice, but\n             I'm lazy enough to take the badly indented loop short-cut\n             for now.\n          */\n\n          /* Decide on one pass (absolute) or two (relative).\n             The VMS restriction may be relaxed when the squirrely code\n             above is reformed.\n          */\n          if ((con->rs == ST_VMS) && (target[0] != '/'))\n            {\n              cwd_start = 0;\n              DEBUGP ((\"Using two-step CWD for relative path.\\n\"));\n            }\n          else\n            {\n              /* Go straight to the target. */\n              cwd_start = 1;\n            }\n\n          /* At least one VMS FTP server (TCPware V5.6-2) can switch to\n             a UNIX emulation mode when given a UNIX-like directory\n             specification (like \"a/b/c\").  If allowed to continue this\n             way, LIST interpretation will be confused, because the\n             system type (SYST response) will not be re-checked, and\n             future UNIX-format directory listings (for multiple URLs or\n             \"-r\") will be horribly misinterpreted.\n\n             The cheap and nasty work-around is to do a \"CWD []\" after a\n             UNIX-like directory specification is used.  (A single-level\n             directory is harmless.)  This puts the TCPware server back\n             into VMS mode, and does no harm on other servers.\n\n             Unlike the rest of this block, this particular behavior\n             _is_ VMS-specific, so it gets its own VMS test.\n          */\n          if ((con->rs == ST_VMS) && (strchr( target, '/') != NULL))\n            {\n              cwd_end = 3;\n              DEBUGP ((\"Using extra \\\"CWD []\\\" step for VMS server.\\n\"));\n            }\n          else\n            {\n              cwd_end = 2;\n            }\n\n          /* 2004-09-20 SMS. */\n          /* Sorry about the deviant indenting.  Laziness. */\n\n          for (cwd_count = cwd_start; cwd_count < cwd_end; cwd_count++)\n            {\n              switch (cwd_count)\n                {\n                  case 0:\n                    /* Step one (optional): Go to the initial directory,\n                       exactly as reported by the server.\n                    */\n                    targ = con->id;\n                    break;\n\n                  case 1:\n                    /* Step two: Go to the target directory.  (Absolute or\n                       relative will work now.)\n                    */\n                    targ = target;\n                    break;\n\n                  case 2:\n                    /* Step three (optional): \"CWD []\" to restore server\n                       VMS-ness.\n                    */\n                    targ = \"[]\";\n                    break;\n\n                  default:\n                    logprintf (LOG_ALWAYS, _(\"Logically impossible section reached in getftp()\"));\n                    logprintf (LOG_ALWAYS, _(\"cwd_count: %d\\ncwd_start: %d\\ncwd_end: %d\\n\"),\n                                             cwd_count, cwd_start, cwd_end);\n                    abort ();\n                }\n\n              if (!opt.server_response)\n                logprintf (LOG_VERBOSE, \"==> CWD (%d) %s ... \", cwd_count,\n                           quotearg_style (escape_quoting_style, target));\n\n              err = ftp_cwd (csock, targ);\n\n              /* FTPRERR, WRITEFAILED, FTPNSFOD */\n              switch (err)\n                {\n                  case FTPRERR:\n                    logputs (LOG_VERBOSE, \"\\n\");\n                    logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n                    fd_close (csock);\n                    con->csock = -1;\n                    return err;\n                  case WRITEFAILED:\n                    logputs (LOG_VERBOSE, \"\\n\");\n                    logputs (LOG_NOTQUIET,\n                             _(\"Write failed, closing control connection.\\n\"));\n                    fd_close (csock);\n                    con->csock = -1;\n                    return err;\n                  case FTPNSFOD:\n                    logputs (LOG_VERBOSE, \"\\n\");\n                    logprintf (LOG_NOTQUIET, _(\"No such directory %s.\\n\\n\"),\n                               quote (u->dir));\n                    fd_close (csock);\n                    con->csock = -1;\n                    return err;\n                  case FTPOK:\n                    break;\n                  default:\n                    abort ();\n                }\n\n              if (!opt.server_response)\n                logputs (LOG_VERBOSE, _(\"done.\\n\"));\n\n            } /* for */\n\n          /* 2004-09-20 SMS. */\n\n        } /* else */\n    }\n  else /* do not CWD */\n    logputs (LOG_VERBOSE, _(\"==> CWD not required.\\n\"));\n\n  if ((cmd & DO_RETR) && passed_expected_bytes == 0)\n    {\n      if (opt.verbose)\n        {\n          if (!opt.server_response)\n            logprintf (LOG_VERBOSE, \"==> SIZE %s ... \",\n                       quotearg_style (escape_quoting_style, u->file));\n        }\n\n      err = ftp_size (csock, u->file, &expected_bytes);\n      /* FTPRERR */\n      switch (err)\n        {\n        case FTPRERR:\n        case FTPSRVERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPOK:\n          got_expected_bytes = true;\n          /* Everything is OK.  */\n          break;\n        default:\n          abort ();\n        }\n        if (!opt.server_response)\n          {\n            logprintf (LOG_VERBOSE, \"%s\\n\",\n                    expected_bytes ?\n                    number_to_static_string (expected_bytes) :\n                    _(\"done.\\n\"));\n          }\n    }\n\n  if (cmd & DO_RETR && restval > 0 && restval == expected_bytes)\n    {\n      /* Server confirms that file has length restval. We should stop now.\n         Some servers (f.e. NcFTPd) return error when receive REST 0 */\n      logputs (LOG_VERBOSE, _(\"File has already been retrieved.\\n\"));\n      fd_close (csock);\n      con->csock = -1;\n      return RETRFINISHED;\n    }\n\n  do\n  {\n  try_again = false;\n  /* If anything is to be retrieved, PORT (or PASV) must be sent.  */\n  if (cmd & (DO_LIST | DO_RETR))\n    {\n      if (opt.ftp_pasv)\n        {\n          ip_address passive_addr;\n          int        passive_port;\n          err = ftp_do_pasv (csock, &passive_addr, &passive_port);\n          /* FTPRERR, WRITEFAILED, FTPNOPASV, FTPINVPASV */\n          switch (err)\n            {\n            case FTPRERR:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              return err;\n            case WRITEFAILED:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET,\n                       _(\"Write failed, closing control connection.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              return err;\n            case FTPNOPASV:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET, _(\"Cannot initiate PASV transfer.\\n\"));\n              break;\n            case FTPINVPASV:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET, _(\"Cannot parse PASV response.\\n\"));\n              break;\n            case FTPOK:\n              break;\n            default:\n              abort ();\n            }   /* switch (err) */\n          if (err==FTPOK)\n            {\n              DEBUGP ((\"trying to connect to %s port %d\\n\",\n                      print_address (&passive_addr), passive_port));\n              dtsock = connect_to_ip (&passive_addr, passive_port, NULL);\n              if (dtsock < 0)\n                {\n                  int save_errno = errno;\n                  fd_close (csock);\n                  con->csock = -1;\n                  logprintf (LOG_VERBOSE, _(\"couldn't connect to %s port %d: %s\\n\"),\n                             print_address (&passive_addr), passive_port,\n                             strerror (save_errno));\n                           ? CONERROR : CONIMPOSSIBLE);\n                 }\n \n              pasv_mode_open = true;  /* Flag to avoid accept port */\n               if (!opt.server_response)\n                 logputs (LOG_VERBOSE, _(\"done.    \"));\n            } /* err==FTP_OK */\n        }\n \n      if (!pasv_mode_open)   /* Try to use a port command if PASV failed */\n         {\n           err = ftp_do_port (csock, &local_sock);\n           /* FTPRERR, WRITEFAILED, bindport (FTPSYSERR), HOSTERR,\n              logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              fd_close (dtsock);\n              fd_close (local_sock);\n              return err;\n            case WRITEFAILED:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET,\n                       _(\"Write failed, closing control connection.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              fd_close (dtsock);\n              fd_close (local_sock);\n              return err;\n            case CONSOCKERR:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logprintf (LOG_NOTQUIET, \"socket: %s\\n\", strerror (errno));\n              fd_close (csock);\n              con->csock = -1;\n              fd_close (dtsock);\n              fd_close (local_sock);\n              return err;\n            case FTPSYSERR:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logprintf (LOG_NOTQUIET, _(\"Bind error (%s).\\n\"),\n                         strerror (errno));\n              fd_close (dtsock);\n              return err;\n            case FTPPORTERR:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET, _(\"Invalid PORT.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              fd_close (dtsock);\n              fd_close (local_sock);\n              return err;\n            case FTPOK:\n              break;\n            default:\n              abort ();\n            } /* port switch */\n          if (!opt.server_response)\n            logputs (LOG_VERBOSE, _(\"done.    \"));\n        } /* dtsock == -1 */\n    } /* cmd & (DO_LIST | DO_RETR) */\n\n  /* Restart if needed.  */\n  if (restval && (cmd & DO_RETR))\n    {\n      if (!opt.server_response)\n        logprintf (LOG_VERBOSE, \"==> REST %s ... \",\n                   number_to_static_string (restval));\n      err = ftp_rest (csock, restval);\n\n      /* FTPRERR, WRITEFAILED, FTPRESTFAIL */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPRESTFAIL:\n          logputs (LOG_VERBOSE, _(\"\\nREST failed, starting from scratch.\\n\"));\n          rest_failed = true;\n          break;\n        case FTPOK:\n          break;\n        default:\n          abort ();\n        }\n      if (err != FTPRESTFAIL && !opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.    \"));\n    } /* restval && cmd & DO_RETR */\n\n  if (cmd & DO_RETR)\n    {\n      /* If we're in spider mode, don't really retrieve anything except\n         the directory listing and verify whether the given \"file\" exists.  */\n      if (opt.spider)\n        {\n          bool exists = false;\n          struct fileinfo *f;\n          uerr_t _res = ftp_get_listing (u, con, &f);\n          /* Set the DO_RETR command flag again, because it gets unset when\n             calling ftp_get_listing() and would otherwise cause an assertion\n             failure earlier on when this function gets repeatedly called\n             (e.g., when recursing).  */\n          con->cmd |= DO_RETR;\n          if (_res == RETROK)\n            {\n              while (f)\n                {\n                  if (!strcmp (f->name, u->file))\n                    {\n                      exists = true;\n                      break;\n                    }\n                  f = f->next;\n                }\n              if (exists)\n                {\n                  logputs (LOG_VERBOSE, \"\\n\");\n                  logprintf (LOG_NOTQUIET, _(\"File %s exists.\\n\"),\n                             quote (u->file));\n                }\n              else\n                {\n                  logputs (LOG_VERBOSE, \"\\n\");\n                  logprintf (LOG_NOTQUIET, _(\"No such file %s.\\n\"),\n                             quote (u->file));\n                }\n            }\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return RETRFINISHED;\n        }\n\n      if (opt.verbose)\n        {\n          if (!opt.server_response)\n            {\n              if (restval)\n                logputs (LOG_VERBOSE, \"\\n\");\n              logprintf (LOG_VERBOSE, \"==> RETR %s ... \",\n                         quotearg_style (escape_quoting_style, u->file));\n            }\n        }\n\n      err = ftp_retr (csock, u->file);\n      /* FTPRERR, WRITEFAILED, FTPNSFOD */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPNSFOD:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logprintf (LOG_NOTQUIET, _(\"No such file %s.\\n\\n\"),\n                     quote (u->file));\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPOK:\n          break;\n        default:\n          abort ();\n        }\n\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.\\n\"));\n\n      if (! got_expected_bytes)\n        expected_bytes = *last_expected_bytes;\n    } /* do retrieve */\n\n  if (cmd & DO_LIST)\n    {\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, \"==> LIST ... \");\n      /* As Maciej W. Rozycki (macro@ds2.pg.gda.pl) says, `LIST'\n         without arguments is better than `LIST .'; confirmed by\n         RFC959.  */\n      err = ftp_list (csock, NULL, con->st&AVOID_LIST_A, con->st&AVOID_LIST, &list_a_used);\n\n      /* FTPRERR, WRITEFAILED */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPNSFOD:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logprintf (LOG_NOTQUIET, _(\"No such file or directory %s.\\n\\n\"),\n                     quote (\".\"));\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPOK:\n          break;\n        default:\n          abort ();\n        }\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.\\n\"));\n\n      if (! got_expected_bytes)\n        expected_bytes = *last_expected_bytes;\n    } /* cmd & DO_LIST */\n\n  if (!(cmd & (DO_LIST | DO_RETR)) || (opt.spider && !(cmd & DO_LIST)))\n    return RETRFINISHED;\n\n  /* Some FTP servers return the total length of file after REST\n     command, others just return the remaining size. */\n  if (passed_expected_bytes && restval && expected_bytes\n      && (expected_bytes == passed_expected_bytes - restval))\n    {\n      DEBUGP ((\"Lying FTP server found, adjusting.\\n\"));\n      expected_bytes = passed_expected_bytes;\n    }\n\n  /* If no transmission was required, then everything is OK.  */\n  if (!pasv_mode_open)  /* we are not using pasive mode so we need\n                              to accept */\n     }\n", "func_hash": 114753069609161113628525870463495041364, "file_name": null, "file_hash": null, "cwe": ["CWE-200"], "cve": "CVE-2015-7665", "cve_desc": "Tails before 1.7 includes the wget program but does not prevent automatic fallback from passive FTP to active FTP, which allows remote FTP servers to discover the Tor client IP address by reading a (1) PORT or (2) EPRT command.  NOTE: within wget itself, the automatic fallback is not considered a vulnerability by CVE.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-7665", "extracted_cve": null}, "consensus_nodes": [{"type": "F_", "name": "Unauthenticated connection", "code_reference": "connect_to_host", "line_start": 60, "line_end": 65, "rationale": "Creates unencrypted channel vulnerable to MITM attacks without certificate validation.", "average_confidence": 0.98, "individual_confidences": [0.98], "confidence_std": 0.0, "source_models": ["DeepSeek"], "model_count": 1, "node_key": "F_:connect_to_host:60-60"}, {"type": "P_", "name": "u", "code_reference": "u->user, u->passwd, u->host, u->port, u->dir, u->file, u->params", "line_start": 0, "line_end": 0, "rationale": "The URL structure 'u' is the entry point for user-supplied data, controlling host, port, path, and file. It directly influences connection establishment, directory navigation, and file retrieval, making it a primary source of potential injection vulnerabilities. Improper handling of fields like 'u->dir' and 'u->file' directly leads to directory traversal or command injection.", "average_confidence": 0.95, "individual_confidences": [0.95], "confidence_std": 0.0, "source_models": ["Gemini-2.0-Flash"], "model_count": 1, "node_key": "P_:uuser,upasswd,uhost,uport,udir,ufile,uparams:0-0"}, {"type": "V_", "name": "Default Credentials", "code_reference": "user, passwd", "line_start": 44, "line_end": 55, "rationale": "Hardcoded default credentials ('anonymous', '-wget@') can be exploited if the server allows anonymous access, leading to unauthorized access.", "average_confidence": 0.95, "individual_confidences": [0.95], "confidence_std": 0.0, "source_models": ["Qwen2.5-Coder-32B"], "model_count": 1, "node_key": "V_:user,passwd:40-50"}], "consensus_statistics": {"total_nodes_before_filtering": 3, "total_nodes_after_filtering": 3, "confidence_threshold": 0.85, "average_confidence": 0.96, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 5, "original_item": {"idx": 5, "project": "ghostscript", "commit_id": "83d4dae44c71816c084a635550acc1a51529b881", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=83d4dae44c71816c084a635550acc1a51529b881;hp=f597300439e62f5e921f0d7b1e880b5c1a1f1607", "commit_message": "None", "target": 1, "func": "void fz_init_cached_color_converter(fz_context *ctx, fz_color_converter *cc, fz_colorspace *is, fz_colorspace *ds, fz_colorspace *ss, const fz_color_params *params)\n{\n\tint n = ss->n;\n\tfz_cached_color_converter *cached = fz_malloc_struct(ctx, fz_cached_color_converter);\n\n\tcc->opaque = cached;\n\tcc->convert = fz_cached_color_convert;\n\tcc->ds = ds ? ds : fz_device_gray(ctx);\n\tcc->ss = ss;\n\tcc->is = is;\n\n\tfz_try(ctx)\n\t{\n\t\tfz_find_color_converter(ctx, &cached->base, is, cc->ds, ss, params);\n\t\tcached->hash = fz_new_hash_table(ctx, 256, n * sizeof(float), -1, fz_free);\n\t}\n\tfz_catch(ctx)\n\t{\n                fz_drop_color_converter(ctx, &cached->base);\n                fz_drop_hash_table(ctx, cached->hash);\n                fz_free(ctx, cached);\n                fz_rethrow(ctx);\n        }\n }\n", "func_hash": 183139468890710880163111516517773812467, "file_name": "colorspace.c", "file_hash": 6862521774369016489561977411663164923, "cwe": ["CWE-20"], "cve": "CVE-2018-1000040", "cve_desc": "In MuPDF 1.12.0 and earlier, multiple use of uninitialized value bugs in the PDF parser could allow an attacker to cause a denial of service (crash) or influence program flow via a crafted file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-1000040", "extracted_cve": null}, "consensus_nodes": [{"type": "F_", "name": "Memory allocation for fz_cached_color_converter", "code_reference": "fz_malloc_struct(ctx, fz_cached_color_converter)", "line_start": 4, "line_end": 4, "rationale": "Memory allocation failure could lead to NULL pointer dereference or heap corruption. Critical for memory safety.", "average_confidence": 0.933, "individual_confidences": [0.95, 0.9, 0.95], "confidence_std": 0.029, "source_models": ["DeepSeek", "Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 3, "node_key": "F_:fz_malloc_struct(ctx,fz_cached_color_converter):0-0"}, {"type": "F_", "name": "Hash table for caching color conversions", "code_reference": "fz_new_hash_table(ctx, 256, n * sizeof(float), -1, fz_free)", "line_start": 12, "line_end": 12, "rationale": "Fixed-size hash table could lead to collisions (DoS risk). Potential integer overflow in size calculation.", "average_confidence": 0.933, "individual_confidences": [0.9, 0.95, 0.95], "confidence_std": 0.029, "source_models": ["DeepSeek", "Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 3, "node_key": "F_:fz_new_hash_table(ctx,256,nsizeof(float),1,fz_free):10-10"}, {"type": "F_", "name": "Base converter initialization", "code_reference": "fz_find_color_converter(ctx, &cached->base, is, cc->ds, ss, params)", "line_start": 11, "line_end": 11, "rationale": "Critical security boundary where invalid color spaces could cause crashes or incorrect conversions.", "average_confidence": 0.89, "individual_confidences": [0.98, 0.8], "confidence_std": 0.127, "source_models": ["DeepSeek", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "F_:fz_find_color_converter(ctx,cachedbase,is,ccds,ss,params):10-10"}], "consensus_statistics": {"total_nodes_before_filtering": 3, "total_nodes_after_filtering": 3, "confidence_threshold": 0.85, "average_confidence": 0.9186666666666667, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 6, "original_item": {"idx": 6, "project": "ghostscript", "commit_id": "f597300439e62f5e921f0d7b1e880b5c1a1f1607", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=f597300439e62f5e921f0d7b1e880b5c1a1f1607;hp=093fc3b098dc5fadef5d8ad4b225db9fb124758b", "commit_message": "None", "target": 1, "func": "add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)\n{\n\tint current;\n\tcmap_splay *tree;\n\n\tif (low > high)\n\t{\n\t\tfz_warn(ctx, \"range limits out of range in cmap %s\", cmap->cmap_name);\n\t\treturn;\n\t}\n\n\ttree = cmap->tree;\n\n\tif (cmap->tlen)\n\t{\n\t\tunsigned int move = cmap->ttop;\n\t\tunsigned int gt = EMPTY;\n\t\tunsigned int lt = EMPTY;\n\t\tif (check_for_overlap)\n\t\t{\n\t\t\t/* Check for collision with the current node */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\t/* Cases we might meet:\n\t\t\t\t * tree[i]:        <----->\n\t\t\t\t * case 0:     <->\n\t\t\t\t * case 1:     <------->\n\t\t\t\t * case 2:     <------------->\n\t\t\t\t * case 3:           <->\n\t\t\t\t * case 4:           <------->\n\t\t\t\t * case 5:                 <->\n\t\t\t\t */\n\t\t\t\tif (low <= tree[current].low && tree[current].low <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 1, reduces to case 0 */\n\t\t\t\t\t/* or case 2, deleting the node */\n\t\t\t\t\ttree[current].out += high + 1 - tree[current].low;\n\t\t\t\t\ttree[current].low = high + 1;\n\t\t\t\t\tif (tree[current].low > tree[current].high)\n\t\t\t\t\t{\n\t\t\t\t\t\tmove = delete_node(cmap, current);\n\t\t\t\t\t\tcurrent = EMPTY;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (low <= tree[current].high && tree[current].high <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 4, reduces to case 5 */\n\t\t\t\t\ttree[current].high = low - 1;\n\t\t\t\t\tassert(tree[current].low <= tree[current].high);\n\t\t\t\t}\n\t\t\t\telse if (tree[current].low < low && high < tree[current].high)\n\t\t\t\t{\n\t\t\t\t\t/* case 3, reduces to case 5 */\n                                        int new_high = tree[current].high;\n                                        tree[current].high = low-1;\n                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);\n                                }\n                                /* Now look for where to move to next (left for case 0, right for case 5) */\n                                if (tree[current].low > high) {\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (move != EMPTY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\tif (tree[current].low > high)\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t} while (move != EMPTY);\n\t\t}\n\t\t/* current is now the node to which we would be adding the new node */\n\t\t/* lt is the last node we traversed which is lt the new node. */\n\t\t/* gt is the last node we traversed which is gt the new node. */\n\n\t\tif (!many)\n\t\t{\n\t\t\t/* Check for the 'merge' cases. */\n\t\t\tif (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[lt].high = high;\n\t\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t\t{\n\t\t\t\t\ttree[lt].high = tree[gt].high;\n\t\t\t\t\tdelete_node(cmap, gt);\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[gt].low = low;\n\t\t\t\ttree[gt].out = out;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tcurrent = EMPTY;\n\n\tif (cmap->tlen == cmap->tcap)\n\t{\n\t\tint new_cap = cmap->tcap ? cmap->tcap * 2 : 256;\n\t\ttree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);\n\t\tcmap->tcap = new_cap;\n\t}\n\ttree[cmap->tlen].low = low;\n\ttree[cmap->tlen].high = high;\n\ttree[cmap->tlen].out = out;\n\ttree[cmap->tlen].parent = current;\n\ttree[cmap->tlen].left = EMPTY;\n\ttree[cmap->tlen].right = EMPTY;\n\ttree[cmap->tlen].many = many;\n\tcmap->tlen++;\n\tif (current == EMPTY)\n\t\tcmap->ttop = 0;\n\telse if (tree[current].low > high)\n\t\ttree[current].left = cmap->tlen-1;\n\telse\n\t{\n\t\tassert(tree[current].high < low);\n\t\ttree[current].right = cmap->tlen-1;\n\t}\n\tmove_to_root(tree, cmap->tlen-1);\n\tcmap->ttop = cmap->tlen-1;\nexit:\n\t{}\n#ifdef CHECK_SPLAY\n\tcheck_splay(cmap->tree, cmap->ttop, 0);\n#endif\n#ifdef DUMP_SPLAY\n\tdump_splay(cmap->tree, cmap->ttop, 0, \"\");\n#endif\n}\n", "func_hash": 73361849657881456808355395187124534685, "file_name": null, "file_hash": null, "cwe": ["CWE-416"], "cve": "CVE-2018-1000039", "cve_desc": "In MuPDF 1.12.0 and earlier, multiple heap use after free bugs in the PDF parser could allow an attacker to execute arbitrary code, read memory, or cause a denial of service via a crafted file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-1000039", "extracted_cve": null}, "consensus_nodes": [{"type": "F_", "name": "Tree node removal", "code_reference": "delete_node(cmap, current)", "line_start": 32, "line_end": 32, "rationale": "Security-sensitive tree modification operation without index validation.", "average_confidence": 0.9, "individual_confidences": [0.85, 0.95], "confidence_std": 0.071, "source_models": ["DeepSeek", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "F_:delete_node(cmap,current):30-30"}], "consensus_statistics": {"total_nodes_before_filtering": 1, "total_nodes_after_filtering": 1, "confidence_threshold": 0.85, "average_confidence": 0.9, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 7, "original_item": {"idx": 7, "project": "ghostscript", "commit_id": "4dcc6affe04368461310a21238f7e1871a752a05", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=4dcc6affe04368461310a21238f7e1871a752a05;hp=8ec561d1bccc46e9db40a9f61310cd8b3763914e", "commit_message": "None", "target": 1, "func": "begin_softmask(fz_context *ctx, pdf_run_processor *pr, softmask_save *save)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tpdf_xobject *softmask = gstate->softmask;\n\tfz_rect mask_bbox;\n\tfz_matrix tos_save[2], save_ctm;\n\tfz_matrix mask_matrix;\n\tfz_colorspace *mask_colorspace;\n\n\tsave->softmask = softmask;\n\tif (softmask == NULL)\n\t\treturn gstate;\n\tsave->page_resources = gstate->softmask_resources;\n\tsave->ctm = gstate->softmask_ctm;\n\tsave_ctm = gstate->ctm;\n\n\tpdf_xobject_bbox(ctx, softmask, &mask_bbox);\n\tpdf_xobject_matrix(ctx, softmask, &mask_matrix);\n\n\tpdf_tos_save(ctx, &pr->tos, tos_save);\n\n\tif (gstate->luminosity)\n\t\tmask_bbox = fz_infinite_rect;\n\telse\n\t{\n\t\tfz_transform_rect(&mask_bbox, &mask_matrix);\n\t\tfz_transform_rect(&mask_bbox, &gstate->softmask_ctm);\n\t}\n\tgstate->softmask = NULL;\n\tgstate->softmask_resources = NULL;\n\tgstate->ctm = gstate->softmask_ctm;\n\n        mask_colorspace = pdf_xobject_colorspace(ctx, softmask);\n \n        if (gstate->luminosity && !mask_colorspace)\n               mask_colorspace = fz_device_gray(ctx);\n \n        fz_try(ctx)\n        {\n\t\tfz_begin_mask(ctx, pr->dev, &mask_bbox, gstate->luminosity, mask_colorspace, gstate->softmask_bc, &gstate->fill.color_params);\n\t\tpdf_run_xobject(ctx, pr, softmask, save->page_resources, &fz_identity, 1);\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_colorspace(ctx, mask_colorspace);\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\t/* FIXME: Ignore error - nasty, but if we throw from\n\t\t * here the clip stack would be messed up. */\n\t\t/* TODO: pass cookie here to increase the cookie error count */\n\t}\n\n\tfz_end_mask(ctx, pr->dev);\n\n\tpdf_tos_restore(ctx, &pr->tos, tos_save);\n\n\tgstate = pr->gstate + pr->gtop;\n\tgstate->ctm = save_ctm;\n\n\treturn gstate;\n}\n", "func_hash": 213010027523017884356658697073580305774, "file_name": "pdf-op-run.c", "file_hash": 11900219421886234693290601818616390909, "cwe": ["CWE-416"], "cve": "CVE-2018-1000039", "cve_desc": "In MuPDF 1.12.0 and earlier, multiple heap use after free bugs in the PDF parser could allow an attacker to execute arbitrary code, read memory, or cause a denial of service via a crafted file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-1000039", "extracted_cve": null}, "consensus_nodes": [{"type": "F_", "name": "fz_transform_rect (First Call)", "code_reference": "fz_transform_rect", "line_start": 25, "line_end": 25, "rationale": "This function transforms the bounding box using the matrix obtained from the PDF file. If the matrix values are not properly validated, this transformation can result in arbitrarily large or invalid bounding box coordinates, which can then cause memory allocation failures or other unexpected behavior in subsequent rendering operations. This transformation acts as the *propagation* point for potentially malicious data from the XObject.", "average_confidence": 0.9, "individual_confidences": [0.9, 0.9], "confidence_std": 0.0, "source_models": ["Gemini-2.0-Flash", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "F_:fz_transform_rect:20-20"}], "consensus_statistics": {"total_nodes_before_filtering": 2, "total_nodes_after_filtering": 1, "confidence_threshold": 0.85, "average_confidence": 0.9, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 8, "original_item": {"idx": 8, "project": "ghostscript", "commit_id": "71ceebcf56e682504da22c4035b39a2d451e8ffd", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=71ceebcf56e682504da22c4035b39a2d451e8ffd;hp=7f82c01523505052615492f8e220f4348ba46995", "commit_message": "None", "target": 1, "func": "add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)\n{\n\tint current;\n\tcmap_splay *tree;\n\n\tif (low > high)\n\t{\n\t\tfz_warn(ctx, \"range limits out of range in cmap %s\", cmap->cmap_name);\n\t\treturn;\n\t}\n\n\ttree = cmap->tree;\n\n\tif (cmap->tlen)\n\t{\n\t\tunsigned int move = cmap->ttop;\n\t\tunsigned int gt = EMPTY;\n\t\tunsigned int lt = EMPTY;\n\t\tif (check_for_overlap)\n\t\t{\n\t\t\t/* Check for collision with the current node */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\t/* Cases we might meet:\n\t\t\t\t * tree[i]:        <----->\n\t\t\t\t * case 0:     <->\n\t\t\t\t * case 1:     <------->\n\t\t\t\t * case 2:     <------------->\n\t\t\t\t * case 3:           <->\n\t\t\t\t * case 4:           <------->\n\t\t\t\t * case 5:                 <->\n\t\t\t\t */\n\t\t\t\tif (low <= tree[current].low && tree[current].low <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 1, reduces to case 0 */\n\t\t\t\t\t/* or case 2, deleting the node */\n\t\t\t\t\ttree[current].out += high + 1 - tree[current].low;\n\t\t\t\t\ttree[current].low = high + 1;\n\t\t\t\t\tif (tree[current].low > tree[current].high)\n\t\t\t\t\t{\n\t\t\t\t\t\tmove = delete_node(cmap, current);\n\t\t\t\t\t\tcurrent = EMPTY;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (low <= tree[current].high && tree[current].high <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 4, reduces to case 5 */\n\t\t\t\t\ttree[current].high = low - 1;\n\t\t\t\t\tassert(tree[current].low <= tree[current].high);\n\t\t\t\t}\n\t\t\t\telse if (tree[current].low < low && high < tree[current].high)\n\t\t\t\t{\n                                        /* case 3, reduces to case 5 */\n                                        int new_high = tree[current].high;\n                                        tree[current].high = low-1;\n                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);\n                                }\n                                /* Now look for where to move to next (left for case 0, right for case 5) */\n                                if (tree[current].low > high) {\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (move != EMPTY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\tif (tree[current].low > high)\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t} while (move != EMPTY);\n\t\t}\n\t\t/* current is now the node to which we would be adding the new node */\n\t\t/* lt is the last node we traversed which is lt the new node. */\n\t\t/* gt is the last node we traversed which is gt the new node. */\n\n\t\tif (!many)\n\t\t{\n\t\t\t/* Check for the 'merge' cases. */\n\t\t\tif (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[lt].high = high;\n\t\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t\t{\n\t\t\t\t\ttree[lt].high = tree[gt].high;\n\t\t\t\t\tdelete_node(cmap, gt);\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[gt].low = low;\n\t\t\t\ttree[gt].out = out;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tcurrent = EMPTY;\n\n\tif (cmap->tlen == cmap->tcap)\n\t{\n\t\tint new_cap = cmap->tcap ? cmap->tcap * 2 : 256;\n\t\ttree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);\n\t\tcmap->tcap = new_cap;\n\t}\n\ttree[cmap->tlen].low = low;\n\ttree[cmap->tlen].high = high;\n\ttree[cmap->tlen].out = out;\n\ttree[cmap->tlen].parent = current;\n\ttree[cmap->tlen].left = EMPTY;\n\ttree[cmap->tlen].right = EMPTY;\n\ttree[cmap->tlen].many = many;\n\tcmap->tlen++;\n\tif (current == EMPTY)\n\t\tcmap->ttop = 0;\n\telse if (tree[current].low > high)\n\t\ttree[current].left = cmap->tlen-1;\n\telse\n\t{\n\t\tassert(tree[current].high < low);\n\t\ttree[current].right = cmap->tlen-1;\n\t}\n\tmove_to_root(tree, cmap->tlen-1);\n\tcmap->ttop = cmap->tlen-1;\nexit:\n\t{}\n#ifdef CHECK_SPLAY\n\tcheck_splay(cmap->tree, cmap->ttop, 0);\n#endif\n#ifdef DUMP_SPLAY\n\tdump_splay(cmap->tree, cmap->ttop, 0, \"\");\n#endif\n}\n", "func_hash": 72963719227623516762803191293835350908, "file_name": "pdf-cmap.c", "file_hash": 295089762772960854132847614036970801947, "cwe": ["CWE-416"], "cve": "CVE-2018-1000039", "cve_desc": "In MuPDF 1.12.0 and earlier, multiple heap use after free bugs in the PDF parser could allow an attacker to execute arbitrary code, read memory, or cause a denial of service via a crafted file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-1000039", "extracted_cve": null}, "consensus_nodes": [{"type": "C_", "name": "C_RANGE_CHECK", "code_reference": "if (low > high)", "line_start": 7, "line_end": 10, "rationale": "Input validation is crucial for preventing out-of-bounds access and ensuring correct operation. Failing this check leads to undefined behavior.", "average_confidence": 0.925, "individual_confidences": [0.9, 0.95], "confidence_std": 0.035, "source_models": ["Gemini-2.0-Flash", "Qwen2.5-Coder-32B"], "model_count": 2, "node_key": "C_:if(lowhigh):0-10"}, {"type": "M_", "name": "Memory allocation failure handling", "code_reference": "", "line_start": 0, "line_end": 0, "rationale": "Missing check for fz_resize_array return value could lead to NULL dereference.", "average_confidence": 0.91, "individual_confidences": [0.98, 0.9, 0.85], "confidence_std": 0.066, "source_models": ["DeepSeek", "DeepSeek", "DeepSeek"], "model_count": 3, "node_key": "M_::0-0"}], "consensus_statistics": {"total_nodes_before_filtering": 2, "total_nodes_after_filtering": 2, "confidence_threshold": 0.85, "average_confidence": 0.9175, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
{"idx": 9, "original_item": {"idx": 9, "project": "ghostscript", "commit_id": "b2e7d38e845c7d4922d05e6e41f3a2dc1bc1b14a", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=b2e7d38e845c7d4922d05e6e41f3a2dc1bc1b14a;hp=f51836b9732c38d945b87fda0770009a77ba680c", "commit_message": "None", "target": 1, "func": " pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)\n {\n        pdf_gstate *gstate = pr->gstate + pr->gtop;\n        fz_matrix image_ctm;\n        fz_rect bbox;\n       softmask_save softmask = { NULL };\n \n        if (pr->super.hidden)\n                return;\n\t\t\tbreak;\n\t\tcase PDF_MAT_SHADE:\n\t\t\tif (gstate->fill.shade)\n\t\t\t{\n\t\t\t\tfz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n        bbox = fz_unit_rect;\n        fz_transform_rect(&bbox, &image_ctm);\n \n       if (image->mask)\n        {\n                /* apply blend group even though we skip the soft mask */\n               if (gstate->blendmode)\n                       fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);\n               fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);\n       }\n       else\n               gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n \n       if (!image->colorspace)\n       {\n               switch (gstate->fill.kind)\n                {\n               case PDF_MAT_NONE:\n                       break;\n               case PDF_MAT_COLOR:\n                       fz_fill_image_mask(ctx, pr->dev, image, &image_ctm,\n                               gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\n                       break;\n               case PDF_MAT_PATTERN:\n                       if (gstate->fill.pattern)\n                       {\n                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n                               pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\n                               fz_pop_clip(ctx, pr->dev);\n                       }\n                       break;\n               case PDF_MAT_SHADE:\n                       if (gstate->fill.shade)\n                       {\n                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n                               fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\n                               fz_pop_clip(ctx, pr->dev);\n                       }\n                       break;\n                }\n        }\n       else\n        {\n               fz_fill_image(ctx, pr->dev, image, &image_ctm, gstate->fill.alpha, &gstate->fill.color_params);\n        }\n       if (image->mask)\n        {\n               fz_pop_clip(ctx, pr->dev);\n               if (gstate->blendmode)\n                       fz_end_group(ctx, pr->dev);\n        }\n       else\n               pdf_end_group(ctx, pr, &softmask);\n }\n \n static void\n\n\t\tif (pr->clip)\n\t\t{\n\t\t\tgstate->clip_depth++;\n\t\t\tfz_clip_path(ctx, pr->dev, path, pr->clip_even_odd, &gstate->ctm, &bbox);\n\t\t\tpr->clip = 0;\n\t\t}\n\n\t\tif (pr->super.hidden)\n\t\t\tdostroke = dofill = 0;\n\n\t\tif (dofill || dostroke)\n\t\t\tgstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n\n\t\tif (dofill && dostroke)\n\t\t{\n\t\t\t/* We may need to push a knockout group */\n\t\t\tif (gstate->stroke.alpha == 0)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't do anything */\n\t\t\t}\n\t\t\telse if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't show up */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tknockout_group = 1;\n\t\t\t\tfz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 1, FZ_BLEND_NORMAL, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (dofill)\n\t\t{\n\t\t\tswitch (gstate->fill.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_fill_path(ctx, pr->dev, path, even_odd, &gstate->ctm,\n\t\t\t\t\tgstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->fill.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\n\t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->fill.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\n\t\t\t\t\t/* The cluster and page 2 of patterns.pdf shows that fz_fill_shade should NOT be called with gstate->ctm. */\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dostroke)\n\t\t{\n\t\t\tswitch (gstate->stroke.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm,\n\t\t\t\t\tgstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, &gstate->stroke.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->stroke.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\n\t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->stroke.pattern, &pr->gstate[gstate->stroke.gstate_num], &bbox, PDF_STROKE);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->stroke.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->stroke.shade, &pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, &gstate->stroke.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (knockout_group)\n\t\t\tfz_end_group(ctx, pr->dev);\n\n\t\tif (dofill || dostroke)\n\t\t\tpdf_end_group(ctx, pr, &softmask);\n\t}\n", "func_hash": 327424409628836476675717770567987598130, "file_name": null, "file_hash": null, "cwe": ["CWE-20"], "cve": "CVE-2018-1000037", "cve_desc": "In MuPDF 1.12.0 and earlier, multiple reachable assertions in the PDF parser allow an attacker to cause a denial of service (assert crash) via a crafted file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-1000037", "extracted_cve": null}, "consensus_nodes": [{"type": "P_", "name": "ctx", "code_reference": "ctx", "line_start": 1, "line_end": 1, "rationale": "The `fz_context` pointer is essential for all operations. A NULL context will cause a crash when dereferenced, leading to DoS. High confidence due to its fundamental role.", "average_confidence": 0.95, "individual_confidences": [0.95, 0.95], "confidence_std": 0.0, "source_models": ["Gemini-2.0-Flash", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "P_:ctx:0-0"}, {"type": "P_", "name": "pr", "code_reference": "pr", "line_start": 1, "line_end": 1, "rationale": "The `pdf_run_processor` pointer controls the execution environment. A NULL `pr` will cause a crash, leading to DoS. It directly influences the execution flow and data processing.", "average_confidence": 0.95, "individual_confidences": [0.95, 0.95], "confidence_std": 0.0, "source_models": ["Gemini-2.0-Flash", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "P_:pr:0-0"}, {"type": "C_", "name": "Null colorspace branch", "code_reference": "if (!image->colorspace)", "line_start": 25, "line_end": 25, "rationale": "Critical security boundary for color processing with potential for type confusion if colorspace is malformed.", "average_confidence": 0.865, "individual_confidences": [0.88, 0.85], "confidence_std": 0.021, "source_models": ["DeepSeek", "Gemini-2.0-Flash"], "model_count": 2, "node_key": "C_:if(imagecolorspace):20-20"}], "consensus_statistics": {"total_nodes_before_filtering": 5, "total_nodes_after_filtering": 3, "confidence_threshold": 0.85, "average_confidence": 0.9216666666666666, "models_with_data": ["deepseek", "gemini", "qwen"], "model_count": 3}}
