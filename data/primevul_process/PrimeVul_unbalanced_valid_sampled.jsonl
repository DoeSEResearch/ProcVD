{"idx": 232552, "project": "linux", "commit_id": "294f2fc6da27620a506e6c050241655459ccd6bd", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/294f2fc6da27620a506e6c050241655459ccd6bd", "commit_message": "bpf: Verifer, adjust_scalar_min_max_vals to always call update_reg_bounds()\n\nCurrently, for all op verification we call __red_deduce_bounds() and\n__red_bound_offset() but we only call __update_reg_bounds() in bitwise\nops. However, we could benefit from calling __update_reg_bounds() in\nBPF_ADD, BPF_SUB, and BPF_MUL cases as well.\n\nFor example, a register with state 'R1_w=invP0' when we subtract from\nit,\n\n w1 -= 2\n\nBefore coerce we will now have an smin_value=S64_MIN, smax_value=U64_MAX\nand unsigned bounds umin_value=0, umax_value=U64_MAX. These will then\nbe clamped to S32_MIN, U32_MAX values by coerce in the case of alu32 op\nas done in above example. However tnum will be a constant because the\nALU op is done on a constant.\n\nWithout update_reg_bounds() we have a scenario where tnum is a const\nbut our unsigned bounds do not reflect this. By calling update_reg_bounds\nafter coerce to 32bit we further refine the umin_value to U64_MAX in the\nalu64 case or U32_MAX in the alu32 case above.\n\nSigned-off-by: John Fastabend <john.fastabend@gmail.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nLink: https://lore.kernel.org/bpf/158507151689.15666.566796274289413203.stgit@john-Precision-5820-Tower", "target": 0, "func": "static int release_reference(struct bpf_verifier_env *env,\n\t\t\t     int ref_obj_id)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tint err;\n\tint i;\n\n\terr = release_reference_state(cur_func(env), ref_obj_id);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <= vstate->curframe; i++)\n\t\trelease_reg_references(env, vstate->frame[i], ref_obj_id);\n\n\treturn 0;\n}", "func_hash": 117901259655658889182380132003364790246, "file_name": "verifier.c", "file_hash": 234225621372955776939749520215587474648, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 208465, "project": "linux", "commit_id": "bb1fceca22492109be12640d49f5ea5a544c6bb4", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/bb1fceca22492109be12640d49f5ea5a544c6bb4", "commit_message": "tcp: fix use after free in tcp_xmit_retransmit_queue()\n\nWhen tcp_sendmsg() allocates a fresh and empty skb, it puts it at the\ntail of the write queue using tcp_add_write_queue_tail()\n\nThen it attempts to copy user data into this fresh skb.\n\nIf the copy fails, we undo the work and remove the fresh skb.\n\nUnfortunately, this undo lacks the change done to tp->highest_sack and\nwe can leave a dangling pointer (to a freed skb)\n\nLater, tcp_xmit_retransmit_queue() can dereference this pointer and\naccess freed memory. For regular kernels where memory is not unmapped,\nthis might cause SACK bugs because tcp_highest_sack_seq() is buggy,\nreturning garbage instead of tp->snd_nxt, but with various debug\nfeatures like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.\n\nThis bug was found by Marco Grassi thanks to syzkaller.\n\nFixes: 6859d49475d4 (\"[TCP]: Abstract tp->highest_sack accessing & point to next skb\")\nReported-by: Marco Grassi <marco.gra@gmail.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Ilpo JÃ¤rvinen <ilpo.jarvinen@helsinki.fi>\nCc: Yuchung Cheng <ycheng@google.com>\nCc: Neal Cardwell <ncardwell@google.com>\nAcked-by: Neal Cardwell <ncardwell@google.com>\nReviewed-by: Cong Wang <xiyou.wangcong@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n}", "func_hash": 286319380038378703927252822840010754897, "file_name": "tcp.h", "file_hash": 236491050258006963296337743903046036385, "cwe": ["CWE-269"], "cve": "CVE-2016-6828", "cve_desc": "The tcp_check_send_head function in include/net/tcp.h in the Linux kernel before 4.7.5 does not properly maintain certain SACK state after a failed data copy, which allows local users to cause a denial of service (tcp_xmit_retransmit_queue use-after-free and system crash) via a crafted SACK option.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-6828"}
{"idx": 232437, "project": "linux", "commit_id": "294f2fc6da27620a506e6c050241655459ccd6bd", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/294f2fc6da27620a506e6c050241655459ccd6bd", "commit_message": "bpf: Verifer, adjust_scalar_min_max_vals to always call update_reg_bounds()\n\nCurrently, for all op verification we call __red_deduce_bounds() and\n__red_bound_offset() but we only call __update_reg_bounds() in bitwise\nops. However, we could benefit from calling __update_reg_bounds() in\nBPF_ADD, BPF_SUB, and BPF_MUL cases as well.\n\nFor example, a register with state 'R1_w=invP0' when we subtract from\nit,\n\n w1 -= 2\n\nBefore coerce we will now have an smin_value=S64_MIN, smax_value=U64_MAX\nand unsigned bounds umin_value=0, umax_value=U64_MAX. These will then\nbe clamped to S32_MIN, U32_MAX values by coerce in the case of alu32 op\nas done in above example. However tnum will be a constant because the\nALU op is done on a constant.\n\nWithout update_reg_bounds() we have a scenario where tnum is a const\nbut our unsigned bounds do not reflect this. By calling update_reg_bounds\nafter coerce to 32bit we further refine the umin_value to U64_MAX in the\nalu64 case or U32_MAX in the alu32 case above.\n\nSigned-off-by: John Fastabend <john.fastabend@gmail.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nLink: https://lore.kernel.org/bpf/158507151689.15666.566796274289413203.stgit@john-Precision-5820-Tower", "target": 0, "func": "static const char *ltrim(const char *s)\n{\n\twhile (isspace(*s))\n\t\ts++;\n\n\treturn s;\n}", "func_hash": 322366500046924200376986167336335237856, "file_name": "verifier.c", "file_hash": 234225621372955776939749520215587474648, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 481110, "project": "linux", "commit_id": "6d1c0f3d28f98ea2736128ed3e46821496dc3a8c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/6d1c0f3d28f98ea2736128ed3e46821496dc3a8c", "commit_message": "sunrpc: Avoid a KASAN slab-out-of-bounds bug in xdr_set_page_base()\n\nThis seems to happen fairly easily during READ_PLUS testing on NFS v4.2.\nI found that we could end up accessing xdr->buf->pages[pgnr] with a pgnr\ngreater than the number of pages in the array. So let's just return\nearly if we're setting base to a point at the end of the page data and\nlet xdr_set_tail_base() handle setting up the buffer pointers instead.\n\nSigned-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>\nFixes: 8d86e373b0ef (\"SUNRPC: Clean up helpers xdr_set_iov() and xdr_set_page_base()\")\nSigned-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>", "target": 0, "func": "static __be32 * __xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes)\n{\n\tunsigned int nwords = XDR_QUADLEN(nbytes);\n\t__be32 *p = xdr->p;\n\t__be32 *q = p + nwords;\n\n\tif (unlikely(nwords > xdr->nwords || q > xdr->end || q < p))\n\t\treturn NULL;\n\txdr->p = q;\n\txdr->nwords -= nwords;\n\treturn p;\n}", "func_hash": 83494257885580455224873214860202433262, "file_name": "xdr.c", "file_hash": 8475365788443041307493360430543450420, "cwe": ["CWE-787"], "cve": "CVE-2021-38201", "cve_desc": "net/sunrpc/xdr.c in the Linux kernel before 5.13.4 allows remote attackers to cause a denial of service (xdr_set_page_base slab-out-of-bounds access) by performing many NFS 4.2 READ_PLUS operations.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-38201"}
{"idx": 379386, "project": "bash", "commit_id": "863d31ae775d56b785dc5b0105b6d251515d81d5", "project_url": "https://github.com/bminor/bash", "commit_url": "http://git.savannah.gnu.org/cgit/bash.git/commit/?h=devel&id=863d31ae775d56b785dc5b0105b6d251515d81d5", "commit_message": "commit bash-20120224 snapshot", "target": 0, "func": "get_histcmd (var)\n     SHELL_VAR *var;\n{\n  char *p;\n\n  p = itos (history_number ());\n  FREE (value_cell (var));\n  var_setvalue (var, p);\n  return (var);\n}", "func_hash": 334358202004018120757131906147961978417, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-6711", "cve_desc": "A heap-based buffer overflow exists in GNU Bash before 4.3 when wide characters, not supported by the current locale set in the LC_CTYPE environment variable, are printed through the echo built-in function. A local attacker, who can provide data to print through the \"echo -e\" built-in function, may use this flaw to crash a script or execute code with the privileges of the bash process. This occurs because ansicstr() in lib/sh/strtrans.c mishandles u32cconv().", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-6711"}
{"idx": 207567, "project": "FreeRDP", "commit_id": "6ade7b4cbfd71c54b3d724e8f2d6ac76a58e879a", "project_url": "https://github.com/FreeRDP/FreeRDP", "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/6ade7b4cbfd71c54b3d724e8f2d6ac76a58e879a", "commit_message": "Fixed OOB Read in license_read_new_or_upgrade_license_packet\n\nCVE-2020-11099 thanks to @antonio-morales for finding this.", "target": 1, "func": "BOOL license_read_new_or_upgrade_license_packet(rdpLicense* license, wStream* s)\n{\n\tUINT32 os_major;\n\tUINT32 os_minor;\n\tUINT32 cbScope, cbCompanyName, cbProductId, cbLicenseInfo;\n\twStream* licenseStream = NULL;\n\tBOOL ret = FALSE;\n\tBYTE computedMac[16];\n\tLICENSE_BLOB* calBlob;\n\n\tDEBUG_LICENSE(\"Receiving Server New/Upgrade License Packet\");\n\n\tcalBlob = license_new_binary_blob(BB_DATA_BLOB);\n\tif (!calBlob)\n\t\treturn FALSE;\n\n\t/* EncryptedLicenseInfo */\n\tif (!license_read_encrypted_blob(license, s, calBlob))\n\t\tgoto out_free_blob;\n\n\t/* compute MAC and check it */\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\tgoto out_free_blob;\n\n\tif (!security_mac_data(license->MacSaltKey, calBlob->data, calBlob->length, computedMac))\n\t\tgoto out_free_blob;\n\n\tif (memcmp(computedMac, Stream_Pointer(s), sizeof(computedMac)) != 0)\n\t{\n\t\tWLog_ERR(TAG, \"new or upgrade license MAC mismatch\");\n\t\tgoto out_free_blob;\n\t}\n\n\tif (!Stream_SafeSeek(s, 16))\n\t\tgoto out_free_blob;\n\n\tlicenseStream = Stream_New(calBlob->data, calBlob->length);\n\tif (!licenseStream)\n\t\tgoto out_free_blob;\n\n\tStream_Read_UINT16(licenseStream, os_minor);\n\tStream_Read_UINT16(licenseStream, os_major);\n\n\t/* Scope */\n\tStream_Read_UINT32(licenseStream, cbScope);\n\tif (Stream_GetRemainingLength(licenseStream) < cbScope)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Scope:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbScope);\n#endif\n\tStream_Seek(licenseStream, cbScope);\n\n\t/* CompanyName */\n\tStream_Read_UINT32(licenseStream, cbCompanyName);\n\tif (Stream_GetRemainingLength(licenseStream) < cbCompanyName)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Company name:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbCompanyName);\n#endif\n\tStream_Seek(licenseStream, cbCompanyName);\n\n\t/* productId */\n\tStream_Read_UINT32(licenseStream, cbProductId);\n\tif (Stream_GetRemainingLength(licenseStream) < cbProductId)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Product id:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbProductId);\n#endif\n\tStream_Seek(licenseStream, cbProductId);\n\n\t/* licenseInfo */\n\tStream_Read_UINT32(licenseStream, cbLicenseInfo);\n\tif (Stream_GetRemainingLength(licenseStream) < cbLicenseInfo)\n\t\tgoto out_free_stream;\n\n\tlicense->state = LICENSE_STATE_COMPLETED;\n\n\tret = TRUE;\n\tif (!license->rdp->settings->OldLicenseBehaviour)\n\t\tret = saveCal(license->rdp->settings, Stream_Pointer(licenseStream), cbLicenseInfo,\n\t\t              license->rdp->settings->ClientHostname);\n\nout_free_stream:\n\tStream_Free(licenseStream, FALSE);\nout_free_blob:\n\tlicense_free_binary_blob(calBlob);\n\treturn ret;\n}", "func_hash": 134542836492059404727348638541733942617, "file_name": "license.c", "file_hash": 41805382834640061372439312241604164558, "cwe": ["CWE-125"], "cve": "CVE-2020-11099", "cve_desc": "In FreeRDP before version 2.1.2, there is an out of bounds read in license_read_new_or_upgrade_license_packet. A manipulated license packet can lead to out of bound reads to an internal buffer. This is fixed in version 2.1.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-11099"}
{"idx": 238733, "project": "jerryscript", "commit_id": "c2b662170245a16f46ce02eae68815c325d99821", "project_url": "https://github.com/zherczeg/jerryscript", "commit_url": "https://github.com/jerryscript-project/jerryscript/commit/c2b662170245a16f46ce02eae68815c325d99821", "commit_message": "Fix adding entries to the internal buffer of a Map object (#3805)\n\nWhen appending the key/value pair separately, garbage collection could be\ntriggered before the value is added, which could cause problems during\nmarking. This patch changes insertion to add both values at the same\ntime, which prevents partial entries from being present in the internal\nbuffer.\n\nFixes #3804.\n\nJerryScript-DCO-1.0-Signed-off-by: DÃ¡niel BÃ¡tyai dbatyai@inf.u-szeged.hu", "target": 0, "func": "ecma_op_container_free_weakset_entries (ecma_object_t *object_p, /**< object pointer */\n                                        ecma_collection_t *container_p) /** internal buffer pointer */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (container_p != NULL);\n\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n\n  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_VALUE_SIZE)\n  {\n    ecma_value_t *entry_p = start_p + i;\n\n    if (ecma_is_value_empty (*entry_p))\n    {\n      continue;\n    }\n\n    ecma_op_container_unref_weak (ecma_get_object_from_value (*entry_p), ecma_make_object_value (object_p));\n    ecma_op_container_remove_weak_entry (object_p, *entry_p);\n\n    *entry_p = ECMA_VALUE_EMPTY;\n  }\n} /* ecma_op_container_free_weakset_entries */", "func_hash": 137477728568010127906269297963767412990, "file_name": "None", "file_hash": null, "cwe": ["CWE-703"], "cve": "CVE-2020-14163", "cve_desc": "An issue was discovered in ecma/operations/ecma-container-object.c in JerryScript 2.2.0. Operations with key/value pairs did not consider the case where garbage collection is triggered after the key operation but before the value operation, as demonstrated by improper read access to memory in ecma_gc_set_object_visited in ecma/base/ecma-gc.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-14163"}
{"idx": 402315, "project": "squid", "commit_id": "fd68382860633aca92065e6c343cfd1b12b126e7", "project_url": "https://github.com/squid-cache/squid", "commit_url": "https://github.com/squid-cache/squid/commit/fd68382860633aca92065e6c343cfd1b12b126e7", "commit_message": "Improve Transfer-Encoding handling (#702)\n\nReject messages containing Transfer-Encoding header with coding other\nthan chunked or identity. Squid does not support other codings.\n\nFor simplicity and security sake, also reject messages where\nTransfer-Encoding contains unnecessary complex values that are\ntechnically equivalent to \"chunked\" or \"identity\" (e.g., \",,chunked\" or\n\"identity, chunked\").\n\nRFC 7230 formally deprecated and removed identity coding, but it is\nstill used by some agents.", "target": 0, "func": "HttpStateData::keepaliveAccounting(HttpReply *reply)\n{\n    if (flags.keepalive)\n        if (_peer)\n            ++ _peer->stats.n_keepalives_sent;\n\n    if (reply->keep_alive) {\n        if (_peer)\n            ++ _peer->stats.n_keepalives_recv;\n\n        if (Config.onoff.detect_broken_server_pconns\n                && reply->bodySize(request->method) == -1 && !flags.chunked) {\n            debugs(11, DBG_IMPORTANT, \"keepaliveAccounting: Impossible keep-alive header from '\" << entry->url() << \"'\" );\n            // debugs(11, 2, \"GOT HTTP REPLY HDR:\\n---------\\n\" << readBuf->content() << \"\\n----------\" );\n            flags.keepalive_broken = true;\n        }\n    }\n}", "func_hash": 338894989040030717104878336932768383422, "file_name": "http.cc", "file_hash": 293506210691236089515155869723742141045, "cwe": ["CWE-444"], "cve": "CVE-2020-15811", "cve_desc": "An issue was discovered in Squid before 4.13 and 5.x before 5.0.4. Due to incorrect data validation, HTTP Request Splitting attacks may succeed against HTTP and HTTPS traffic. This leads to cache poisoning. This allows any client, including browser scripts, to bypass local security and poison the browser cache and any downstream caches with content from an arbitrary source. Squid uses a string search instead of parsing the Transfer-Encoding header to find chunked encoding. This allows an attacker to hide a second request inside Transfer-Encoding: it is interpreted by Squid as chunked and split out into a second request delivered upstream. Squid will then deliver two distinct responses to the client, corrupting any downstream caches.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-15811"}
{"idx": 509278, "project": "server", "commit_id": "2e7891080667c59ac80f788eef4d59d447595772", "project_url": "https://github.com/MariaDB/server", "commit_url": "https://github.com/MariaDB/server/commit/2e7891080667c59ac80f788eef4d59d447595772", "commit_message": "MDEV-25635 Assertion failure when pushing from HAVING into WHERE of view\n\nThis bug could manifest itself after pushing a where condition over a\nmergeable derived table / view / CTE DT into a grouping view / derived\ntable / CTE V whose item list contained set functions with constant\narguments such as MIN(2), SUM(1) etc. In such cases the field references\nused in the condition pushed into the view V that correspond set functions\nare wrapped into Item_direct_view_ref wrappers. Due to a wrong implementation\nof the virtual method const_item() for the class Item_direct_view_ref the\nwrapped set functions with constant arguments could be erroneously taken\nfor constant items. This could lead to a wrong result set returned by the\nmain select query in 10.2. In 10.4 where a possibility of pushing condition\nfrom HAVING into WHERE had been added this could cause a crash.\n\nApproved by Sergey Petrunya <sergey.petrunya@mariadb.com>", "target": 0, "func": "  Item_temporal_literal(THD *thd, MYSQL_TIME *ltime, uint dec_arg):\n    Item_basic_constant(thd)\n  {\n    collation.set(&my_charset_numeric, DERIVATION_NUMERIC, MY_REPERTOIRE_ASCII);\n    decimals= dec_arg;\n    cached_time= *ltime;\n  }", "func_hash": 179888322558411903540115263952661277777, "file_name": "None", "file_hash": null, "cwe": ["CWE-617"], "cve": "CVE-2021-46666", "cve_desc": "MariaDB before 10.6.2 allows an application crash because of mishandling of a pushdown from a HAVING clause to a WHERE clause.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-46666"}
{"idx": 267211, "project": "gpac", "commit_id": "ebfa346eff05049718f7b80041093b4c5581c24e", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/ebfa346eff05049718f7b80041093b4c5581c24e", "commit_message": "fixed #1706", "target": 0, "func": "static GF_Err trak_add_sample(GF_ISOFile *movie, GF_TrackBox *trak, const GF_ISOSample *sample, u32 descIndex, u64 data_offset, u32 syncShadowSampleNum)\n{\n\tBool skip_data = GF_FALSE;\n\tGF_Err e;\n\n\t//faststart mode with interleaving time, cache data until we have a full chunk\n\tif ((movie->storageMode==GF_ISOM_STORE_FASTSTART) && movie->interleavingTime) {\n\t\tBool flush_chunk = GF_FALSE;\n\t\tu64 stime = sample->DTS;\n\t\tstime *= movie->moov->mvhd->timeScale;\n\t\tstime /= trak->Media->mediaHeader->timeScale;\n\n\t\tif (stime - trak->first_dts_chunk > movie->interleavingTime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (movie->next_flush_chunk_time < stime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->chunk_stsd_idx != descIndex)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->Media->information->sampleTable->MaxChunkSize && trak->Media->information->sampleTable->MaxChunkSize < trak->chunk_cache_size + sample->dataLength)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (flush_chunk) {\n\t\t\tmovie->next_flush_chunk_time = stime + movie->interleavingTime;\n\t\t\tif (trak->chunk_cache) {\n\t\t\t\te = gf_isom_flush_chunk(trak, GF_FALSE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\ttrak->nb_samples_in_cache = 0;\n\t\t\ttrak->chunk_cache_size = 0;\n\t\t\ttrak->first_dts_chunk = stime;\n\t\t}\n\t\tif (!trak->chunk_cache)\n\t\t\ttrak->chunk_cache = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(trak->chunk_cache, sample->data, sample->dataLength);\n\t\ttrak->nb_samples_in_cache += sample->nb_pack ? sample->nb_pack : 1;\n\t\ttrak->chunk_cache_size += sample->dataLength;\n\t\ttrak->chunk_stsd_idx = descIndex;\n\n\t\tskip_data = GF_TRUE;\n\t}\n\n\te = Media_AddSample(trak->Media, data_offset, sample, descIndex, syncShadowSampleNum);\n\tif (e) return e;\n\n\tif (!skip_data && sample->dataLength) {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, sample->data, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\n\treturn GF_OK;\n}", "func_hash": 185101099688691550937494957479649927556, "file_name": "isom_write.c", "file_hash": 282403932169763893947360360802804463352, "cwe": ["CWE-476"], "cve": "CVE-2021-31258", "cve_desc": "The gf_isom_set_extraction_slc function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-31258"}
