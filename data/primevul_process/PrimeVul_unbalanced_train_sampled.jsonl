{"idx": 306957, "project": "mbedtls", "commit_id": "c988f32adde62a169ba340fee0da15aecd40e76e", "project_url": "https://github.com/ARMmbed/mbedtls", "commit_url": "https://github.com/ARMmbed/mbedtls/commit/c988f32adde62a169ba340fee0da15aecd40e76e", "commit_message": "Added max length checking of hostname", "target": 0, "func": "void ssl_set_session_ticket_lifetime( ssl_context *ssl, int lifetime )\n{\n    ssl->ticket_lifetime = lifetime;\n}", "func_hash": 64835027883927276940855084422761291565, "file_name": "ssl_tls.c", "file_hash": 41989934499373270126191041875081777906, "cwe": ["CWE-119"], "cve": "CVE-2015-5291", "cve_desc": "Heap-based buffer overflow in PolarSSL 1.x before 1.2.17 and ARM mbed TLS (formerly PolarSSL) 1.3.x before 1.3.14 and 2.x before 2.1.2 allows remote SSL servers to cause a denial of service (client crash) and possibly execute arbitrary code via a long hostname to the server name indication (SNI) extension, which is not properly handled when creating a ClientHello message.  NOTE: this identifier has been SPLIT per ADT3 due to different affected version ranges. See CVE-2015-8036 for the session ticket issue that was introduced in 1.3.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-5291"}
{"idx": 327168, "project": "exiv2", "commit_id": "c72d16f4c402a8acc2dfe06fe3d58bf6cf99069e", "project_url": "https://github.com/Exiv2/exiv2", "commit_url": "https://github.com/Exiv2/exiv2/commit/c72d16f4c402a8acc2dfe06fe3d58bf6cf99069e", "commit_message": "Change BasicIO read/write methods to use size_t", "target": 0, "func": "        bool operator==(int compression) const { return compression_ == compression; }", "func_hash": 48090134819839096339798580937726053619, "file_name": "tiffimage.cpp", "file_hash": 67481382449795543937823408800787044304, "cwe": [], "cve": "CVE-2019-13504", "cve_desc": "There is an out-of-bounds read in Exiv2::MrwImage::readMetadata in mrwimage.cpp in Exiv2 through 0.27.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-13504"}
{"idx": 393761, "project": "samba", "commit_id": "31f1a36901b5b8959dc51401c09c114829b50392", "project_url": "https://github.com/samba-team/samba", "commit_url": "https://github.com/samba-team/samba/commit/31f1a36901b5b8959dc51401c09c114829b50392", "commit_message": "s3: Don't fail authentication when one or some group of require-membership-of is invalid.\n\nSigned-off-by: Bo Yang <boyang@samba.org>", "target": 0, "func": "static int winbind_chauthtok_request(struct pwb_context *ctx,\n\t\t\t\t     const char *user,\n\t\t\t\t     const char *oldpass,\n\t\t\t\t     const char *newpass,\n\t\t\t\t     time_t pwd_last_set)\n{\n\twbcErr wbc_status;\n\tstruct wbcChangePasswordParams params;\n\tstruct wbcAuthErrorInfo *error = NULL;\n\tstruct wbcUserPasswordPolicyInfo *policy = NULL;\n\tenum wbcPasswordChangeRejectReason reject_reason = -1;\n\tuint32_t flags = 0;\n\n\tint i;\n\tconst char *codes[] = {\n\t\t\"NT_STATUS_BACKUP_CONTROLLER\",\n\t\t\"NT_STATUS_DOMAIN_CONTROLLER_NOT_FOUND\",\n\t\t\"NT_STATUS_NO_LOGON_SERVERS\",\n\t\t\"NT_STATUS_ACCESS_DENIED\",\n\t\t\"NT_STATUS_PWD_TOO_SHORT\", /* TODO: tell the min pwd length ? */\n\t\t\"NT_STATUS_PWD_TOO_RECENT\", /* TODO: tell the minage ? */\n\t\t\"NT_STATUS_PWD_HISTORY_CONFLICT\" /* TODO: tell the history length ? */\n\t};\n\tint ret = PAM_AUTH_ERR;\n\n\tZERO_STRUCT(params);\n\n\tif (ctx->ctrl & WINBIND_KRB5_AUTH) {\n\t\tflags |= WBFLAG_PAM_KRB5 |\n\t\t\t WBFLAG_PAM_CONTACT_TRUSTDOM;\n\t}\n\n\tif (ctx->ctrl & WINBIND_CACHED_LOGIN) {\n\t\tflags |= WBFLAG_PAM_CACHED_LOGIN;\n\t}\n\n\tparams.account_name\t\t= user;\n\tparams.level\t\t\t= WBC_AUTH_USER_LEVEL_PLAIN;\n\tparams.old_password.plaintext\t= oldpass;\n\tparams.new_password.plaintext\t= newpass;\n\tparams.flags\t\t\t= flags;\n\n\twbc_status = wbcChangeUserPasswordEx(&params, &error, &reject_reason, &policy);\n\tret = wbc_auth_error_to_pam_error(ctx, error, wbc_status,\n\t\t\t\t\t  user, \"wbcChangeUserPasswordEx\");\n\n\tif (WBC_ERROR_IS_OK(wbc_status)) {\n\t\t_pam_log(ctx, LOG_NOTICE,\n\t\t\t \"user '%s' password changed\", user);\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tif (!error) {\n\t\twbcFreeMemory(policy);\n\t\treturn ret;\n\t}\n\n\tfor (i=0; i<ARRAY_SIZE(codes); i++) {\n\t\tint _ret = ret;\n\t\tif (_pam_check_remark_auth_err(ctx, error, codes[i], &_ret)) {\n\t\t\tret = _ret;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (!strcasecmp(error->nt_string,\n\t\t\t\"NT_STATUS_PASSWORD_RESTRICTION\")) {\n\n\t\tchar *pwd_restriction_string = NULL;\n\t\tSMB_TIME_T min_pwd_age = 0;\n\n\t\tif (policy) {\n\t\t\tmin_pwd_age\t= policy->min_passwordage;\n\t\t}\n\n\t\t/* FIXME: avoid to send multiple PAM messages after another */\n\t\tswitch (reject_reason) {\n\t\t\tcase -1:\n\t\t\t\tbreak;\n\t\t\tcase WBC_PWD_CHANGE_NO_ERROR:\n\t\t\t\tif ((min_pwd_age > 0) &&\n\t\t\t\t    (pwd_last_set + min_pwd_age > time(NULL))) {\n\t\t\t\t\tPAM_WB_REMARK_DIRECT(ctx,\n\t\t\t\t\t     \"NT_STATUS_PWD_TOO_RECENT\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WBC_PWD_CHANGE_PASSWORD_TOO_SHORT:\n\t\t\t\tPAM_WB_REMARK_DIRECT(ctx,\n\t\t\t\t\t\"NT_STATUS_PWD_TOO_SHORT\");\n\t\t\t\tbreak;\n\t\t\tcase WBC_PWD_CHANGE_PWD_IN_HISTORY:\n\t\t\t\tPAM_WB_REMARK_DIRECT(ctx,\n\t\t\t\t\t\"NT_STATUS_PWD_HISTORY_CONFLICT\");\n\t\t\t\tbreak;\n\t\t\tcase WBC_PWD_CHANGE_NOT_COMPLEX:\n\t\t\t\t_make_remark(ctx, PAM_ERROR_MSG,\n\t\t\t\t\t     _(\"Password does not meet \"\n\t\t\t\t\t       \"complexity requirements\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_pam_log_debug(ctx, LOG_DEBUG,\n\t\t\t\t\t       \"unknown password change \"\n\t\t\t\t\t       \"reject reason: %d\",\n\t\t\t\t\t       reject_reason);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpwd_restriction_string =\n\t\t\t_pam_compose_pwd_restriction_string(ctx, policy);\n\t\tif (pwd_restriction_string) {\n\t\t\t_make_remark(ctx, PAM_ERROR_MSG,\n\t\t\t\t     pwd_restriction_string);\n\t\t\tTALLOC_FREE(pwd_restriction_string);\n\t\t}\n\t}\n done:\n\twbcFreeMemory(error);\n\twbcFreeMemory(policy);\n\n\treturn ret;\n}", "func_hash": 4357864677082075361049541879133417846, "file_name": "pam_winbind.c", "file_hash": 159213883402940222877074906279748425580, "cwe": [], "cve": "CVE-2012-6150", "cve_desc": "The winbind_name_list_to_sid_string_list function in nsswitch/pam_winbind.c in Samba through 4.1.2 handles invalid require_membership_of group names by accepting authentication by any user, which allows remote authenticated users to bypass intended access restrictions in opportunistic circumstances by leveraging an administrator's pam_winbind configuration-file mistake.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-6150"}
{"idx": 2114, "project": "linux", "commit_id": "c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754", "commit_message": "USB: cypress_m8: add endpoint sanity check\n\nAn attack using missing endpoints exists.\n\nCVE-2016-3137\n\nSigned-off-by: Oliver Neukum <ONeukum@suse.com>\nCC: stable@vger.kernel.org\nSigned-off-by: Johan Hovold <johan@kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 1, "func": "static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint result = 0;\n\n\tif (!priv->comm_is_ok)\n\t\treturn -EIO;\n\n\t/* clear halts before open */\n\tusb_clear_halt(serial->dev, 0x81);\n\tusb_clear_halt(serial->dev, 0x02);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t/* reset read/write statistics */\n\tpriv->bytes_in = 0;\n\tpriv->bytes_out = 0;\n\tpriv->cmd_count = 0;\n\tpriv->rx_flags = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t/* Set termios */\n\tcypress_send(port);\n\n\tif (tty)\n \t\tcypress_set_termios(tty, port, &priv->tmp_termios);\n \n \t/* setup the port and start reading from the device */\n\tif (!port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"%s - interrupt_in_urb is empty!\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n \tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n \t\tusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n \t\tport->interrupt_in_urb->transfer_buffer,\n\t\tport->interrupt_in_urb->transfer_buffer_length,\n\t\tcypress_read_int_callback, port, priv->read_urb_interval);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\n\tif (result) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tcypress_set_dead(port);\n\t}\n\n\treturn result;\n} /* cypress_open */\n", "func_hash": 24933462448207739107700705725886965920, "file_name": "cypress_m8.c", "file_hash": 185821559057352693604924043774572250527, "cwe": ["CWE-703"], "cve": "CVE-2016-3137", "cve_desc": "drivers/usb/serial/cypress_m8.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a USB device without both an interrupt-in and an interrupt-out endpoint descriptor, related to the cypress_generic_port_probe and cypress_open functions.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3137"}
{"idx": 9418, "project": "ImageMagick", "commit_id": "8598a497e2d1f556a34458cf54b40ba40674734c", "project_url": "https://github.com/ImageMagick/ImageMagick", "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/8598a497e2d1f556a34458cf54b40ba40674734c", "commit_message": "None", "target": 1, "func": "static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \"BoundingBox:\"\n#define BeginDocument  \"BeginDocument:\"\n#define BeginXMPPacket  \"<?xpacket begin=\"\n#define EndXMPPacket  \"<?xpacket end=\"\n#define ICCProfile \"BeginICCProfile:\"\n#define CMYKCustomColor  \"CMYKCustomColor:\"\n#define CMYKProcessColor  \"CMYKProcessColor:\"\n#define DocumentMedia  \"DocumentMedia:\"\n#define DocumentCustomColors  \"DocumentCustomColors:\"\n#define DocumentProcessColors  \"DocumentProcessColors:\"\n#define EndDocument  \"EndDocument:\"\n#define HiResBoundingBox  \"HiResBoundingBox:\"\n#define ImageData  \"ImageData:\"\n#define PageBoundingBox  \"PageBoundingBox:\"\n#define LanguageLevel  \"LanguageLevel:\"\n#define PageMedia  \"PageMedia:\"\n#define Pages  \"Pages:\"\n#define PhotoshopProfile  \"BeginPhotoshop:\"\n#define PostscriptLevel  \"!PS-\"\n#define RenderPostscriptText  \"  Rendering Postscript...  \"\n#define SpotColor  \"+ \"\n\n  char\n    command[MaxTextExtent],\n    *density,\n    filename[MaxTextExtent],\n    geometry[MaxTextExtent],\n    input_filename[MaxTextExtent],\n    message[MaxTextExtent],\n    *options,\n    postscript_filename[MaxTextExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *postscript_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    fitPage,\n    skip,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution;\n\n  RectangleInfo\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  short int\n    hex_digits[256];\n\n  size_t\n    length,\n    priority;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned long\n    columns,\n    extent,\n    language_level,\n    pages,\n    rows,\n    scene,\n    spotcolor;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize hex values.\n  */\n  (void) ResetMagickMemory(hex_digits,0,sizeof(hex_digits));\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->x_resolution == 0.0) || (image->y_resolution == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  resolution.x=image->x_resolution;\n  resolution.y=image->y_resolution;\n  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);\n  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);\n  /*\n    Determine page geometry from the Postscript bounding box.\n  */\n  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));\n  (void) ResetMagickMemory(command,0,sizeof(command));\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  (void) ResetMagickMemory(&hires_bounds,0,sizeof(hires_bounds));\n  priority=0;\n  columns=0;\n  rows=0;\n  extent=0;\n  spotcolor=0;\n  language_level=1;\n  skip=MagickFalse;\n  pages=(~0UL);\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MaxTextExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\"ps:Level\",command+4);\n        if (GlobExpression(command,\"*EPSF-*\",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \" %lu\",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \" %lu\",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \" %lu %lu\",&columns,&rows);\n    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)\n      {\n        unsigned char\n          *datum;\n\n        /*\n          Read ICC profile.\n        */\n        profile=AcquireStringInfo(MaxTextExtent);\n        datum=GetStringInfoDatum(profile);\n        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)\n        {\n          if (i >= (ssize_t) GetStringInfoLength(profile))\n            {\n              SetStringInfoLength(profile,(size_t) i << 1);\n              datum=GetStringInfoDatum(profile);\n            }\n          datum[i]=(unsigned char) c;\n        }\n        SetStringInfoLength(profile,(size_t) i+1);\n        (void) SetImageProfile(image,\"icc\",profile);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)\n      {\n        unsigned char\n          *p;\n\n        /*\n          Read Photoshop profile.\n        */\n        count=(ssize_t) sscanf(command,PhotoshopProfile \" %lu\",&extent);\n         if (count != 1)\n           continue;\n         length=extent;\n         profile=BlobToStringInfo((const void *) NULL,length);\n         if (profile != (StringInfo *) NULL)\n           {\n            p=GetStringInfoDatum(profile);\n            for (i=0; i < (ssize_t) length; i++)\n              *p++=(unsigned char) ProfileInteger(image,hex_digits);\n            (void) SetImageProfile(image,\"8bim\",profile);\n            profile=DestroyStringInfo(profile);\n          }\n        continue;\n      }\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        register size_t\n          i;\n\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,i+1);\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MaxTextExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,i);\n        (void) SetImageProfile(image,\"xmp\",profile);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    /*\n      Is this a CMYK document?\n    */\n    length=strlen(DocumentProcessColors);\n    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)\n      {\n        if ((GlobExpression(command,\"*Cyan*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Magenta*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Yellow*\",MagickTrue) != MagickFalse))\n          cmyk=MagickTrue;\n      }\n    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    length=strlen(DocumentCustomColors);\n    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||\n        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||\n        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))\n      {\n        char\n          property[MaxTextExtent],\n          *value;\n\n        register char\n          *p;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MaxTextExtent,\"ps:SpotColor-%.20g\",\n          (double) (spotcolor++));\n        for (p=command; *p != '\\0'; p++)\n          if (isspace((int) (unsigned char) *p) != 0)\n            break;\n        value=AcquireString(p);\n        (void) SubstituteString(&value,\"(\",\"\");\n        (void) SubstituteString(&value,\")\",\"\");\n        (void) StripString(value);\n        (void) SetImageProperty(image,property,value);\n        value=DestroyString(value);\n        continue;\n      }\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note region defined by bounding box.\n    */\n    count=0;\n    i=0;\n    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,BoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=2;\n      }\n    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,DocumentMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,HiResBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=3;\n      }\n    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if ((count != 4) || (i < (ssize_t) priority))\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      if (i == (ssize_t) priority)\n        continue;\n    hires_bounds=bounds;\n    priority=i;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) &&\n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set Postscript render geometry.\n      */\n      (void) FormatLocaleString(geometry,MaxTextExtent,\"%gx%g%+.15g%+.15g\",\n        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\"ps:HiResBoundingBox\",geometry);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"eps:fit-page\");\n  if (option != (char *) NULL)\n  {\n    char\n      *geometry;\n\n    MagickStatusType\n      flags;\n\n    geometry=GetPageGeometry(option);\n    flags=ParseMetaGeometry(geometry,&page.x,&page.y,&page.width,&page.height);\n    if (flags == NoValue)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"InvalidGeometry\",\"`%s'\",option);\n        image=DestroyImage(image);\n        return((Image *) NULL);\n      }\n    page.width=(size_t) ceil((double) (page.width*image->x_resolution/delta.x)\n      -0.5);\n    page.height=(size_t) ceil((double) (page.height*image->y_resolution/\n      delta.y) -0.5);\n    geometry=DestroyString(geometry);\n    fitPage=MagickTrue;\n  }\n  (void) CloseBlob(image);\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(&image->exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(command,\"/setpagedevice {pop} bind 1 index where {\"\n    \"dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\\n\"\n    \"<</UseCIEColor true>>setpagedevice\\n\",MaxTextExtent);\n  count=write(file,command,(unsigned int) strlen(command));\n  if (image_info->page == (char *) NULL)\n    {\n      char\n        translate_geometry[MaxTextExtent];\n\n      (void) FormatLocaleString(translate_geometry,MaxTextExtent,\n        \"%g %g translate\\n\",-hires_bounds.x1,-hires_bounds.y1);\n      count=write(file,translate_geometry,(unsigned int)\n        strlen(translate_geometry));\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n    if (cmyk != MagickFalse)\n      delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n    else\n      delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MaxTextExtent,\"%gx%g\",resolution.x,\n    resolution.y);\n  (void) FormatLocaleString(options,MaxTextExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MaxTextExtent];\n\n      (void) FormatLocaleString(pages,MaxTextExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g \",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MaxTextExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  if (*image_info->magick == 'E')\n    {\n      option=GetImageOption(image_info,\"eps:use-cropbox\");\n      if ((option == (const char *) NULL) ||\n          (IsStringTrue(option) != MagickFalse))\n        (void) ConcatenateMagickString(options,\"-dEPSCrop \",MaxTextExtent);\n      if (fitPage != MagickFalse)\n        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",MaxTextExtent);\n    }\n  (void) CopyMagickString(filename,read_info->filename,MaxTextExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MaxTextExtent);\n  (void) FormatLocaleString(command,MaxTextExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);\n  (void) InterpretImageFilename(image_info,image,filename,1,\n    read_info->filename);\n  if ((status == MagickFalse) ||\n      (IsPostscriptRendered(read_info->filename) == MagickFalse))\n    {\n      (void) ConcatenateMagickString(command,\" -c showpage\",MaxTextExtent);\n      status=InvokePostscriptDelegate(read_info->verbose,command,message,\n        exception);\n    }\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  postscript_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&postscript_image,next);\n    }\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (postscript_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n          \"PostscriptDelegateFailed\",\"`%s'\",message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(postscript_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          postscript_image=DestroyImageList(postscript_image);\n          postscript_image=cmyk_image;\n        }\n    }\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      register ssize_t\n        i;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&postscript_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(postscript_image->filename,filename,MaxTextExtent);\n    (void) CopyMagickString(postscript_image->magick,image->magick,\n      MaxTextExtent);\n    if (columns != 0)\n      postscript_image->magick_columns=columns;\n    if (rows != 0)\n      postscript_image->magick_rows=rows;\n    postscript_image->page=page;\n    (void) CloneImageProfiles(postscript_image,image);\n    (void) CloneImageProperties(postscript_image,image);\n    next=SyncNextImageInList(postscript_image);\n    if (next != (Image *) NULL)\n      postscript_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImageList(image);\n  scene=0;\n  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(postscript_image));\n}\n", "func_hash": 136311021343540439524826913710137015019, "file_name": "None", "file_hash": null, "cwe": ["CWE-834"], "cve": "CVE-2017-14172", "cve_desc": "In coders/ps.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSImage() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large \"extent\" field in the header but does not contain sufficient backing data, is provided, the loop over \"length\" would consume huge CPU resources, since there is no EOF check inside the loop.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-14172"}
{"idx": 204287, "project": "oniguruma", "commit_id": "bfc36d3d8139b8be4d3df630d625c58687b0c7d4", "project_url": "https://github.com/kkos/oniguruma", "commit_url": "https://github.com/kkos/oniguruma/commit/bfc36d3d8139b8be4d3df630d625c58687b0c7d4", "commit_message": "fix #164: Integer overflow related to reg->dmax in search_in_range()", "target": 1, "func": "search_in_range(regex_t* reg, const UChar* str, const UChar* end,\n                const UChar* start, const UChar* range, /* match start range */\n                const UChar* data_range, /* subject string range */\n                OnigRegion* region,\n                OnigOptionType option, OnigMatchParam* mp)\n{\n  int r;\n  UChar *s, *prev;\n  MatchArg msa;\n  const UChar *orig_start = start;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr,\n     \"onig_search (entry point): str: %p, end: %d, start: %d, range: %d\\n\",\n     str, (int )(end - str), (int )(start - str), (int )(range - str));\n#endif\n\n  ADJUST_MATCH_PARAM(reg, mp);\n\n  if (region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    r = onig_region_resize_clear(region, reg->num_mem + 1);\n    if (r != 0) goto finish_no_msa;\n  }\n\n  if (start > end || start < str) goto mismatch_no_msa;\n\n  if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n    if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end)) {\n      r = ONIGERR_INVALID_WIDE_CHAR_VALUE;\n      goto finish_no_msa;\n    }\n  }\n\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n#define MATCH_AND_RETURN_CHECK(upper_range) \\\n  r = match_at(reg, str, end, (upper_range), s, prev, &msa); \\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      if (! IS_FIND_LONGEST(reg->options)) {\\\n        goto match;\\\n      }\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#else\n#define MATCH_AND_RETURN_CHECK(upper_range) \\\n  r = match_at(reg, str, end, (upper_range), s, prev, &msa); \\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      goto match;\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#endif /* USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE */\n\n\n  /* anchor optimize: resume search range */\n  if (reg->anchor != 0 && str < end) {\n    UChar *min_semi_end, *max_semi_end;\n\n    if (reg->anchor & ANCR_BEGIN_POSITION) {\n      /* search start-position only */\n    begin_position:\n      if (range > start)\n        range = start + 1;\n      else\n        range = start;\n    }\n    else if (reg->anchor & ANCR_BEGIN_BUF) {\n      /* search str-position only */\n      if (range > start) {\n        if (start != str) goto mismatch_no_msa;\n        range = str + 1;\n      }\n      else {\n        if (range <= str) {\n          start = str;\n          range = str;\n        }\n        else\n          goto mismatch_no_msa;\n      }\n    }\n    else if (reg->anchor & ANCR_END_BUF) {\n      min_semi_end = max_semi_end = (UChar* )end;\n\n    end_buf:\n      if ((OnigLen )(max_semi_end - str) < reg->anchor_dmin)\n        goto mismatch_no_msa;\n\n      if (range > start) {\n        if ((OnigLen )(min_semi_end - start) > reg->anchor_dmax) {\n          start = min_semi_end - reg->anchor_dmax;\n          if (start < end)\n            start = onigenc_get_right_adjust_char_head(reg->enc, str, start);\n        }\n        if ((OnigLen )(max_semi_end - (range - 1)) < reg->anchor_dmin) {\n          range = max_semi_end - reg->anchor_dmin + 1;\n        }\n\n        if (start > range) goto mismatch_no_msa;\n        /* If start == range, match with empty at end.\n           Backward search is used. */\n      }\n      else {\n        if ((OnigLen )(min_semi_end - range) > reg->anchor_dmax) {\n          range = min_semi_end - reg->anchor_dmax;\n        }\n        if ((OnigLen )(max_semi_end - start) < reg->anchor_dmin) {\n          start = max_semi_end - reg->anchor_dmin;\n          start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, start);\n        }\n        if (range > start) goto mismatch_no_msa;\n      }\n    }\n    else if (reg->anchor & ANCR_SEMI_END_BUF) {\n      UChar* pre_end = ONIGENC_STEP_BACK(reg->enc, str, end, 1);\n\n      max_semi_end = (UChar* )end;\n      if (ONIGENC_IS_MBC_NEWLINE(reg->enc, pre_end, end)) {\n        min_semi_end = pre_end;\n\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n        pre_end = ONIGENC_STEP_BACK(reg->enc, str, pre_end, 1);\n        if (IS_NOT_NULL(pre_end) &&\n            ONIGENC_IS_MBC_CRNL(reg->enc, pre_end, end)) {\n          min_semi_end = pre_end;\n        }\n#endif\n        if (min_semi_end > str && start <= min_semi_end) {\n          goto end_buf;\n        }\n      }\n      else {\n        min_semi_end = (UChar* )end;\n        goto end_buf;\n      }\n    }\n    else if ((reg->anchor & ANCR_ANYCHAR_INF_ML)) {\n      goto begin_position;\n    }\n  }\n  else if (str == end) { /* empty string */\n    static const UChar* address_for_empty_string = (UChar* )\"\";\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr, \"onig_search: empty string.\\n\");\n#endif\n\n    if (reg->threshold_len == 0) {\n      start = end = str = address_for_empty_string;\n      s = (UChar* )start;\n      prev = (UChar* )NULL;\n\n      MATCH_ARG_INIT(msa, reg, option, region, start, mp);\n      MATCH_AND_RETURN_CHECK(end);\n      goto mismatch;\n    }\n    goto mismatch_no_msa;\n  }\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"onig_search(apply anchor): end: %d, start: %d, range: %d\\n\",\n          (int )(end - str), (int )(start - str), (int )(range - str));\n#endif\n\n  MATCH_ARG_INIT(msa, reg, option, region, orig_start, mp);\n\n  s = (UChar* )start;\n  if (range > start) {   /* forward search */\n    if (s > str)\n      prev = onigenc_get_prev_char_head(reg->enc, str, s);\n    else\n      prev = (UChar* )NULL;\n\n    if (reg->optimize != OPTIMIZE_NONE) {\n      UChar *sch_range, *low, *high, *low_prev;\n\n      sch_range = (UChar* )range;\n      if (reg->dist_max != 0) {\n        if (reg->dist_max == INFINITE_LEN)\n          sch_range = (UChar* )end;\n        else {\n          sch_range += reg->dist_max;\n          if (sch_range > end) sch_range = (UChar* )end;\n        }\n      }\n\n      if ((end - start) < reg->threshold_len)\n        goto mismatch;\n\n      if (reg->dist_max != INFINITE_LEN) {\n        do {\n          if (! forward_search(reg, str, end, s, sch_range, &low, &high,\n                               &low_prev)) goto mismatch;\n          if (s < low) {\n            s    = low;\n            prev = low_prev;\n          }\n          while (s <= high) {\n            MATCH_AND_RETURN_CHECK(data_range);\n            prev = s;\n            s += enclen(reg->enc, s);\n          }\n        } while (s < range);\n        goto mismatch;\n      }\n      else { /* check only. */\n        if (! forward_search(reg, str, end, s, sch_range, &low, &high,\n                             (UChar** )NULL)) goto mismatch;\n\n        if ((reg->anchor & ANCR_ANYCHAR_INF) != 0) {\n          do {\n            MATCH_AND_RETURN_CHECK(data_range);\n            prev = s;\n            s += enclen(reg->enc, s);\n\n            if ((reg->anchor & (ANCR_LOOK_BEHIND | ANCR_PREC_READ_NOT)) == 0) {\n              while (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end) && s < range) {\n                prev = s;\n                s += enclen(reg->enc, s);\n              }\n            }\n          } while (s < range);\n          goto mismatch;\n        }\n      }\n    }\n\n    do {\n      MATCH_AND_RETURN_CHECK(data_range);\n      prev = s;\n      s += enclen(reg->enc, s);\n    } while (s < range);\n\n    if (s == range) { /* because empty match with /$/. */\n      MATCH_AND_RETURN_CHECK(data_range);\n    }\n  }\n  else {  /* backward search */\n    if (range < str) goto mismatch;\n\n    if (orig_start < end)\n      orig_start += enclen(reg->enc, orig_start); /* is upper range */\n\n    if (reg->optimize != OPTIMIZE_NONE) {\n      UChar *low, *high, *adjrange, *sch_start;\n\n      if ((end - range) < reg->threshold_len) goto mismatch;\n\n      if (range < end)\n        adjrange = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, range);\n      else\n        adjrange = (UChar* )end;\n\n      if (reg->dist_max != INFINITE_LEN) {\n        do {\n          sch_start = s + reg->dist_max;\n          if (sch_start >= end)\n            sch_start = onigenc_get_prev_char_head(reg->enc, str, end);\n\n          if (backward_search(reg, str, end, sch_start, range, adjrange,\n                              &low, &high) <= 0)\n            goto mismatch;\n\n          if (s > high)\n            s = high;\n\n          while (s >= low) {\n            prev = onigenc_get_prev_char_head(reg->enc, str, s);\n            MATCH_AND_RETURN_CHECK(orig_start);\n            s = prev;\n          }\n        } while (s >= range);\n        goto mismatch;\n      }\n      else { /* check only. */\n        sch_start = s;\n        if (reg->dist_max != 0) {\n          if (reg->dist_max == INFINITE_LEN)\n            sch_start = (UChar* )end;\n          else {\n            sch_start += reg->dist_max;\n            if (sch_start >= end) sch_start = (UChar* )end;\n            else\n              sch_start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc,\n                                                        start, sch_start);\n          }\n          if (sch_start >= end)\n            sch_start = onigenc_get_prev_char_head(reg->enc, str, end);\n        }\n        if (backward_search(reg, str, end, sch_start, range, adjrange,\n                            &low, &high) <= 0) goto mismatch;\n      }\n    }\n\n    do {\n      prev = onigenc_get_prev_char_head(reg->enc, str, s);\n      MATCH_AND_RETURN_CHECK(orig_start);\n      s = prev;\n    } while (s >= range);\n  }\n\n mismatch:\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n  if (IS_FIND_LONGEST(reg->options)) {\n    if (msa.best_len >= 0) {\n      s = msa.best_s;\n      goto match;\n    }\n  }\n#endif\n  r = ONIG_MISMATCH;\n\n finish:\n  MATCH_ARG_FREE(msa);\n\n  /* If result is mismatch and no FIND_NOT_EMPTY option,\n     then the region is not set in match_at(). */\n  if (IS_FIND_NOT_EMPTY(reg->options) && region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    onig_region_clear(region);\n  }\n\n#ifdef ONIG_DEBUG\n  if (r != ONIG_MISMATCH)\n    fprintf(stderr, \"onig_search: error %d\\n\", r);\n#endif\n  return r;\n\n mismatch_no_msa:\n  r = ONIG_MISMATCH;\n finish_no_msa:\n#ifdef ONIG_DEBUG\n  if (r != ONIG_MISMATCH)\n    fprintf(stderr, \"onig_search: error %d\\n\", r);\n#endif\n  return r;\n\n match:\n  MATCH_ARG_FREE(msa);\n  return (int )(s - str);\n}", "func_hash": 228591662235986540178258976559472704289, "file_name": "regexec.c", "file_hash": 273722622053944329834068754494744869133, "cwe": ["CWE-125"], "cve": "CVE-2019-19012", "cve_desc": "An integer overflow in the search_in_range function in regexec.c in Oniguruma 6.x before 6.9.4_rc2 leads to an out-of-bounds read, in which the offset of this read is under the control of an attacker. (This only affects the 32-bit compiled version). Remote attackers can cause a denial-of-service or information disclosure, or possibly have unspecified other impact, via a crafted regular expression.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19012"}
{"idx": 450535, "project": "linux", "commit_id": "27d461333459d282ffa4a2bdb6b215a59d493a8f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/27d461333459d282ffa4a2bdb6b215a59d493a8f", "commit_message": "i40e: prevent memory leak in i40e_setup_macvlans\n\nIn i40e_setup_macvlans if i40e_setup_channel fails the allocated memory\nfor ch should be released.\n\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nTested-by: Andrew Bowers <andrewx.bowers@intel.com>\nSigned-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>", "target": 0, "func": "static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,\n\t\t\t\t\t    struct rtnl_link_stats64 *stats)\n{\n\tu64 bytes, packets;\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin_irq(&ring->syncp);\n\t\tpackets = ring->stats.packets;\n\t\tbytes   = ring->stats.bytes;\n\t} while (u64_stats_fetch_retry_irq(&ring->syncp, start));\n\n\tstats->tx_packets += packets;\n\tstats->tx_bytes   += bytes;\n}", "func_hash": 202856344701827857107606582268316527995, "file_name": "i40e_main.c", "file_hash": 288123846412478965482970439941830707811, "cwe": ["CWE-401"], "cve": "CVE-2019-19043", "cve_desc": "A memory leak in the i40e_setup_macvlans() function in drivers/net/ethernet/intel/i40e/i40e_main.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering i40e_setup_channel() failures, aka CID-27d461333459.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19043"}
{"idx": 66131, "project": "Little-CMS", "commit_id": "5ca71a7bc18b6897ab21d815d15e218e204581e2", "project_url": "https://github.com/mm2/Little-CMS", "commit_url": "https://github.com/mm2/Little-CMS/commit/5ca71a7bc18b6897ab21d815d15e218e204581e2", "commit_message": "Added an extra check to MLU bounds\n\nThanks to Ibrahim el-sayed for spotting the bug", "target": 0, "func": "cmsBool  Type_MPEmatrix_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number i, nElems;\n    cmsStage* mpe = (cmsStage*) Ptr;\n    _cmsStageMatrixData* Matrix = (_cmsStageMatrixData*) mpe ->Data;\n\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->OutputChannels)) return FALSE;\n\n    nElems = mpe ->InputChannels * mpe ->OutputChannels;\n\n    for (i=0; i < nElems; i++) {\n        if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) Matrix->Double[i])) return FALSE;\n    }\n\n\n    for (i=0; i < mpe ->OutputChannels; i++) {\n\n        if (Matrix ->Offset == NULL) {\n\n               if (!_cmsWriteFloat32Number(io, 0)) return FALSE;\n        }\n        else {\n               if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) Matrix->Offset[i])) return FALSE;\n        }\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n", "func_hash": 275552335520090457899173240238397614991, "file_name": "cmstypes.c", "file_hash": 332694077870161989474087757872563748000, "cwe": ["CWE-125"], "cve": "CVE-2016-10165", "cve_desc": "The Type_MLU_Read function in cmstypes.c in Little CMS (aka lcms2) allows remote attackers to obtain sensitive information or cause a denial of service via an image with a crafted ICC profile, which triggers an out-of-bounds heap read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10165"}
{"idx": 214976, "project": "linux", "commit_id": "f4351a199cc120ff9d59e06d02e8657d08e6cc46", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f4351a199cc120ff9d59e06d02e8657d08e6cc46", "commit_message": "ALSA: usb-audio: Avoid access before bLength check in build_audio_procunit()\n\nThe parser for the processing unit reads bNrInPins field before the\nbLength sanity check, which may lead to an out-of-bound access when a\nmalformed descriptor is given.  Fix it by assignment after the bLength\ncheck.\n\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "target": 1, "func": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "func_hash": 12215826483691912695596794611235130095, "file_name": "mixer.c", "file_hash": 66640194003274081519783449994141558073, "cwe": ["CWE-125"], "cve": "CVE-2019-15927", "cve_desc": "An issue was discovered in the Linux kernel before 4.20.2. An out-of-bounds access exists in the function build_audio_procunit in the file sound/usb/mixer.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-15927"}
{"idx": 204160, "project": "oniguruma", "commit_id": "f015fbdd95f76438cd86366467bb2b39870dd7c6", "project_url": "https://github.com/kkos/oniguruma", "commit_url": "https://github.com/kkos/oniguruma/commit/f015fbdd95f76438cd86366467bb2b39870dd7c6", "commit_message": "fix #55 : Byte value expressed in octal must be smaller than 256", "target": 1, "func": "fetch_token_in_cc(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int num;\n  OnigCodePoint c, c2;\n  OnigSyntaxType* syn = env->syntax;\n  OnigEncoding enc = env->enc;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  PFETCH(c);\n  tok->type = TK_CHAR;\n  tok->base = 0;\n  tok->u.c  = c;\n  tok->escaped = 0;\n\n  if (c == ']') {\n    tok->type = TK_CC_CLOSE;\n  }\n  else if (c == '-') {\n    tok->type = TK_CC_RANGE;\n  }\n  else if (c == MC_ESC(syn)) {\n    if (! IS_SYNTAX_BV(syn, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC))\n      goto end;\n\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    PFETCH(c);\n    tok->escaped = 1;\n    tok->u.c = c;\n    switch (c) {\n    case 'w':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n    case 'W':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n    case 'd':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'D':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n    case 's':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n    case 'S':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'p':\n    case 'P':\n      if (PEND) break;\n\n      c2 = PPEEK;\n      if (c2 == '{' &&\n\t  IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n\tPINC;\n\ttok->type = TK_CHAR_PROPERTY;\n\ttok->u.prop.not = (c == 'P' ? 1 : 0);\n\n\tif (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n\t  PFETCH(c2);\n\t  if (c2 == '^') {\n\t    tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n\t  }\n\t  else\n\t    PUNFETCH;\n\t}\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n        PINC;\n        num = scan_unsigned_hexadecimal_number(&p, end, 8, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          c2 = PPEEK;\n          if (ONIGENC_IS_CODE_XDIGIT(enc, c2))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->base   = 16;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 2, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 16;\n        tok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 4, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type   = TK_CODE_POINT;\n        tok->base   = 16;\n        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '0':\n    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        PUNFETCH;\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, 3, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      break;\n\n    default:\n      PUNFETCH;\n      num = fetch_escaped_value(&p, end, env, &c2);\n      if (num < 0) return num;\n      if (tok->u.c != c2) {\n        tok->u.code = c2;\n        tok->type   = TK_CODE_POINT;\n      }\n      break;\n    }\n  }\n  else if (c == '[') {\n    if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_POSIX_BRACKET) && (PPEEK_IS(':'))) {\n      OnigCodePoint send[] = { (OnigCodePoint )':', (OnigCodePoint )']' };\n      tok->backp = p; /* point at '[' is read */\n      PINC;\n      if (str_exist_check_with_esc(send, 2, p, end,\n                                   (OnigCodePoint )']', enc, syn)) {\n        tok->type = TK_POSIX_BRACKET_OPEN;\n      }\n      else {\n        PUNFETCH;\n        goto cc_in_cc;\n      }\n    }\n    else {\n    cc_in_cc:\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP)) {\n        tok->type = TK_CC_CC_OPEN;\n      }\n      else {\n        CC_ESC_WARN(env, (UChar* )\"[\");\n      }\n    }\n  }\n  else if (c == '&') {\n    if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP) &&\n        !PEND && (PPEEK_IS('&'))) {\n      PINC;\n      tok->type = TK_CC_AND;\n    }\n  }\n\n end:\n  *src = p;\n  return tok->type;\n}", "func_hash": 95497899004455921849880798039460633766, "file_name": "regparse.c", "file_hash": 31891282150523284949071273148244295780, "cwe": ["CWE-787"], "cve": "CVE-2017-9226", "cve_desc": "An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A heap out-of-bounds write or read occurs in next_state_val() during regular expression compilation. Octal numbers larger than 0xff are not handled correctly in fetch_token() and fetch_token_in_cc(). A malformed regular expression containing an octal number in the form of '\\700' would produce an invalid code point value larger than 0xff in next_state_val(), resulting in an out-of-bounds write memory corruption.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9226"}
