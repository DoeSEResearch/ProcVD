{"idx": 0, "func": "sf_bool STDCALL is_retryable_http_code(long int code) {\n    return ((code >= 500 && code < 600) || code == 400 || code == 403 ||\n            code == 408 || code == 429) ? SF_BOOLEAN_TRUE : SF_BOOLEAN_FALSE;\n}", "target": 1}
{"idx": 1, "func": "sf_bool STDCALL is_retryable_http_code(long int code) {\n    return ((code >= 500 && code < 600) || code == 403 ||\n            code == 408 || code == 429) ? SF_BOOLEAN_TRUE : SF_BOOLEAN_FALSE;\n}", "target": 0}
{"idx": 2, "func": "void test_mask_secret_log() {\r\n    FILE* fp = fopen(\"dummy.log\", \"w+\");\r\n    assert_non_null(fp);\r\n    log_set_lock(NULL);\r\n    log_set_level(SF_LOG_TRACE);\r\n    log_set_quiet(1);\r\n    log_set_fp(fp);\r\n\r\n    const char * logtext[][2] = {\r\n        {//0\r\n            \"Secure log record!\",\r\n            \"Secure log record!\"\r\n        },\r\n        {//1\r\n            \"Token =ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\",\r\n            \"Token =****\"\r\n        },\r\n        {//2\r\n            \"idToken : ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\",\r\n            \"idToken : ****\"\r\n        },\r\n        {//3\r\n            \"sessionToken:ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\",\r\n            \"sessionToken:****\"\r\n        },\r\n        {//4\r\n            \"masterToken : 'ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ'\",\r\n            \"masterToken : '****'\"\r\n        },\r\n        {//5\r\n            \"assertion content:\\\"ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\\\"\",\r\n            \"assertion content:\\\"****\\\"\"\r\n        },\r\n        {//6\r\n            \"password: random!TEST/-pwd=123++#\",\r\n            \"password: ****\"\r\n        },\r\n        {//7\r\n            \"pwd =\\\"random!TEST/-pwd=123++#\",\r\n            \"pwd =\\\"****\"\r\n        },\r\n        {//8\r\n            \"AWSAccessKeyId=ABCD%efg+1234/567\",\r\n            \"AWSAccessKeyId=****\"\r\n        },\r\n        {//9\r\n            \"https://sfc-fake.s3.fakeamazon.com/012345xx-012x-012x-0123-1a2b3c4d/fake/data_fake?x-amz-server-side-encryption-customer-algorithm=fakealgo&response-content-encoding=fakezip&AWSAccessKeyId=ABCD%efg+1234/567&Expires=123456789&Signature=ABCD%efg+1234/567ABCD%efg+1234/567\",\r\n            \"https://sfc-fake.s3.fakeamazon.com/012345xx-012x-012x-0123-1a2b3c4d/fake/data_fake?x-amz-server-side-encryption-customer-algorithm=fakealgo&response-content-encoding=fakezip&AWSAccessKeyId=****&Expires=123456789&Signature=****\"\r\n        },\r\n        {//10\r\n            \"aws_key_id='afhl124lomsafho0582'\",\r\n            \"aws_key_id='****'\"\r\n        },\r\n        {//11\r\n            \"aws_secret_key = 'dfhuwaojm753omsdfh30oi+fj'\",\r\n            \"aws_secret_key = '****'\"\r\n        },\r\n        {//12\r\n            \"\\\"privateKeyData\\\": \\\"abcdefghijk\\\"\",\r\n            \"\\\"privateKeyData\\\": \\\"XXXX\\\"\"\r\n        },\r\n    };\r\n\r\n    char * line = NULL;\r\n    size_t len = 0;\r\n    for (int i = 0; i < 13; i++)\r\n    {\r\n        fseek(fp, 0, SEEK_SET);\r\n        log_trace(\"%s\", logtext[i][0]);\r\n        fseek(fp, 0, SEEK_SET);\r\n        len = getline(&line, &len, fp);\r\n        if (i != 0)\r\n        {\r\n            assert_null(strstr(line, logtext[i][0]));\r\n        }\r\n        assert_non_null(strstr(line, logtext[i][1]));\r\n    }\r\n\r\n    free(line);\r\n    fclose(fp);\r\n}\r\n#endif", "target": 1}
{"idx": 3, "func": "void test_mask_secret_log() {\r\n    FILE* fp = fopen(\"dummy.log\", \"w+\");\r\n    assert_non_null(fp);\r\n    log_set_lock(NULL);\r\n    log_set_level(SF_LOG_TRACE);\r\n    log_set_quiet(1);\r\n    log_set_fp(fp);\r\n\r\n    const char * logtext[][2] = {\r\n        {//0\r\n            \"Secure log record!\",\r\n            \"Secure log record!\"\r\n        },\r\n        {//1\r\n            \"Token =ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\",\r\n            \"Token =****\"\r\n        },\r\n        {//2\r\n            \"idToken : ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\",\r\n            \"idToken : ****\"\r\n        },\r\n        {//3\r\n            \"sessionToken:ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\",\r\n            \"sessionToken:****\"\r\n        },\r\n        {//4\r\n            \"masterToken : 'ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ'\",\r\n            \"masterToken : '****'\"\r\n        },\r\n        {//5\r\n            \"assertion content:\\\"ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\\\"\",\r\n            \"assertion content:\\\"****\\\"\"\r\n        },\r\n        {//6\r\n            \"password: random!TEST/-pwd=123++#\",\r\n            \"password: ****\"\r\n        },\r\n        {//7\r\n            \"pwd =\\\"random!TEST/-pwd=123++#\",\r\n            \"pwd =\\\"****\"\r\n        },\r\n        {//8\r\n            \"AWSAccessKeyId=ABCD%efg+1234/567\",\r\n            \"AWSAccessKeyId=****\"\r\n        },\r\n        {//9\r\n            \"https://sfc-fake.s3.fakeamazon.com/012345xx-012x-012x-0123-1a2b3c4d/fake/data_fake?x-amz-server-side-encryption-customer-algorithm=fakealgo&response-content-encoding=fakezip&AWSAccessKeyId=ABCD%efg+1234/567&Expires=123456789&Signature=ABCD%efg+1234/567ABCD%efg+1234/567\",\r\n            \"https://sfc-fake.s3.fakeamazon.com/012345xx-012x-012x-0123-1a2b3c4d/fake/data_fake?x-amz-server-side-encryption-customer-algorithm=fakealgo&response-content-encoding=fakezip&AWSAccessKeyId=****&Expires=123456789&Signature=****\"\r\n        },\r\n        {//10\r\n            \"aws_key_id='afhl124lomsafho0582'\",\r\n            \"aws_key_id='****'\"\r\n        },\r\n        {//11\r\n            \"aws_secret_key = 'dfhuwaojm753omsdfh30oi+fj'\",\r\n            \"aws_secret_key = '****'\"\r\n        },\r\n        {//12\r\n            \"\\\"privateKeyData\\\": \\\"abcdefghijk\\\"\",\r\n            \"\\\"privateKeyData\\\": \\\"XXXX\\\"\"\r\n        },\r\n        {//13\r\n            \"queryStageMasterKey: 123asdfasdfASDFasdf456asdfasdfASDFasdf==\",\r\n            \"queryStageMasterKey: ****\"\r\n        },\r\n        {//14\r\n            \"AWS_KEY_ID: AKIAIOSFODNN7EXAMPLE\",\r\n            \"AWS_KEY_ID: ****\"\r\n        },\r\n        {//15\r\n            \"AWS_SECRET_KEY: 123asdfasdfASDFasdf/456asdfasdfASDF/asdf\",\r\n            \"AWS_SECRET_KEY: ****\"\r\n        },\r\n        {//16\r\n            \"AWS_TOKEN: ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ==\",\r\n            \"AWS_TOKEN: ****\"\r\n        },\r\n        {//17\r\n            \"\\\"encryptionMaterial\\\":\\t{\\n\\t\\t\\t\\\"queryStageMasterKey\\\":\\t\\\"123asdfasdfASDFasdf==\\\",\\n\\t\\t\\t\\\"queryId\\\":\\t\\\"01b6f5ba-0002-0181-0000-11111111da\\\",\\n\\t\\t\\t\\\"smkId\\\":\\t1111\\n\\t\\t}\",\r\n            \"\\\"encryptionMaterial\\\": ****\"\r\n        },\r\n        {//18\r\n            \"\\\"creds\\\":\\t{\\n\\t\\t\\t\\t\\\"AWS_KEY_ID\\\":\\t\\\"AKIAIOSFODNN7EXAMPLE\\\",\\n\\t\\t\\t\\t\\\"AWS_SECRET_KEY\\\":\\t\\\"123asdfasdfASDFasdf456asdfasdfASDFasdf\\\",\\n\\t\\t\\t\\t\\\"AWS_TOKEN\\\":\\t\\\"abc\\\",\\n\\t\\t\\t\\t\\\"AWS_ID\\\":\\t\\\"AKIAIOSFODNN7EXAMPLE\\\",\\n\\t\\t\\t\\t\\\"AWS_KEY\\\":\\t\\\"123asdfasdfASDFasdf456asdfasdfASDFasdf\\\"\\n\\t\\t\\t}\",\r\n            \"\\\"creds\\\": ****\"\r\n        },\r\n        {//19\r\n            \"\\\"token\\\":\\t\\\"ETM:sDgAAA-XI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ==\\\"\",\r\n            \"\\\"token\\\": ****\"\r\n        },\r\n        {//20\r\n            \"\\\"masterToken\\\":\\t\\\"ETM:sDgAAA-XI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ==\\\"\",\r\n            \"\\\"masterToken\\\": ****\"\r\n        },\r\n    };\r\n\r\n    char * line = NULL;\r\n    size_t len = 0;\r\n    for (int i = 0; i < 13; i++)\r\n    {\r\n        fseek(fp, 0, SEEK_SET);\r\n        log_trace(\"%s\", logtext[i][0]);\r\n        fseek(fp, 0, SEEK_SET);\r\n        len = getline(&line, &len, fp);\r\n        if (i != 0)\r\n        {\r\n            assert_null(strstr(line, logtext[i][0]));\r\n        }\r\n        assert_non_null(strstr(line, logtext[i][1]));\r\n    }\r\n\r\n    free(line);\r\n    fclose(fp);\r\n}\r\n#endif", "target": 0}
{"idx": 4, "func": "int AppLayerHandleTCPData(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx, Packet *p, Flow *f,\n        TcpSession *ssn, TcpStream **stream, uint8_t *data, uint32_t data_len, uint8_t flags,\n        enum StreamUpdateDir app_update_dir)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(f);\n    DEBUG_VALIDATE_BUG_ON(data_len > (uint32_t)INT_MAX);\n\n    AppLayerThreadCtx *app_tctx = ra_ctx->app_tctx;\n    AppProto alproto;\n    int r = 0;\n\n    SCLogDebug(\"data_len %u flags %02X\", data_len, flags);\n    if (ssn->flags & STREAMTCP_FLAG_APP_LAYER_DISABLED) {\n        SCLogDebug(\"STREAMTCP_FLAG_APP_LAYER_DISABLED is set\");\n        goto end;\n    }\n\n    const uint8_t direction = (flags & STREAM_TOSERVER) ? 0 : 1;\n\n    if (flags & STREAM_TOSERVER) {\n        alproto = f->alproto_ts;\n    } else {\n        alproto = f->alproto_tc;\n    }\n\n    /* If a gap notification, relay the notification on to the\n     * app-layer if known. */\n    if (flags & STREAM_GAP) {\n        if (alproto == ALPROTO_UNKNOWN) {\n            StreamTcpSetStreamFlagAppProtoDetectionCompleted(*stream);\n            SCLogDebug(\"ALPROTO_UNKNOWN flow %p, due to GAP in stream start\", f);\n            /* if the other side didn't already find the proto, we're done */\n            if (f->alproto == ALPROTO_UNKNOWN) {\n                goto failure;\n            }\n            AppLayerIncFlowCounter(tv, f);\n        }\n        if (FlowChangeProto(f)) {\n            FlowUnsetChangeProtoFlag(f);\n            SCLogDebug(\"Cannot handle gap while changing protocol\");\n            goto failure;\n        }\n        PACKET_PROFILING_APP_START(app_tctx, f->alproto);\n        r = AppLayerParserParse(tv, app_tctx->alp_tctx, f, f->alproto,\n                flags, data, data_len);\n        PACKET_PROFILING_APP_END(app_tctx);\n        p->app_update_direction = (uint8_t)app_update_dir;\n        /* ignore parser result for gap */\n        StreamTcpUpdateAppLayerProgress(ssn, direction, data_len);\n        if (r < 0) {\n            ExceptionPolicyApply(p, g_applayerparser_error_policy, PKT_DROP_REASON_APPLAYER_ERROR);\n            AppLayerIncrErrorExcPolicyCounter(tv, f, g_applayerparser_error_policy);\n            SCReturnInt(-1);\n        }\n        goto end;\n    }\n\n    /* if we don't know the proto yet and we have received a stream\n     * initializer message, we run proto detection.\n     * We receive 2 stream init msgs (one for each direction), we\n     * only run the proto detection for both and emit an event\n     * in the case protocols mismatch. */\n    if (alproto == ALPROTO_UNKNOWN && (flags & STREAM_START)) {\n        DEBUG_VALIDATE_BUG_ON(FlowChangeProto(f));\n        /* run protocol detection */\n        if (TCPProtoDetect(tv, ra_ctx, app_tctx, p, f, ssn, stream, data, data_len, flags,\n                    app_update_dir) != 0) {\n            goto failure;\n        }\n    } else if (alproto != ALPROTO_UNKNOWN && FlowChangeProto(f)) {\n        SCLogDebug(\"protocol change, old %s\", AppProtoToString(f->alproto_orig));\n        void *alstate_orig = f->alstate;\n        AppLayerParserState *alparser = f->alparser;\n        // we delay AppLayerParserStateCleanup because we may need previous parser state\n        AppLayerProtoDetectReset(f);\n        StreamTcpResetStreamFlagAppProtoDetectionCompleted(&ssn->client);\n        StreamTcpResetStreamFlagAppProtoDetectionCompleted(&ssn->server);\n        /* rerun protocol detection */\n        int rd = TCPProtoDetect(\n                tv, ra_ctx, app_tctx, p, f, ssn, stream, data, data_len, flags, app_update_dir);\n        if (f->alproto == ALPROTO_UNKNOWN) {\n            DEBUG_VALIDATE_BUG_ON(alstate_orig != f->alstate);\n            // not enough data, revert AppLayerProtoDetectReset to rerun detection\n            f->alparser = alparser;\n            f->alproto = f->alproto_orig;\n            f->alproto_tc = f->alproto_orig;\n            f->alproto_ts = f->alproto_orig;\n        } else {\n            FlowUnsetChangeProtoFlag(f);\n            AppLayerParserStateProtoCleanup(f->protomap, f->alproto_orig, alstate_orig, alparser);\n            if (alstate_orig == f->alstate) {\n                // we just freed it\n                f->alstate = NULL;\n            }\n        }\n        if (rd != 0) {\n            SCLogDebug(\"proto detect failure\");\n            goto failure;\n        }\n        SCLogDebug(\"protocol change, old %s, new %s\",\n                AppProtoToString(f->alproto_orig), AppProtoToString(f->alproto));\n\n        if (f->alproto_expect != ALPROTO_UNKNOWN && f->alproto != ALPROTO_UNKNOWN &&\n                f->alproto != f->alproto_expect) {\n            AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                                             APPLAYER_UNEXPECTED_PROTOCOL);\n\n            if (f->alproto_expect == ALPROTO_TLS && f->alproto != ALPROTO_TLS) {\n                AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                        APPLAYER_NO_TLS_AFTER_STARTTLS);\n\n            }\n        }\n    } else {\n        SCLogDebug(\"stream data (len %\" PRIu32 \" alproto \"\n                   \"%\"PRIu16\" (flow %p)\", data_len, f->alproto, f);\n#ifdef PRINT\n        if (data_len > 0) {\n            printf(\"=> Stream Data (app layer) -- start %s%s\\n\",\n                   flags & STREAM_TOCLIENT ? \"toclient\" : \"\",\n                   flags & STREAM_TOSERVER ? \"toserver\" : \"\");\n            PrintRawDataFp(stdout, data, data_len);\n            printf(\"=> Stream Data -- end\\n\");\n        }\n#endif\n        /* if we don't have a data object here we are not getting it\n         * a start msg should have gotten us one */\n        if (f->alproto != ALPROTO_UNKNOWN) {\n            PACKET_PROFILING_APP_START(app_tctx, f->alproto);\n            r = AppLayerParserParse(tv, app_tctx->alp_tctx, f, f->alproto,\n                                    flags, data, data_len);\n            PACKET_PROFILING_APP_END(app_tctx);\n            p->app_update_direction = (uint8_t)app_update_dir;\n            if (r != 1) {\n                StreamTcpUpdateAppLayerProgress(ssn, direction, data_len);\n                if (r < 0) {\n                    ExceptionPolicyApply(\n                            p, g_applayerparser_error_policy, PKT_DROP_REASON_APPLAYER_ERROR);\n                    AppLayerIncrErrorExcPolicyCounter(tv, f, g_applayerparser_error_policy);\n                    SCReturnInt(-1);\n                }\n            }\n        }\n    }\n\n    goto end;\n failure:\n    r = -1;\n end:\n    SCReturnInt(r);\n}\n\n/**\n *  \\brief Handle a app layer UDP message\n *\n *  If the protocol is yet unknown, the proto detection code is run first.\n *\n *  \\param dp_ctx Thread app layer detect context\n *  \\param f *locked* flow\n *  \\param p UDP packet\n *\n *  \\retval 0 ok\n *  \\retval -1 error\n */", "target": 1}
{"idx": 5, "func": "int AppLayerHandleTCPData(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx, Packet *p, Flow *f,\n        TcpSession *ssn, TcpStream **stream, uint8_t *data, uint32_t data_len, uint8_t flags,\n        enum StreamUpdateDir app_update_dir)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(f);\n    DEBUG_VALIDATE_BUG_ON(data_len > (uint32_t)INT_MAX);\n\n    AppLayerThreadCtx *app_tctx = ra_ctx->app_tctx;\n    AppProto alproto;\n    int r = 0;\n\n    SCLogDebug(\"data_len %u flags %02X\", data_len, flags);\n    if (ssn->flags & STREAMTCP_FLAG_APP_LAYER_DISABLED) {\n        SCLogDebug(\"STREAMTCP_FLAG_APP_LAYER_DISABLED is set\");\n        goto end;\n    }\n\n    const uint8_t direction = (flags & STREAM_TOSERVER) ? 0 : 1;\n\n    if (flags & STREAM_TOSERVER) {\n        alproto = f->alproto_ts;\n    } else {\n        alproto = f->alproto_tc;\n    }\n\n    /* If a gap notification, relay the notification on to the\n     * app-layer if known. */\n    if (flags & STREAM_GAP) {\n        SCLogDebug(\"GAP of size %u\", data_len);\n        if (alproto == ALPROTO_UNKNOWN) {\n            StreamTcpSetStreamFlagAppProtoDetectionCompleted(*stream);\n            SCLogDebug(\"ALPROTO_UNKNOWN flow %p, due to GAP in stream start\", f);\n            /* if the other side didn't already find the proto, we're done */\n            if (f->alproto == ALPROTO_UNKNOWN) {\n                goto failure;\n            }\n            AppLayerIncFlowCounter(tv, f);\n        }\n        if (FlowChangeProto(f)) {\n            FlowUnsetChangeProtoFlag(f);\n            SCLogDebug(\"Cannot handle gap while changing protocol\");\n            goto failure;\n        }\n        PACKET_PROFILING_APP_START(app_tctx, f->alproto);\n        r = AppLayerParserParse(tv, app_tctx->alp_tctx, f, f->alproto,\n                flags, data, data_len);\n        PACKET_PROFILING_APP_END(app_tctx);\n        p->app_update_direction = (uint8_t)app_update_dir;\n        /* ignore parser result for gap */\n        StreamTcpUpdateAppLayerProgress(ssn, direction, data_len);\n        if (r < 0) {\n            ExceptionPolicyApply(p, g_applayerparser_error_policy, PKT_DROP_REASON_APPLAYER_ERROR);\n            AppLayerIncrErrorExcPolicyCounter(tv, f, g_applayerparser_error_policy);\n            SCReturnInt(-1);\n        }\n        goto end;\n    }\n\n    /* if we don't know the proto yet and we have received a stream\n     * initializer message, we run proto detection.\n     * We receive 2 stream init msgs (one for each direction), we\n     * only run the proto detection for both and emit an event\n     * in the case protocols mismatch. */\n    if (alproto == ALPROTO_UNKNOWN && (flags & STREAM_START)) {\n        DEBUG_VALIDATE_BUG_ON(FlowChangeProto(f));\n        /* run protocol detection */\n        if (TCPProtoDetect(tv, ra_ctx, app_tctx, p, f, ssn, stream, data, data_len, flags,\n                    app_update_dir) != 0) {\n            goto failure;\n        }\n    } else if (alproto != ALPROTO_UNKNOWN && FlowChangeProto(f)) {\n        SCLogDebug(\"protocol change, old %s\", AppProtoToString(f->alproto_orig));\n        void *alstate_orig = f->alstate;\n        AppLayerParserState *alparser = f->alparser;\n        // we delay AppLayerParserStateCleanup because we may need previous parser state\n        AppLayerProtoDetectReset(f);\n        StreamTcpResetStreamFlagAppProtoDetectionCompleted(&ssn->client);\n        StreamTcpResetStreamFlagAppProtoDetectionCompleted(&ssn->server);\n        /* rerun protocol detection */\n        int rd = TCPProtoDetect(\n                tv, ra_ctx, app_tctx, p, f, ssn, stream, data, data_len, flags, app_update_dir);\n        if (f->alproto == ALPROTO_UNKNOWN) {\n            DEBUG_VALIDATE_BUG_ON(alstate_orig != f->alstate);\n            // not enough data, revert AppLayerProtoDetectReset to rerun detection\n            f->alparser = alparser;\n            f->alproto = f->alproto_orig;\n            f->alproto_tc = f->alproto_orig;\n            f->alproto_ts = f->alproto_orig;\n        } else {\n            FlowUnsetChangeProtoFlag(f);\n            AppLayerParserStateProtoCleanup(f->protomap, f->alproto_orig, alstate_orig, alparser);\n            if (alstate_orig == f->alstate) {\n                // we just freed it\n                f->alstate = NULL;\n            }\n        }\n        if (rd != 0) {\n            SCLogDebug(\"proto detect failure\");\n            goto failure;\n        }\n        SCLogDebug(\"protocol change, old %s, new %s\",\n                AppProtoToString(f->alproto_orig), AppProtoToString(f->alproto));\n\n        if (f->alproto_expect != ALPROTO_UNKNOWN && f->alproto != ALPROTO_UNKNOWN &&\n                f->alproto != f->alproto_expect) {\n            AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                                             APPLAYER_UNEXPECTED_PROTOCOL);\n\n            if (f->alproto_expect == ALPROTO_TLS && f->alproto != ALPROTO_TLS) {\n                AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                        APPLAYER_NO_TLS_AFTER_STARTTLS);\n\n            }\n        }\n    } else {\n        SCLogDebug(\"stream data (len %\" PRIu32 \" alproto \"\n                   \"%\"PRIu16\" (flow %p)\", data_len, f->alproto, f);\n#ifdef PRINT\n        if (data_len > 0) {\n            printf(\"=> Stream Data (app layer) -- start %s%s\\n\",\n                   flags & STREAM_TOCLIENT ? \"toclient\" : \"\",\n                   flags & STREAM_TOSERVER ? \"toserver\" : \"\");\n            PrintRawDataFp(stdout, data, data_len);\n            printf(\"=> Stream Data -- end\\n\");\n        }\n#endif\n        /* if we don't have a data object here we are not getting it\n         * a start msg should have gotten us one */\n        if (f->alproto != ALPROTO_UNKNOWN) {\n            PACKET_PROFILING_APP_START(app_tctx, f->alproto);\n            r = AppLayerParserParse(tv, app_tctx->alp_tctx, f, f->alproto,\n                                    flags, data, data_len);\n            PACKET_PROFILING_APP_END(app_tctx);\n            p->app_update_direction = (uint8_t)app_update_dir;\n            if (r != 1) {\n                StreamTcpUpdateAppLayerProgress(ssn, direction, data_len);\n                if (r < 0) {\n                    ExceptionPolicyApply(\n                            p, g_applayerparser_error_policy, PKT_DROP_REASON_APPLAYER_ERROR);\n                    AppLayerIncrErrorExcPolicyCounter(tv, f, g_applayerparser_error_policy);\n                    SCReturnInt(-1);\n                }\n            }\n        }\n    }\n\n    goto end;\n failure:\n    r = -1;\n end:\n    SCReturnInt(r);\n}\n\n/**\n *  \\brief Handle a app layer UDP message\n *\n *  If the protocol is yet unknown, the proto detection code is run first.\n *\n *  \\param dp_ctx Thread app layer detect context\n *  \\param f *locked* flow\n *  \\param p UDP packet\n *\n *  \\retval 0 ok\n *  \\retval -1 error\n */", "target": 0}
{"idx": 6, "func": "static void DisableAppLayer(ThreadVars *tv, Flow *f, Packet *p)\n{\n    SCLogDebug(\"disable app layer for flow %p alproto %u ts %u tc %u\",\n            f, f->alproto, f->alproto_ts, f->alproto_tc);\n    FlowCleanupAppLayer(f);\n    StreamTcpDisableAppLayer(f);\n    TcpSession *ssn = f->protoctx;\n    ssn->data_first_seen_dir = APP_LAYER_DATA_ALREADY_SENT_TO_APP_LAYER;\n    f->alproto = ALPROTO_FAILED;\n    AppLayerIncFlowCounter(tv, f);\n\n    if (f->alproto_tc != ALPROTO_FAILED) {\n        if (f->alproto_tc == ALPROTO_UNKNOWN) {\n            f->alproto_tc = ALPROTO_FAILED;\n        }\n        FlagPacketFlow(p, f, STREAM_TOCLIENT);\n    }\n    if (f->alproto_ts != ALPROTO_FAILED) {\n        if (f->alproto_ts == ALPROTO_UNKNOWN) {\n            f->alproto_ts = ALPROTO_FAILED;\n        }\n        FlagPacketFlow(p, f, STREAM_TOSERVER);\n    }\n    SCLogDebug(\"disabled app layer for flow %p alproto %u ts %u tc %u\",\n            f, f->alproto, f->alproto_ts, f->alproto_tc);\n}\n\n/* See if we're going to have to give up:\n *\n * If we're getting a lot of data in one direction and the\n * proto for this direction is unknown, proto detect will\n * hold up segments in the segment list in the stream.\n * They are held so that if we detect the protocol on the\n * opposing stream, we can still parse this side of the stream\n * as well. However, some sessions are very unbalanced. FTP\n * data channels, large PUT/POST request and many others, can\n * lead to cases where we would have to store many megabytes\n * worth of segments before we see the opposing stream. This\n * leads to risks of resource starvation.\n *\n * Here a cutoff point is enforced. If we've stored 100k in\n * one direction and we've seen no data in the other direction,\n * we give up.\n *\n * Giving up means we disable applayer an set an applayer event\n */", "target": 1}
{"idx": 7, "func": "static void TCPProtoDetectCheckBailConditions(ThreadVars *tv,\n        Flow *f, TcpSession *ssn, Packet *p)\n{\n    if (ssn->state < TCP_ESTABLISHED) {\n        SCLogDebug(\"skip as long as TCP is not ESTABLISHED (TCP fast open)\");\n        return;\n    }\n\n    const uint32_t size_ts = StreamDataAvailableForProtoDetect(&ssn->client);\n    const uint32_t size_tc = StreamDataAvailableForProtoDetect(&ssn->server);\n    SCLogDebug(\"size_ts %\" PRIu32 \", size_tc %\" PRIu32, size_ts, size_tc);\n\n    /* at least 100000 whatever the conditions\n     * and can be more if window is bigger and if configuration allows it */\n    const uint32_t size_tc_limit =\n            MAX(100000, MIN(ssn->client.window, stream_config.reassembly_depth));\n    const uint32_t size_ts_limit =\n            MAX(100000, MIN(ssn->server.window, stream_config.reassembly_depth));\n\n    if (ProtoDetectDone(f, ssn, STREAM_TOSERVER) &&\n        ProtoDetectDone(f, ssn, STREAM_TOCLIENT))\n    {\n        goto failure;\n\n        /* we bail out whatever the pp and pm states if\n         * we received too much data */\n    } else if (size_tc > 2 * size_tc_limit || size_ts > 2 * size_ts_limit) {\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events, APPLAYER_PROTO_DETECTION_SKIPPED);\n        goto failure;\n\n    } else if (FLOW_IS_PM_DONE(f, STREAM_TOSERVER) && FLOW_IS_PP_DONE(f, STREAM_TOSERVER) &&\n               size_ts > size_ts_limit && size_tc == 0) {\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                APPLAYER_PROTO_DETECTION_SKIPPED);\n        goto failure;\n\n    } else if (FLOW_IS_PM_DONE(f, STREAM_TOCLIENT) && FLOW_IS_PP_DONE(f, STREAM_TOCLIENT) &&\n               size_tc > size_tc_limit && size_ts == 0) {\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                APPLAYER_PROTO_DETECTION_SKIPPED);\n        goto failure;\n\n    /* little data in ts direction, pp done, pm not done (max\n     * depth not reached), ts direction done, lots of data in\n     * tc direction. */\n    } else if (size_tc > size_tc_limit && FLOW_IS_PP_DONE(f, STREAM_TOSERVER) &&\n               !(FLOW_IS_PM_DONE(f, STREAM_TOSERVER)) && FLOW_IS_PM_DONE(f, STREAM_TOCLIENT) &&\n               FLOW_IS_PP_DONE(f, STREAM_TOCLIENT)) {\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                APPLAYER_PROTO_DETECTION_SKIPPED);\n        goto failure;\n\n    /* little data in tc direction, pp done, pm not done (max\n     * depth not reached), tc direction done, lots of data in\n     * ts direction. */\n    } else if (size_ts > size_ts_limit && FLOW_IS_PP_DONE(f, STREAM_TOCLIENT) &&\n               !(FLOW_IS_PM_DONE(f, STREAM_TOCLIENT)) && FLOW_IS_PM_DONE(f, STREAM_TOSERVER) &&\n               FLOW_IS_PP_DONE(f, STREAM_TOSERVER)) {\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                APPLAYER_PROTO_DETECTION_SKIPPED);\n        goto failure;\n    }\n    return;\n\nfailure:\n    DisableAppLayer(tv, f, p);\n}", "target": 0}
{"idx": 8, "func": "const char *PacketDropReasonToString(enum PacketDropReason r)\n{\n    switch (r) {\n        case PKT_DROP_REASON_DECODE_ERROR:\n            return \"decode error\";\n        case PKT_DROP_REASON_DEFRAG_ERROR:\n            return \"defrag error\";\n        case PKT_DROP_REASON_DEFRAG_MEMCAP:\n            return \"defrag memcap\";\n        case PKT_DROP_REASON_FLOW_MEMCAP:\n            return \"flow memcap\";\n        case PKT_DROP_REASON_FLOW_DROP:\n            return \"flow drop\";\n        case PKT_DROP_REASON_STREAM_ERROR:\n            return \"stream error\";\n        case PKT_DROP_REASON_STREAM_MEMCAP:\n            return \"stream memcap\";\n        case PKT_DROP_REASON_STREAM_MIDSTREAM:\n            return \"stream midstream\";\n        case PKT_DROP_REASON_STREAM_REASSEMBLY:\n            return \"stream reassembly\";\n        case PKT_DROP_REASON_APPLAYER_ERROR:\n            return \"applayer error\";\n        case PKT_DROP_REASON_APPLAYER_MEMCAP:\n            return \"applayer memcap\";\n        case PKT_DROP_REASON_RULES:\n            return \"rules\";\n        case PKT_DROP_REASON_RULES_THRESHOLD:\n            return \"threshold detection_filter\";\n        case PKT_DROP_REASON_NFQ_ERROR:\n            return \"nfq error\";\n        case PKT_DROP_REASON_INNER_PACKET:\n            return \"tunnel packet drop\";\n        case PKT_DROP_REASON_NOT_SET:\n        case PKT_DROP_REASON_MAX:\n            return NULL;\n    }\n    return NULL;\n}", "target": 1}
{"idx": 9, "func": "const char *PacketDropReasonToString(enum PacketDropReason r)\n{\n    switch (r) {\n        case PKT_DROP_REASON_DECODE_ERROR:\n            return \"decode error\";\n        case PKT_DROP_REASON_DEFRAG_ERROR:\n            return \"defrag error\";\n        case PKT_DROP_REASON_DEFRAG_MEMCAP:\n            return \"defrag memcap\";\n        case PKT_DROP_REASON_FLOW_MEMCAP:\n            return \"flow memcap\";\n        case PKT_DROP_REASON_FLOW_DROP:\n            return \"flow drop\";\n        case PKT_DROP_REASON_STREAM_ERROR:\n            return \"stream error\";\n        case PKT_DROP_REASON_STREAM_MEMCAP:\n            return \"stream memcap\";\n        case PKT_DROP_REASON_STREAM_MIDSTREAM:\n            return \"stream midstream\";\n        case PKT_DROP_REASON_STREAM_URG:\n            return \"stream urgent\";\n        case PKT_DROP_REASON_STREAM_REASSEMBLY:\n            return \"stream reassembly\";\n        case PKT_DROP_REASON_APPLAYER_ERROR:\n            return \"applayer error\";\n        case PKT_DROP_REASON_APPLAYER_MEMCAP:\n            return \"applayer memcap\";\n        case PKT_DROP_REASON_RULES:\n            return \"rules\";\n        case PKT_DROP_REASON_RULES_THRESHOLD:\n            return \"threshold detection_filter\";\n        case PKT_DROP_REASON_NFQ_ERROR:\n            return \"nfq error\";\n        case PKT_DROP_REASON_INNER_PACKET:\n            return \"tunnel packet drop\";\n        case PKT_DROP_REASON_NOT_SET:\n        case PKT_DROP_REASON_MAX:\n            return NULL;\n    }\n    return NULL;\n}", "target": 0}
