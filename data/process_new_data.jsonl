{"idx": 0, "func": "sf_bool STDCALL is_retryable_http_code(long int code) {\n    return ((code >= 500 && code < 600) || code == 400 || code == 403 ||\n            code == 408 || code == 429) ? SF_BOOLEAN_TRUE : SF_BOOLEAN_FALSE;\n}", "target": 1}
{"idx": 1, "func": "sf_bool STDCALL is_retryable_http_code(long int code) {\n    return ((code >= 500 && code < 600) || code == 403 ||\n            code == 408 || code == 429) ? SF_BOOLEAN_TRUE : SF_BOOLEAN_FALSE;\n}", "target": 0}
{"idx": 2, "func": "void test_mask_secret_log() {\r\n    FILE* fp = fopen(\"dummy.log\", \"w+\");\r\n    assert_non_null(fp);\r\n    log_set_lock(NULL);\r\n    log_set_level(SF_LOG_TRACE);\r\n    log_set_quiet(1);\r\n    log_set_fp(fp);\r\n\r\n    const char * logtext[][2] = {\r\n        {//0\r\n            \"Secure log record!\",\r\n            \"Secure log record!\"\r\n        },\r\n        {//1\r\n            \"Token =ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\",\r\n            \"Token =****\"\r\n        },\r\n        {//2\r\n            \"idToken : ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\",\r\n            \"idToken : ****\"\r\n        },\r\n        {//3\r\n            \"sessionToken:ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\",\r\n            \"sessionToken:****\"\r\n        },\r\n        {//4\r\n            \"masterToken : 'ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ'\",\r\n            \"masterToken : '****'\"\r\n        },\r\n        {//5\r\n            \"assertion content:\\\"ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\\\"\",\r\n            \"assertion content:\\\"****\\\"\"\r\n        },\r\n        {//6\r\n            \"password: random!TEST/-pwd=123++#\",\r\n            \"password: ****\"\r\n        },\r\n        {//7\r\n            \"pwd =\\\"random!TEST/-pwd=123++#\",\r\n            \"pwd =\\\"****\"\r\n        },\r\n        {//8\r\n            \"AWSAccessKeyId=ABCD%efg+1234/567\",\r\n            \"AWSAccessKeyId=****\"\r\n        },\r\n        {//9\r\n            \"https://sfc-fake.s3.fakeamazon.com/012345xx-012x-012x-0123-1a2b3c4d/fake/data_fake?x-amz-server-side-encryption-customer-algorithm=fakealgo&response-content-encoding=fakezip&AWSAccessKeyId=ABCD%efg+1234/567&Expires=123456789&Signature=ABCD%efg+1234/567ABCD%efg+1234/567\",\r\n            \"https://sfc-fake.s3.fakeamazon.com/012345xx-012x-012x-0123-1a2b3c4d/fake/data_fake?x-amz-server-side-encryption-customer-algorithm=fakealgo&response-content-encoding=fakezip&AWSAccessKeyId=****&Expires=123456789&Signature=****\"\r\n        },\r\n        {//10\r\n            \"aws_key_id='afhl124lomsafho0582'\",\r\n            \"aws_key_id='****'\"\r\n        },\r\n        {//11\r\n            \"aws_secret_key = 'dfhuwaojm753omsdfh30oi+fj'\",\r\n            \"aws_secret_key = '****'\"\r\n        },\r\n        {//12\r\n            \"\\\"privateKeyData\\\": \\\"abcdefghijk\\\"\",\r\n            \"\\\"privateKeyData\\\": \\\"XXXX\\\"\"\r\n        },\r\n    };\r\n\r\n    char * line = NULL;\r\n    size_t len = 0;\r\n    for (int i = 0; i < 13; i++)\r\n    {\r\n        fseek(fp, 0, SEEK_SET);\r\n        log_trace(\"%s\", logtext[i][0]);\r\n        fseek(fp, 0, SEEK_SET);\r\n        len = getline(&line, &len, fp);\r\n        if (i != 0)\r\n        {\r\n            assert_null(strstr(line, logtext[i][0]));\r\n        }\r\n        assert_non_null(strstr(line, logtext[i][1]));\r\n    }\r\n\r\n    free(line);\r\n    fclose(fp);\r\n}\r\n#endif", "target": 1}
{"idx": 3, "func": "void test_mask_secret_log() {\r\n    FILE* fp = fopen(\"dummy.log\", \"w+\");\r\n    assert_non_null(fp);\r\n    log_set_lock(NULL);\r\n    log_set_level(SF_LOG_TRACE);\r\n    log_set_quiet(1);\r\n    log_set_fp(fp);\r\n\r\n    const char * logtext[][2] = {\r\n        {//0\r\n            \"Secure log record!\",\r\n            \"Secure log record!\"\r\n        },\r\n        {//1\r\n            \"Token =ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\",\r\n            \"Token =****\"\r\n        },\r\n        {//2\r\n            \"idToken : ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\",\r\n            \"idToken : ****\"\r\n        },\r\n        {//3\r\n            \"sessionToken:ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\",\r\n            \"sessionToken:****\"\r\n        },\r\n        {//4\r\n            \"masterToken : 'ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ'\",\r\n            \"masterToken : '****'\"\r\n        },\r\n        {//5\r\n            \"assertion content:\\\"ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ\\\"\",\r\n            \"assertion content:\\\"****\\\"\"\r\n        },\r\n        {//6\r\n            \"password: random!TEST/-pwd=123++#\",\r\n            \"password: ****\"\r\n        },\r\n        {//7\r\n            \"pwd =\\\"random!TEST/-pwd=123++#\",\r\n            \"pwd =\\\"****\"\r\n        },\r\n        {//8\r\n            \"AWSAccessKeyId=ABCD%efg+1234/567\",\r\n            \"AWSAccessKeyId=****\"\r\n        },\r\n        {//9\r\n            \"https://sfc-fake.s3.fakeamazon.com/012345xx-012x-012x-0123-1a2b3c4d/fake/data_fake?x-amz-server-side-encryption-customer-algorithm=fakealgo&response-content-encoding=fakezip&AWSAccessKeyId=ABCD%efg+1234/567&Expires=123456789&Signature=ABCD%efg+1234/567ABCD%efg+1234/567\",\r\n            \"https://sfc-fake.s3.fakeamazon.com/012345xx-012x-012x-0123-1a2b3c4d/fake/data_fake?x-amz-server-side-encryption-customer-algorithm=fakealgo&response-content-encoding=fakezip&AWSAccessKeyId=****&Expires=123456789&Signature=****\"\r\n        },\r\n        {//10\r\n            \"aws_key_id='afhl124lomsafho0582'\",\r\n            \"aws_key_id='****'\"\r\n        },\r\n        {//11\r\n            \"aws_secret_key = 'dfhuwaojm753omsdfh30oi+fj'\",\r\n            \"aws_secret_key = '****'\"\r\n        },\r\n        {//12\r\n            \"\\\"privateKeyData\\\": \\\"abcdefghijk\\\"\",\r\n            \"\\\"privateKeyData\\\": \\\"XXXX\\\"\"\r\n        },\r\n        {//13\r\n            \"queryStageMasterKey: 123asdfasdfASDFasdf456asdfasdfASDFasdf==\",\r\n            \"queryStageMasterKey: ****\"\r\n        },\r\n        {//14\r\n            \"AWS_KEY_ID: AKIAIOSFODNN7EXAMPLE\",\r\n            \"AWS_KEY_ID: ****\"\r\n        },\r\n        {//15\r\n            \"AWS_SECRET_KEY: 123asdfasdfASDFasdf/456asdfasdfASDF/asdf\",\r\n            \"AWS_SECRET_KEY: ****\"\r\n        },\r\n        {//16\r\n            \"AWS_TOKEN: ETMsDgAAAXI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ==\",\r\n            \"AWS_TOKEN: ****\"\r\n        },\r\n        {//17\r\n            \"\\\"encryptionMaterial\\\":\\t{\\n\\t\\t\\t\\\"queryStageMasterKey\\\":\\t\\\"123asdfasdfASDFasdf==\\\",\\n\\t\\t\\t\\\"queryId\\\":\\t\\\"01b6f5ba-0002-0181-0000-11111111da\\\",\\n\\t\\t\\t\\\"smkId\\\":\\t1111\\n\\t\\t}\",\r\n            \"\\\"encryptionMaterial\\\": ****\"\r\n        },\r\n        {//18\r\n            \"\\\"creds\\\":\\t{\\n\\t\\t\\t\\t\\\"AWS_KEY_ID\\\":\\t\\\"AKIAIOSFODNN7EXAMPLE\\\",\\n\\t\\t\\t\\t\\\"AWS_SECRET_KEY\\\":\\t\\\"123asdfasdfASDFasdf456asdfasdfASDFasdf\\\",\\n\\t\\t\\t\\t\\\"AWS_TOKEN\\\":\\t\\\"abc\\\",\\n\\t\\t\\t\\t\\\"AWS_ID\\\":\\t\\\"AKIAIOSFODNN7EXAMPLE\\\",\\n\\t\\t\\t\\t\\\"AWS_KEY\\\":\\t\\\"123asdfasdfASDFasdf456asdfasdfASDFasdf\\\"\\n\\t\\t\\t}\",\r\n            \"\\\"creds\\\": ****\"\r\n        },\r\n        {//19\r\n            \"\\\"token\\\":\\t\\\"ETM:sDgAAA-XI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ==\\\"\",\r\n            \"\\\"token\\\": ****\"\r\n        },\r\n        {//20\r\n            \"\\\"masterToken\\\":\\t\\\"ETM:sDgAAA-XI0IS9NABRBRVMvQ0JDL1BLQ1M1UGFkZGluZwCAABAAEEb/xAQlmT+mwIx9G32E+ikAAACA/CPlEkq//+jWZnQkOj5VhjayruDsCVRGS/B6GzHUugXLc94EfEwuto94gS/oKSVrUg/JRPekypLAx4Afa1KW8n1RqXRF9Hzy1VVLmVEBMtei3yFJPNSHtfbeFHSr9eVB/OL8dOGbxQluGCh6XmaqTjyrh3fqUTWz7+n74+gu2ugAFFZ18iT+DStK0TTdmy4vBC6xUcHQ==\\\"\",\r\n            \"\\\"masterToken\\\": ****\"\r\n        },\r\n    };\r\n\r\n    char * line = NULL;\r\n    size_t len = 0;\r\n    for (int i = 0; i < 13; i++)\r\n    {\r\n        fseek(fp, 0, SEEK_SET);\r\n        log_trace(\"%s\", logtext[i][0]);\r\n        fseek(fp, 0, SEEK_SET);\r\n        len = getline(&line, &len, fp);\r\n        if (i != 0)\r\n        {\r\n            assert_null(strstr(line, logtext[i][0]));\r\n        }\r\n        assert_non_null(strstr(line, logtext[i][1]));\r\n    }\r\n\r\n    free(line);\r\n    fclose(fp);\r\n}\r\n#endif", "target": 0}
{"idx": 4, "func": "int AppLayerHandleTCPData(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx, Packet *p, Flow *f,\n        TcpSession *ssn, TcpStream **stream, uint8_t *data, uint32_t data_len, uint8_t flags,\n        enum StreamUpdateDir app_update_dir)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(f);\n    DEBUG_VALIDATE_BUG_ON(data_len > (uint32_t)INT_MAX);\n\n    AppLayerThreadCtx *app_tctx = ra_ctx->app_tctx;\n    AppProto alproto;\n    int r = 0;\n\n    SCLogDebug(\"data_len %u flags %02X\", data_len, flags);\n    if (ssn->flags & STREAMTCP_FLAG_APP_LAYER_DISABLED) {\n        SCLogDebug(\"STREAMTCP_FLAG_APP_LAYER_DISABLED is set\");\n        goto end;\n    }\n\n    const uint8_t direction = (flags & STREAM_TOSERVER) ? 0 : 1;\n\n    if (flags & STREAM_TOSERVER) {\n        alproto = f->alproto_ts;\n    } else {\n        alproto = f->alproto_tc;\n    }\n\n    /* If a gap notification, relay the notification on to the\n     * app-layer if known. */\n    if (flags & STREAM_GAP) {\n        if (alproto == ALPROTO_UNKNOWN) {\n            StreamTcpSetStreamFlagAppProtoDetectionCompleted(*stream);\n            SCLogDebug(\"ALPROTO_UNKNOWN flow %p, due to GAP in stream start\", f);\n            /* if the other side didn't already find the proto, we're done */\n            if (f->alproto == ALPROTO_UNKNOWN) {\n                goto failure;\n            }\n            AppLayerIncFlowCounter(tv, f);\n        }\n        if (FlowChangeProto(f)) {\n            FlowUnsetChangeProtoFlag(f);\n            SCLogDebug(\"Cannot handle gap while changing protocol\");\n            goto failure;\n        }\n        PACKET_PROFILING_APP_START(app_tctx, f->alproto);\n        r = AppLayerParserParse(tv, app_tctx->alp_tctx, f, f->alproto,\n                flags, data, data_len);\n        PACKET_PROFILING_APP_END(app_tctx);\n        p->app_update_direction = (uint8_t)app_update_dir;\n        /* ignore parser result for gap */\n        StreamTcpUpdateAppLayerProgress(ssn, direction, data_len);\n        if (r < 0) {\n            ExceptionPolicyApply(p, g_applayerparser_error_policy, PKT_DROP_REASON_APPLAYER_ERROR);\n            AppLayerIncrErrorExcPolicyCounter(tv, f, g_applayerparser_error_policy);\n            SCReturnInt(-1);\n        }\n        goto end;\n    }\n\n    /* if we don't know the proto yet and we have received a stream\n     * initializer message, we run proto detection.\n     * We receive 2 stream init msgs (one for each direction), we\n     * only run the proto detection for both and emit an event\n     * in the case protocols mismatch. */\n    if (alproto == ALPROTO_UNKNOWN && (flags & STREAM_START)) {\n        DEBUG_VALIDATE_BUG_ON(FlowChangeProto(f));\n        /* run protocol detection */\n        if (TCPProtoDetect(tv, ra_ctx, app_tctx, p, f, ssn, stream, data, data_len, flags,\n                    app_update_dir) != 0) {\n            goto failure;\n        }\n    } else if (alproto != ALPROTO_UNKNOWN && FlowChangeProto(f)) {\n        SCLogDebug(\"protocol change, old %s\", AppProtoToString(f->alproto_orig));\n        void *alstate_orig = f->alstate;\n        AppLayerParserState *alparser = f->alparser;\n        // we delay AppLayerParserStateCleanup because we may need previous parser state\n        AppLayerProtoDetectReset(f);\n        StreamTcpResetStreamFlagAppProtoDetectionCompleted(&ssn->client);\n        StreamTcpResetStreamFlagAppProtoDetectionCompleted(&ssn->server);\n        /* rerun protocol detection */\n        int rd = TCPProtoDetect(\n                tv, ra_ctx, app_tctx, p, f, ssn, stream, data, data_len, flags, app_update_dir);\n        if (f->alproto == ALPROTO_UNKNOWN) {\n            DEBUG_VALIDATE_BUG_ON(alstate_orig != f->alstate);\n            // not enough data, revert AppLayerProtoDetectReset to rerun detection\n            f->alparser = alparser;\n            f->alproto = f->alproto_orig;\n            f->alproto_tc = f->alproto_orig;\n            f->alproto_ts = f->alproto_orig;\n        } else {\n            FlowUnsetChangeProtoFlag(f);\n            AppLayerParserStateProtoCleanup(f->protomap, f->alproto_orig, alstate_orig, alparser);\n            if (alstate_orig == f->alstate) {\n                // we just freed it\n                f->alstate = NULL;\n            }\n        }\n        if (rd != 0) {\n            SCLogDebug(\"proto detect failure\");\n            goto failure;\n        }\n        SCLogDebug(\"protocol change, old %s, new %s\",\n                AppProtoToString(f->alproto_orig), AppProtoToString(f->alproto));\n\n        if (f->alproto_expect != ALPROTO_UNKNOWN && f->alproto != ALPROTO_UNKNOWN &&\n                f->alproto != f->alproto_expect) {\n            AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                                             APPLAYER_UNEXPECTED_PROTOCOL);\n\n            if (f->alproto_expect == ALPROTO_TLS && f->alproto != ALPROTO_TLS) {\n                AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                        APPLAYER_NO_TLS_AFTER_STARTTLS);\n\n            }\n        }\n    } else {\n        SCLogDebug(\"stream data (len %\" PRIu32 \" alproto \"\n                   \"%\"PRIu16\" (flow %p)\", data_len, f->alproto, f);\n#ifdef PRINT\n        if (data_len > 0) {\n            printf(\"=> Stream Data (app layer) -- start %s%s\\n\",\n                   flags & STREAM_TOCLIENT ? \"toclient\" : \"\",\n                   flags & STREAM_TOSERVER ? \"toserver\" : \"\");\n            PrintRawDataFp(stdout, data, data_len);\n            printf(\"=> Stream Data -- end\\n\");\n        }\n#endif\n        /* if we don't have a data object here we are not getting it\n         * a start msg should have gotten us one */\n        if (f->alproto != ALPROTO_UNKNOWN) {\n            PACKET_PROFILING_APP_START(app_tctx, f->alproto);\n            r = AppLayerParserParse(tv, app_tctx->alp_tctx, f, f->alproto,\n                                    flags, data, data_len);\n            PACKET_PROFILING_APP_END(app_tctx);\n            p->app_update_direction = (uint8_t)app_update_dir;\n            if (r != 1) {\n                StreamTcpUpdateAppLayerProgress(ssn, direction, data_len);\n                if (r < 0) {\n                    ExceptionPolicyApply(\n                            p, g_applayerparser_error_policy, PKT_DROP_REASON_APPLAYER_ERROR);\n                    AppLayerIncrErrorExcPolicyCounter(tv, f, g_applayerparser_error_policy);\n                    SCReturnInt(-1);\n                }\n            }\n        }\n    }\n\n    goto end;\n failure:\n    r = -1;\n end:\n    SCReturnInt(r);\n}\n\n/**\n *  \\brief Handle a app layer UDP message\n *\n *  If the protocol is yet unknown, the proto detection code is run first.\n *\n *  \\param dp_ctx Thread app layer detect context\n *  \\param f *locked* flow\n *  \\param p UDP packet\n *\n *  \\retval 0 ok\n *  \\retval -1 error\n */", "target": 1}
{"idx": 5, "func": "int AppLayerHandleTCPData(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx, Packet *p, Flow *f,\n        TcpSession *ssn, TcpStream **stream, uint8_t *data, uint32_t data_len, uint8_t flags,\n        enum StreamUpdateDir app_update_dir)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(f);\n    DEBUG_VALIDATE_BUG_ON(data_len > (uint32_t)INT_MAX);\n\n    AppLayerThreadCtx *app_tctx = ra_ctx->app_tctx;\n    AppProto alproto;\n    int r = 0;\n\n    SCLogDebug(\"data_len %u flags %02X\", data_len, flags);\n    if (ssn->flags & STREAMTCP_FLAG_APP_LAYER_DISABLED) {\n        SCLogDebug(\"STREAMTCP_FLAG_APP_LAYER_DISABLED is set\");\n        goto end;\n    }\n\n    const uint8_t direction = (flags & STREAM_TOSERVER) ? 0 : 1;\n\n    if (flags & STREAM_TOSERVER) {\n        alproto = f->alproto_ts;\n    } else {\n        alproto = f->alproto_tc;\n    }\n\n    /* If a gap notification, relay the notification on to the\n     * app-layer if known. */\n    if (flags & STREAM_GAP) {\n        SCLogDebug(\"GAP of size %u\", data_len);\n        if (alproto == ALPROTO_UNKNOWN) {\n            StreamTcpSetStreamFlagAppProtoDetectionCompleted(*stream);\n            SCLogDebug(\"ALPROTO_UNKNOWN flow %p, due to GAP in stream start\", f);\n            /* if the other side didn't already find the proto, we're done */\n            if (f->alproto == ALPROTO_UNKNOWN) {\n                goto failure;\n            }\n            AppLayerIncFlowCounter(tv, f);\n        }\n        if (FlowChangeProto(f)) {\n            FlowUnsetChangeProtoFlag(f);\n            SCLogDebug(\"Cannot handle gap while changing protocol\");\n            goto failure;\n        }\n        PACKET_PROFILING_APP_START(app_tctx, f->alproto);\n        r = AppLayerParserParse(tv, app_tctx->alp_tctx, f, f->alproto,\n                flags, data, data_len);\n        PACKET_PROFILING_APP_END(app_tctx);\n        p->app_update_direction = (uint8_t)app_update_dir;\n        /* ignore parser result for gap */\n        StreamTcpUpdateAppLayerProgress(ssn, direction, data_len);\n        if (r < 0) {\n            ExceptionPolicyApply(p, g_applayerparser_error_policy, PKT_DROP_REASON_APPLAYER_ERROR);\n            AppLayerIncrErrorExcPolicyCounter(tv, f, g_applayerparser_error_policy);\n            SCReturnInt(-1);\n        }\n        goto end;\n    }\n\n    /* if we don't know the proto yet and we have received a stream\n     * initializer message, we run proto detection.\n     * We receive 2 stream init msgs (one for each direction), we\n     * only run the proto detection for both and emit an event\n     * in the case protocols mismatch. */\n    if (alproto == ALPROTO_UNKNOWN && (flags & STREAM_START)) {\n        DEBUG_VALIDATE_BUG_ON(FlowChangeProto(f));\n        /* run protocol detection */\n        if (TCPProtoDetect(tv, ra_ctx, app_tctx, p, f, ssn, stream, data, data_len, flags,\n                    app_update_dir) != 0) {\n            goto failure;\n        }\n    } else if (alproto != ALPROTO_UNKNOWN && FlowChangeProto(f)) {\n        SCLogDebug(\"protocol change, old %s\", AppProtoToString(f->alproto_orig));\n        void *alstate_orig = f->alstate;\n        AppLayerParserState *alparser = f->alparser;\n        // we delay AppLayerParserStateCleanup because we may need previous parser state\n        AppLayerProtoDetectReset(f);\n        StreamTcpResetStreamFlagAppProtoDetectionCompleted(&ssn->client);\n        StreamTcpResetStreamFlagAppProtoDetectionCompleted(&ssn->server);\n        /* rerun protocol detection */\n        int rd = TCPProtoDetect(\n                tv, ra_ctx, app_tctx, p, f, ssn, stream, data, data_len, flags, app_update_dir);\n        if (f->alproto == ALPROTO_UNKNOWN) {\n            DEBUG_VALIDATE_BUG_ON(alstate_orig != f->alstate);\n            // not enough data, revert AppLayerProtoDetectReset to rerun detection\n            f->alparser = alparser;\n            f->alproto = f->alproto_orig;\n            f->alproto_tc = f->alproto_orig;\n            f->alproto_ts = f->alproto_orig;\n        } else {\n            FlowUnsetChangeProtoFlag(f);\n            AppLayerParserStateProtoCleanup(f->protomap, f->alproto_orig, alstate_orig, alparser);\n            if (alstate_orig == f->alstate) {\n                // we just freed it\n                f->alstate = NULL;\n            }\n        }\n        if (rd != 0) {\n            SCLogDebug(\"proto detect failure\");\n            goto failure;\n        }\n        SCLogDebug(\"protocol change, old %s, new %s\",\n                AppProtoToString(f->alproto_orig), AppProtoToString(f->alproto));\n\n        if (f->alproto_expect != ALPROTO_UNKNOWN && f->alproto != ALPROTO_UNKNOWN &&\n                f->alproto != f->alproto_expect) {\n            AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                                             APPLAYER_UNEXPECTED_PROTOCOL);\n\n            if (f->alproto_expect == ALPROTO_TLS && f->alproto != ALPROTO_TLS) {\n                AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                        APPLAYER_NO_TLS_AFTER_STARTTLS);\n\n            }\n        }\n    } else {\n        SCLogDebug(\"stream data (len %\" PRIu32 \" alproto \"\n                   \"%\"PRIu16\" (flow %p)\", data_len, f->alproto, f);\n#ifdef PRINT\n        if (data_len > 0) {\n            printf(\"=> Stream Data (app layer) -- start %s%s\\n\",\n                   flags & STREAM_TOCLIENT ? \"toclient\" : \"\",\n                   flags & STREAM_TOSERVER ? \"toserver\" : \"\");\n            PrintRawDataFp(stdout, data, data_len);\n            printf(\"=> Stream Data -- end\\n\");\n        }\n#endif\n        /* if we don't have a data object here we are not getting it\n         * a start msg should have gotten us one */\n        if (f->alproto != ALPROTO_UNKNOWN) {\n            PACKET_PROFILING_APP_START(app_tctx, f->alproto);\n            r = AppLayerParserParse(tv, app_tctx->alp_tctx, f, f->alproto,\n                                    flags, data, data_len);\n            PACKET_PROFILING_APP_END(app_tctx);\n            p->app_update_direction = (uint8_t)app_update_dir;\n            if (r != 1) {\n                StreamTcpUpdateAppLayerProgress(ssn, direction, data_len);\n                if (r < 0) {\n                    ExceptionPolicyApply(\n                            p, g_applayerparser_error_policy, PKT_DROP_REASON_APPLAYER_ERROR);\n                    AppLayerIncrErrorExcPolicyCounter(tv, f, g_applayerparser_error_policy);\n                    SCReturnInt(-1);\n                }\n            }\n        }\n    }\n\n    goto end;\n failure:\n    r = -1;\n end:\n    SCReturnInt(r);\n}\n\n/**\n *  \\brief Handle a app layer UDP message\n *\n *  If the protocol is yet unknown, the proto detection code is run first.\n *\n *  \\param dp_ctx Thread app layer detect context\n *  \\param f *locked* flow\n *  \\param p UDP packet\n *\n *  \\retval 0 ok\n *  \\retval -1 error\n */", "target": 0}
{"idx": 6, "func": "static void DisableAppLayer(ThreadVars *tv, Flow *f, Packet *p)\n{\n    SCLogDebug(\"disable app layer for flow %p alproto %u ts %u tc %u\",\n            f, f->alproto, f->alproto_ts, f->alproto_tc);\n    FlowCleanupAppLayer(f);\n    StreamTcpDisableAppLayer(f);\n    TcpSession *ssn = f->protoctx;\n    ssn->data_first_seen_dir = APP_LAYER_DATA_ALREADY_SENT_TO_APP_LAYER;\n    f->alproto = ALPROTO_FAILED;\n    AppLayerIncFlowCounter(tv, f);\n\n    if (f->alproto_tc != ALPROTO_FAILED) {\n        if (f->alproto_tc == ALPROTO_UNKNOWN) {\n            f->alproto_tc = ALPROTO_FAILED;\n        }\n        FlagPacketFlow(p, f, STREAM_TOCLIENT);\n    }\n    if (f->alproto_ts != ALPROTO_FAILED) {\n        if (f->alproto_ts == ALPROTO_UNKNOWN) {\n            f->alproto_ts = ALPROTO_FAILED;\n        }\n        FlagPacketFlow(p, f, STREAM_TOSERVER);\n    }\n    SCLogDebug(\"disabled app layer for flow %p alproto %u ts %u tc %u\",\n            f, f->alproto, f->alproto_ts, f->alproto_tc);\n}\n\n/* See if we're going to have to give up:\n *\n * If we're getting a lot of data in one direction and the\n * proto for this direction is unknown, proto detect will\n * hold up segments in the segment list in the stream.\n * They are held so that if we detect the protocol on the\n * opposing stream, we can still parse this side of the stream\n * as well. However, some sessions are very unbalanced. FTP\n * data channels, large PUT/POST request and many others, can\n * lead to cases where we would have to store many megabytes\n * worth of segments before we see the opposing stream. This\n * leads to risks of resource starvation.\n *\n * Here a cutoff point is enforced. If we've stored 100k in\n * one direction and we've seen no data in the other direction,\n * we give up.\n *\n * Giving up means we disable applayer an set an applayer event\n */", "target": 1}
{"idx": 7, "func": "static void TCPProtoDetectCheckBailConditions(ThreadVars *tv,\n        Flow *f, TcpSession *ssn, Packet *p)\n{\n    if (ssn->state < TCP_ESTABLISHED) {\n        SCLogDebug(\"skip as long as TCP is not ESTABLISHED (TCP fast open)\");\n        return;\n    }\n\n    const uint32_t size_ts = StreamDataAvailableForProtoDetect(&ssn->client);\n    const uint32_t size_tc = StreamDataAvailableForProtoDetect(&ssn->server);\n    SCLogDebug(\"size_ts %\" PRIu32 \", size_tc %\" PRIu32, size_ts, size_tc);\n\n    /* at least 100000 whatever the conditions\n     * and can be more if window is bigger and if configuration allows it */\n    const uint32_t size_tc_limit =\n            MAX(100000, MIN(ssn->client.window, stream_config.reassembly_depth));\n    const uint32_t size_ts_limit =\n            MAX(100000, MIN(ssn->server.window, stream_config.reassembly_depth));\n\n    if (ProtoDetectDone(f, ssn, STREAM_TOSERVER) &&\n        ProtoDetectDone(f, ssn, STREAM_TOCLIENT))\n    {\n        goto failure;\n\n        /* we bail out whatever the pp and pm states if\n         * we received too much data */\n    } else if (size_tc > 2 * size_tc_limit || size_ts > 2 * size_ts_limit) {\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events, APPLAYER_PROTO_DETECTION_SKIPPED);\n        goto failure;\n\n    } else if (FLOW_IS_PM_DONE(f, STREAM_TOSERVER) && FLOW_IS_PP_DONE(f, STREAM_TOSERVER) &&\n               size_ts > size_ts_limit && size_tc == 0) {\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                APPLAYER_PROTO_DETECTION_SKIPPED);\n        goto failure;\n\n    } else if (FLOW_IS_PM_DONE(f, STREAM_TOCLIENT) && FLOW_IS_PP_DONE(f, STREAM_TOCLIENT) &&\n               size_tc > size_tc_limit && size_ts == 0) {\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                APPLAYER_PROTO_DETECTION_SKIPPED);\n        goto failure;\n\n    /* little data in ts direction, pp done, pm not done (max\n     * depth not reached), ts direction done, lots of data in\n     * tc direction. */\n    } else if (size_tc > size_tc_limit && FLOW_IS_PP_DONE(f, STREAM_TOSERVER) &&\n               !(FLOW_IS_PM_DONE(f, STREAM_TOSERVER)) && FLOW_IS_PM_DONE(f, STREAM_TOCLIENT) &&\n               FLOW_IS_PP_DONE(f, STREAM_TOCLIENT)) {\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                APPLAYER_PROTO_DETECTION_SKIPPED);\n        goto failure;\n\n    /* little data in tc direction, pp done, pm not done (max\n     * depth not reached), tc direction done, lots of data in\n     * ts direction. */\n    } else if (size_ts > size_ts_limit && FLOW_IS_PP_DONE(f, STREAM_TOCLIENT) &&\n               !(FLOW_IS_PM_DONE(f, STREAM_TOCLIENT)) && FLOW_IS_PM_DONE(f, STREAM_TOSERVER) &&\n               FLOW_IS_PP_DONE(f, STREAM_TOSERVER)) {\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                APPLAYER_PROTO_DETECTION_SKIPPED);\n        goto failure;\n    }\n    return;\n\nfailure:\n    DisableAppLayer(tv, f, p);\n}", "target": 0}
{"idx": 8, "func": "const char *PacketDropReasonToString(enum PacketDropReason r)\n{\n    switch (r) {\n        case PKT_DROP_REASON_DECODE_ERROR:\n            return \"decode error\";\n        case PKT_DROP_REASON_DEFRAG_ERROR:\n            return \"defrag error\";\n        case PKT_DROP_REASON_DEFRAG_MEMCAP:\n            return \"defrag memcap\";\n        case PKT_DROP_REASON_FLOW_MEMCAP:\n            return \"flow memcap\";\n        case PKT_DROP_REASON_FLOW_DROP:\n            return \"flow drop\";\n        case PKT_DROP_REASON_STREAM_ERROR:\n            return \"stream error\";\n        case PKT_DROP_REASON_STREAM_MEMCAP:\n            return \"stream memcap\";\n        case PKT_DROP_REASON_STREAM_MIDSTREAM:\n            return \"stream midstream\";\n        case PKT_DROP_REASON_STREAM_REASSEMBLY:\n            return \"stream reassembly\";\n        case PKT_DROP_REASON_APPLAYER_ERROR:\n            return \"applayer error\";\n        case PKT_DROP_REASON_APPLAYER_MEMCAP:\n            return \"applayer memcap\";\n        case PKT_DROP_REASON_RULES:\n            return \"rules\";\n        case PKT_DROP_REASON_RULES_THRESHOLD:\n            return \"threshold detection_filter\";\n        case PKT_DROP_REASON_NFQ_ERROR:\n            return \"nfq error\";\n        case PKT_DROP_REASON_INNER_PACKET:\n            return \"tunnel packet drop\";\n        case PKT_DROP_REASON_NOT_SET:\n        case PKT_DROP_REASON_MAX:\n            return NULL;\n    }\n    return NULL;\n}", "target": 1}
{"idx": 9, "func": "const char *PacketDropReasonToString(enum PacketDropReason r)\n{\n    switch (r) {\n        case PKT_DROP_REASON_DECODE_ERROR:\n            return \"decode error\";\n        case PKT_DROP_REASON_DEFRAG_ERROR:\n            return \"defrag error\";\n        case PKT_DROP_REASON_DEFRAG_MEMCAP:\n            return \"defrag memcap\";\n        case PKT_DROP_REASON_FLOW_MEMCAP:\n            return \"flow memcap\";\n        case PKT_DROP_REASON_FLOW_DROP:\n            return \"flow drop\";\n        case PKT_DROP_REASON_STREAM_ERROR:\n            return \"stream error\";\n        case PKT_DROP_REASON_STREAM_MEMCAP:\n            return \"stream memcap\";\n        case PKT_DROP_REASON_STREAM_MIDSTREAM:\n            return \"stream midstream\";\n        case PKT_DROP_REASON_STREAM_URG:\n            return \"stream urgent\";\n        case PKT_DROP_REASON_STREAM_REASSEMBLY:\n            return \"stream reassembly\";\n        case PKT_DROP_REASON_APPLAYER_ERROR:\n            return \"applayer error\";\n        case PKT_DROP_REASON_APPLAYER_MEMCAP:\n            return \"applayer memcap\";\n        case PKT_DROP_REASON_RULES:\n            return \"rules\";\n        case PKT_DROP_REASON_RULES_THRESHOLD:\n            return \"threshold detection_filter\";\n        case PKT_DROP_REASON_NFQ_ERROR:\n            return \"nfq error\";\n        case PKT_DROP_REASON_INNER_PACKET:\n            return \"tunnel packet drop\";\n        case PKT_DROP_REASON_NOT_SET:\n        case PKT_DROP_REASON_MAX:\n            return NULL;\n    }\n    return NULL;\n}", "target": 0}
{"idx": 10, "func": "int StreamTcpReassembleInsertSegment(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx,\n        TcpStream *stream, TcpSegment *seg, Packet *p,\n        uint8_t *pkt_data, uint16_t pkt_datalen)\n{\n    SCEnter();\n\n    TcpSegment *dup_seg = NULL;\n\n    /* insert segment into list. Note: doesn't handle the data */\n    int r = DoInsertSegment (stream, seg, &dup_seg, p);\n\n    if (IsTcpSessionDumpingEnabled()) {\n        StreamTcpSegmentAddPacketData(seg, p, tv, ra_ctx);\n    }\n\n    if (likely(r == 0)) {\n        /* no overlap, straight data insert */\n        int res = InsertSegmentDataCustom(stream, seg, pkt_data, pkt_datalen);\n        if (res != SC_OK) {\n            StatsIncr(tv, ra_ctx->counter_tcp_reass_data_normal_fail);\n            StreamTcpRemoveSegmentFromStream(stream, seg);\n            StreamTcpSegmentReturntoPool(seg);\n            if (res == SC_ENOMEM) {\n                StatsIncr(tv, ra_ctx->counter_tcp_segment_memcap);\n                SCReturnInt(-SC_ENOMEM);\n            }\n            SCReturnInt(-1);\n        }\n\n    } else if (r == 1 || r == 2) {\n        SCLogDebug(\"overlap (%s%s)\", r == 1 ? \"normal\" : \"\", r == 2 ? \"duplicate\" : \"\");\n\n        if (r == 2) {\n            SCLogDebug(\"dup_seg %p\", dup_seg);\n        }\n\n        /* XXX should we exclude 'retransmissions' here? */\n        StatsIncr(tv, ra_ctx->counter_tcp_reass_overlap);\n\n        /* now let's consider the data in the overlap case */\n        int res = DoHandleData(tv, ra_ctx, stream, seg, dup_seg, p);\n        if (res < 0) {\n            StatsIncr(tv, ra_ctx->counter_tcp_reass_data_overlap_fail);\n\n            if (r == 1) // r == 2 mean seg wasn't added to stream\n                StreamTcpRemoveSegmentFromStream(stream, seg);\n\n            StreamTcpSegmentReturntoPool(seg);\n            SCReturnInt(-1);\n        }\n        if (r == 2) {\n            SCLogDebug(\"duplicate segment %u/%u, discard it\",\n                    seg->seq, seg->payload_len);\n\n            StreamTcpSegmentReturntoPool(seg);\n#ifdef DEBUG\n            if (SCLogDebugEnabled()) {\n                TcpSegment *s = NULL, *safe = NULL;\n                RB_FOREACH_SAFE(s, TCPSEG, &stream->seg_tree, safe)\n                {\n                    SCLogDebug(\"tree: seg %p, SEQ %\"PRIu32\", LEN %\"PRIu16\", SUM %\"PRIu32\"%s%s%s\",\n                            s, s->seq, TCP_SEG_LEN(s),\n                            (uint32_t)(s->seq + TCP_SEG_LEN(s)),\n                            s->seq == seg->seq ? \" DUPLICATE\" : \"\",\n                            TCPSEG_RB_PREV(s) == NULL ? \" HEAD\" : \"\",\n                            TCPSEG_RB_NEXT(s) == NULL ? \" TAIL\" : \"\");\n                }\n            }\n#endif\n        }\n    } else {\n        // EINVAL\n        StreamTcpSegmentReturntoPool(seg);\n    }\n\n    SCReturnInt(0);\n}\n\n\n/*\n * Pruning & removal\n */", "target": 1}
{"idx": 11, "func": "int StreamTcpReassembleInsertSegment(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx,\n        TcpStream *stream, TcpSegment *seg, Packet *p, uint8_t *pkt_data, uint16_t pkt_datalen)\n{\n    SCEnter();\n\n    TcpSegment *dup_seg = NULL;\n\n    /* insert segment into list. Note: doesn't handle the data */\n    int r = DoInsertSegment (stream, seg, &dup_seg, p);\n\n    if (IsTcpSessionDumpingEnabled()) {\n        StreamTcpSegmentAddPacketData(seg, p, tv, ra_ctx);\n    }\n\n    if (likely(r == 0)) {\n        /* no overlap, straight data insert */\n        int res = InsertSegmentDataCustom(stream, seg, pkt_data, pkt_datalen);\n        if (res != SC_OK) {\n            StatsIncr(tv, ra_ctx->counter_tcp_reass_data_normal_fail);\n            StreamTcpRemoveSegmentFromStream(stream, seg);\n            StreamTcpSegmentReturntoPool(seg);\n            if (res == SC_ENOMEM) {\n                StatsIncr(tv, ra_ctx->counter_tcp_segment_memcap);\n                SCReturnInt(-SC_ENOMEM);\n            }\n            SCReturnInt(-1);\n        }\n\n    } else if (r == 1 || r == 2) {\n        SCLogDebug(\"overlap (%s%s)\", r == 1 ? \"normal\" : \"\", r == 2 ? \"duplicate\" : \"\");\n\n        if (r == 2) {\n            SCLogDebug(\"dup_seg %p\", dup_seg);\n        }\n\n        /* XXX should we exclude 'retransmissions' here? */\n        StatsIncr(tv, ra_ctx->counter_tcp_reass_overlap);\n\n        /* now let's consider the data in the overlap case */\n        int res = DoHandleData(tv, ra_ctx, stream, seg, dup_seg, p);\n        if (res < 0) {\n            StatsIncr(tv, ra_ctx->counter_tcp_reass_data_overlap_fail);\n\n            if (r == 1) // r == 2 mean seg wasn't added to stream\n                StreamTcpRemoveSegmentFromStream(stream, seg);\n\n            StreamTcpSegmentReturntoPool(seg);\n            SCReturnInt(-1);\n        }\n        if (r == 2) {\n            SCLogDebug(\"duplicate segment %u/%u, discard it\",\n                    seg->seq, seg->payload_len);\n\n            StreamTcpSegmentReturntoPool(seg);\n#ifdef DEBUG\n            if (SCLogDebugEnabled()) {\n                TcpSegment *s = NULL, *safe = NULL;\n                RB_FOREACH_SAFE(s, TCPSEG, &stream->seg_tree, safe)\n                {\n                    SCLogDebug(\"tree: seg %p, SEQ %\"PRIu32\", LEN %\"PRIu16\", SUM %\"PRIu32\"%s%s%s\",\n                            s, s->seq, TCP_SEG_LEN(s),\n                            (uint32_t)(s->seq + TCP_SEG_LEN(s)),\n                            s->seq == seg->seq ? \" DUPLICATE\" : \"\",\n                            TCPSEG_RB_PREV(s) == NULL ? \" HEAD\" : \"\",\n                            TCPSEG_RB_NEXT(s) == NULL ? \" TAIL\" : \"\");\n                }\n            }\n#endif\n        }\n    } else {\n        // EINVAL\n        StreamTcpSegmentReturntoPool(seg);\n    }\n\n    SCReturnInt(0);\n}\n\n\n/*\n * Pruning & removal\n */", "target": 0}
{"idx": 12, "func": "int StreamTcpReassembleHandleSegmentHandleData(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx,\n                                TcpSession *ssn, TcpStream *stream, Packet *p)\n{\n    SCEnter();\n\n    if (ssn->data_first_seen_dir == 0) {\n        if (PKT_IS_TOSERVER(p)) {\n            ssn->data_first_seen_dir = STREAM_TOSERVER;\n        } else {\n            ssn->data_first_seen_dir = STREAM_TOCLIENT;\n        }\n    }\n\n    /* If the OS policy is not set then set the OS policy for this stream */\n    if (stream->os_policy == 0) {\n        StreamTcpSetOSPolicy(stream, p);\n    }\n\n    if ((ssn->flags & STREAMTCP_FLAG_APP_LAYER_DISABLED) &&\n        (stream->flags & STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED)) {\n        SCLogDebug(\"ssn %p: both app and raw reassembly disabled, not reassembling\", ssn);\n        SCReturnInt(0);\n    }\n\n    const TCPHdr *tcph = PacketGetTCP(p);\n\n    /* If we have reached the defined depth for either of the stream, then stop\n       reassembling the TCP session */\n    uint32_t size =\n            StreamTcpReassembleCheckDepth(ssn, stream, TCP_GET_RAW_SEQ(tcph), p->payload_len);\n    SCLogDebug(\"ssn %p: check depth returned %\"PRIu32, ssn, size);\n\n    if (stream->flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) {\n        StreamTcpSetEvent(p, STREAM_REASSEMBLY_DEPTH_REACHED);\n        /* increment stream depth counter */\n        StatsIncr(tv, ra_ctx->counter_tcp_stream_depth);\n        p->app_update_direction = UPDATE_DIR_PACKET;\n    }\n    if (size == 0) {\n        SCLogDebug(\"ssn %p: depth reached, not reassembling\", ssn);\n        SCReturnInt(0);\n    }\n\n    DEBUG_VALIDATE_BUG_ON(size > p->payload_len);\n    if (size > p->payload_len)\n        size = p->payload_len;\n\n    TcpSegment *seg = StreamTcpGetSegment(tv, ra_ctx);\n    if (seg == NULL) {\n        SCLogDebug(\"segment_pool is empty\");\n        StreamTcpSetEvent(p, STREAM_REASSEMBLY_NO_SEGMENT);\n        ssn->flags |= STREAMTCP_FLAG_LOSSY_BE_LIBERAL;\n        SCReturnInt(-1);\n    }\n\n    DEBUG_VALIDATE_BUG_ON(size > UINT16_MAX);\n    TCP_SEG_LEN(seg) = (uint16_t)size;\n    seg->seq = TCP_GET_RAW_SEQ(tcph);\n\n    /* HACK: for TFO SYN packets the seq for data starts at + 1 */\n    if (TCP_HAS_TFO(p) && p->payload_len && (tcph->th_flags & TH_SYN))\n        seg->seq += 1;\n\n    /* proto detection skipped, but now we do get data. Set event. */\n    if (RB_EMPTY(&stream->seg_tree) &&\n        stream->flags & STREAMTCP_STREAM_FLAG_APPPROTO_DETECTION_SKIPPED) {\n\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                APPLAYER_PROTO_DETECTION_SKIPPED);\n    }\n\n    int r = StreamTcpReassembleInsertSegment(\n            tv, ra_ctx, stream, seg, p, p->payload, p->payload_len);\n    if (r < 0) {\n        if (r == -SC_ENOMEM) {\n            ssn->flags |= STREAMTCP_FLAG_LOSSY_BE_LIBERAL;\n        }\n        SCLogDebug(\"StreamTcpReassembleInsertSegment failed\");\n        SCReturnInt(-1);\n    }\n    SCReturnInt(0);\n}", "target": 1}
{"idx": 13, "func": "uint32_t StreamDataAvailableForProtoDetect(TcpStream *stream)\n{\n    if (RB_EMPTY(&stream->sb.sbb_tree)) {\n        if (stream->sb.region.stream_offset != 0)\n            return 0;\n\n        return stream->sb.region.buf_offset;\n    } else {\n        DEBUG_VALIDATE_BUG_ON(stream->sb.head == NULL);\n        DEBUG_VALIDATE_BUG_ON(stream->sb.sbb_size == 0);\n        return stream->sb.sbb_size;\n    }\n}\n\n/**\n *  \\brief Insert a packets TCP data into the stream reassembly engine.\n *\n *  \\retval 0 good segment, as far as we checked.\n *  \\retval -1 insert failure due to memcap\n *\n *  If the retval is 0 the segment is inserted correctly, or overlap is handled,\n *  or it wasn't added because of reassembly depth.\n *\n */", "target": 0}
{"idx": 14, "func": "static int StreamTcpReassembleRawCheckLimit(const TcpSession *ssn,\n        const TcpStream *stream, const Packet *p)\n{\n    SCEnter();\n\n    /* if any of these flags is set we always inspect immediately */\n#define STREAMTCP_STREAM_FLAG_FLUSH_FLAGS       \\\n        (   STREAMTCP_STREAM_FLAG_DEPTH_REACHED \\\n        |   STREAMTCP_STREAM_FLAG_TRIGGER_RAW   \\\n        |   STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED)\n\n    if (stream->flags & STREAMTCP_STREAM_FLAG_FLUSH_FLAGS) {\n        if (stream->flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) {\n            SCLogDebug(\"reassembling now as STREAMTCP_STREAM_FLAG_DEPTH_REACHED \"\n                    \"is set, so not expecting any new data segments\");\n        }\n        if (stream->flags & STREAMTCP_STREAM_FLAG_TRIGGER_RAW) {\n            SCLogDebug(\"reassembling now as STREAMTCP_STREAM_FLAG_TRIGGER_RAW is set\");\n        }\n        if (stream->flags & STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED) {\n            SCLogDebug(\"reassembling now as STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED is set, \"\n                    \"so no new segments will be considered\");\n        }\n        SCReturnInt(1);\n    }\n#undef STREAMTCP_STREAM_FLAG_FLUSH_FLAGS\n\n    /* some states mean we reassemble no matter how much data we have */\n    if (ssn->state > TCP_TIME_WAIT)\n        SCReturnInt(1);\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        SCReturnInt(1);\n\n    const uint64_t last_ack_abs = GetAbsLastAck(stream);\n    int64_t diff = last_ack_abs - STREAM_RAW_PROGRESS(stream);\n    int64_t chunk_size = PKT_IS_TOSERVER(p) ? (int64_t)stream_config.reassembly_toserver_chunk_size\n                                            : (int64_t)stream_config.reassembly_toclient_chunk_size;\n\n    /* check if we have enough data to do raw reassembly */\n    if (chunk_size <= diff) {\n        SCReturnInt(1);\n    } else {\n        SCLogDebug(\"%s min chunk len not yet reached: \"\n                   \"last_ack %\" PRIu32 \", ra_raw_base_seq %\" PRIu32 \", %\" PRIu32 \" < \"\n                   \"%\" PRIi64,\n                PKT_IS_TOSERVER(p) ? \"toserver\" : \"toclient\", stream->last_ack, stream->base_seq,\n                (stream->last_ack - stream->base_seq), chunk_size);\n        SCReturnInt(0);\n    }\n\n    SCReturnInt(0);\n}\n\n/**\n *  \\brief see what if any work the TCP session still needs\n */", "target": 1}
{"idx": 15, "func": "int StreamTcpReassembleHandleSegmentHandleData(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx,\n                                TcpSession *ssn, TcpStream *stream, Packet *p)\n{\n    SCEnter();\n\n    if (ssn->data_first_seen_dir == 0) {\n        if (PKT_IS_TOSERVER(p)) {\n            ssn->data_first_seen_dir = STREAM_TOSERVER;\n        } else {\n            ssn->data_first_seen_dir = STREAM_TOCLIENT;\n        }\n    }\n\n    /* If the OS policy is not set then set the OS policy for this stream */\n    if (stream->os_policy == 0) {\n        StreamTcpSetOSPolicy(stream, p);\n    }\n\n    if ((ssn->flags & STREAMTCP_FLAG_APP_LAYER_DISABLED) &&\n        (stream->flags & STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED)) {\n        SCLogDebug(\"ssn %p: both app and raw reassembly disabled, not reassembling\", ssn);\n        SCReturnInt(0);\n    }\n\n    uint16_t *urg_offset;\n    if (PKT_IS_TOSERVER(p)) {\n        urg_offset = &ssn->urg_offset_ts;\n    } else {\n        urg_offset = &ssn->urg_offset_tc;\n    }\n\n    const TCPHdr *tcph = PacketGetTCP(p);\n    /* segment sequence number, offset by previously accepted\n     * URG OOB data. */\n    uint32_t seg_seq = TCP_GET_RAW_SEQ(tcph) - (*urg_offset);\n    uint8_t urg_data = 0;\n\n    /* if stream_config.urgent_policy == TCP_STREAM_URGENT_DROP, we won't get here */\n    if (tcph->th_flags & TH_URG) {\n        const uint16_t urg_ptr = SCNtohs(tcph->th_urp);\n        if (urg_ptr > 0 && urg_ptr <= p->payload_len &&\n                (stream_config.urgent_policy == TCP_STREAM_URGENT_OOB ||\n                        stream_config.urgent_policy == TCP_STREAM_URGENT_GAP)) {\n            /* track up to 64k out of band URG bytes. Fall back to inline\n             * when that budget is exceeded. */\n            if ((*urg_offset) < UINT16_MAX) {\n                if (stream_config.urgent_policy == TCP_STREAM_URGENT_OOB)\n                    (*urg_offset)++;\n\n                if ((*urg_offset) == UINT16_MAX) {\n                    StreamTcpSetEvent(p, STREAM_REASSEMBLY_URGENT_OOB_LIMIT_REACHED);\n                }\n            } else {\n                /* OOB limit DROP is handled here */\n                if (stream_config.urgent_oob_limit_policy == TCP_STREAM_URGENT_DROP) {\n                    PacketDrop(p, ACTION_DROP, PKT_DROP_REASON_STREAM_URG);\n                    SCReturnInt(0);\n                }\n            }\n            urg_data = 1; /* only treat last 1 byte as out of band. */\n            if (stream_config.urgent_policy == TCP_STREAM_URGENT_OOB) {\n                StatsIncr(tv, ra_ctx->counter_tcp_urgent_oob);\n            }\n\n            /* depending on hitting the OOB limit, update urg_data or not */\n            if (stream_config.urgent_policy == TCP_STREAM_URGENT_OOB &&\n                    (*urg_offset) == UINT16_MAX &&\n                    stream_config.urgent_oob_limit_policy == TCP_STREAM_URGENT_INLINE) {\n                urg_data = 0;\n            } else {\n                if (urg_ptr == 1 && p->payload_len == 1) {\n                    SCLogDebug(\"no non-URG data\");\n                    SCReturnInt(0);\n                }\n            }\n        }\n    }\n\n    const uint16_t payload_len = p->payload_len - urg_data;\n\n    /* If we have reached the defined depth for either of the stream, then stop\n       reassembling the TCP session */\n    uint32_t size = StreamTcpReassembleCheckDepth(ssn, stream, seg_seq, payload_len);\n    SCLogDebug(\"ssn %p: check depth returned %\"PRIu32, ssn, size);\n\n    if (stream->flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) {\n        StreamTcpSetEvent(p, STREAM_REASSEMBLY_DEPTH_REACHED);\n        /* increment stream depth counter */\n        StatsIncr(tv, ra_ctx->counter_tcp_stream_depth);\n        p->app_update_direction = UPDATE_DIR_PACKET;\n    }\n    if (size == 0) {\n        SCLogDebug(\"ssn %p: depth reached, not reassembling\", ssn);\n        SCReturnInt(0);\n    }\n\n    DEBUG_VALIDATE_BUG_ON(size > payload_len);\n    if (size > payload_len)\n        size = payload_len;\n\n    TcpSegment *seg = StreamTcpGetSegment(tv, ra_ctx);\n    if (seg == NULL) {\n        SCLogDebug(\"segment_pool is empty\");\n        StreamTcpSetEvent(p, STREAM_REASSEMBLY_NO_SEGMENT);\n        ssn->flags |= STREAMTCP_FLAG_LOSSY_BE_LIBERAL;\n        SCReturnInt(-1);\n    }\n\n    DEBUG_VALIDATE_BUG_ON(size > UINT16_MAX);\n    TCP_SEG_LEN(seg) = (uint16_t)size;\n    /* set SEQUENCE number, adjusted to any URG pointer offset */\n    seg->seq = seg_seq;\n\n    /* HACK: for TFO SYN packets the seq for data starts at + 1 */\n    if (TCP_HAS_TFO(p) && p->payload_len && (tcph->th_flags & TH_SYN))\n        seg->seq += 1;\n\n    /* proto detection skipped, but now we do get data. Set event. */\n    if (RB_EMPTY(&stream->seg_tree) &&\n        stream->flags & STREAMTCP_STREAM_FLAG_APPPROTO_DETECTION_SKIPPED) {\n\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                APPLAYER_PROTO_DETECTION_SKIPPED);\n    }\n\n    int r = StreamTcpReassembleInsertSegment(tv, ra_ctx, stream, seg, p, p->payload, payload_len);\n    if (r < 0) {\n        if (r == -SC_ENOMEM) {\n            ssn->flags |= STREAMTCP_FLAG_LOSSY_BE_LIBERAL;\n        }\n        SCLogDebug(\"StreamTcpReassembleInsertSegment failed\");\n        SCReturnInt(-1);\n    }\n    SCReturnInt(0);\n}", "target": 0}
{"idx": 16, "func": "void StreamTcpInitConfig(bool quiet)\n{\n    intmax_t value = 0;\n    uint16_t rdrange = 10;\n\n    SCLogDebug(\"Initializing Stream\");\n\n    memset(&stream_config,  0, sizeof(stream_config));\n\n    SC_ATOMIC_INIT(stream_config.memcap);\n    SC_ATOMIC_INIT(stream_config.reassembly_memcap);\n\n    if ((ConfGetInt(\"stream.max-sessions\", &value)) == 1) {\n        SCLogWarning(\"max-sessions is obsolete. \"\n                     \"Number of concurrent sessions is now only limited by Flow and \"\n                     \"TCP stream engine memcaps.\");\n    }\n\n    if ((ConfGetInt(\"stream.prealloc-sessions\", &value)) == 1) {\n        stream_config.prealloc_sessions = (uint32_t)value;\n    } else {\n        if (RunmodeIsUnittests()) {\n            stream_config.prealloc_sessions = 128;\n        } else {\n            stream_config.prealloc_sessions = STREAMTCP_DEFAULT_PREALLOC;\n            if (ConfGetNode(\"stream.prealloc-sessions\") != NULL) {\n                WarnInvalidConfEntry(\"stream.prealloc_sessions\",\n                                     \"%\"PRIu32,\n                                     stream_config.prealloc_sessions);\n            }\n        }\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"prealloc-sessions\\\": %\"PRIu32\" (per thread)\",\n                stream_config.prealloc_sessions);\n    }\n\n    const char *temp_stream_memcap_str;\n    if (ConfGet(\"stream.memcap\", &temp_stream_memcap_str) == 1) {\n        uint64_t stream_memcap_copy;\n        if (ParseSizeStringU64(temp_stream_memcap_str, &stream_memcap_copy) < 0) {\n            SCLogError(\"Error parsing stream.memcap \"\n                       \"from conf file - %s.  Killing engine\",\n                    temp_stream_memcap_str);\n            exit(EXIT_FAILURE);\n        } else {\n            SC_ATOMIC_SET(stream_config.memcap, stream_memcap_copy);\n        }\n    } else {\n        SC_ATOMIC_SET(stream_config.memcap, STREAMTCP_DEFAULT_MEMCAP);\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"memcap\\\": %\"PRIu64, SC_ATOMIC_GET(stream_config.memcap));\n    }\n\n    int imidstream;\n    (void)ConfGetBool(\"stream.midstream\", &imidstream);\n    stream_config.midstream = imidstream != 0;\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"midstream\\\" session pickups: %s\", stream_config.midstream ? \"enabled\" : \"disabled\");\n    }\n\n    int async_oneside;\n    (void)ConfGetBool(\"stream.async-oneside\", &async_oneside);\n    stream_config.async_oneside = async_oneside != 0;\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"async-oneside\\\": %s\", stream_config.async_oneside ? \"enabled\" : \"disabled\");\n    }\n\n    int csum = 0;\n\n    if ((ConfGetBool(\"stream.checksum-validation\", &csum)) == 1) {\n        if (csum == 1) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION;\n        }\n    /* Default is that we validate the checksum of all the packets */\n    } else {\n        stream_config.flags |= STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION;\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"checksum-validation\\\": %s\",\n                stream_config.flags & STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION ?\n                \"enabled\" : \"disabled\");\n    }\n\n    const char *temp_stream_inline_str;\n    if (ConfGet(\"stream.inline\", &temp_stream_inline_str) == 1) {\n        int inl = 0;\n\n        /* checking for \"auto\" and falling back to boolean to provide\n         * backward compatibility */\n        if (strcmp(temp_stream_inline_str, \"auto\") == 0) {\n            if (EngineModeIsIPS()) {\n                stream_config.flags |= STREAMTCP_INIT_FLAG_INLINE;\n            }\n        } else if (ConfGetBool(\"stream.inline\", &inl) == 1) {\n            if (inl) {\n                stream_config.flags |= STREAMTCP_INIT_FLAG_INLINE;\n            }\n        }\n    } else {\n        /* default to 'auto' */\n        if (EngineModeIsIPS()) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_INLINE;\n        }\n    }\n    stream_config.ssn_memcap_policy = ExceptionPolicyParse(\"stream.memcap-policy\", true);\n    stream_config.reassembly_memcap_policy =\n            ExceptionPolicyParse(\"stream.reassembly.memcap-policy\", true);\n    stream_config.midstream_policy = ExceptionPolicyMidstreamParse(stream_config.midstream);\n\n    if (!quiet) {\n        SCLogConfig(\"stream.\\\"inline\\\": %s\",\n                    stream_config.flags & STREAMTCP_INIT_FLAG_INLINE\n                    ? \"enabled\" : \"disabled\");\n    }\n\n    int bypass = 0;\n    if ((ConfGetBool(\"stream.bypass\", &bypass)) == 1) {\n        if (bypass == 1) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_BYPASS;\n        }\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"bypass\\\": %s\",\n                    (stream_config.flags & STREAMTCP_INIT_FLAG_BYPASS)\n                    ? \"enabled\" : \"disabled\");\n    }\n\n    int drop_invalid = 0;\n    if ((ConfGetBool(\"stream.drop-invalid\", &drop_invalid)) == 1) {\n        if (drop_invalid == 1) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_DROP_INVALID;\n        }\n    } else {\n        stream_config.flags |= STREAMTCP_INIT_FLAG_DROP_INVALID;\n    }\n\n    if ((ConfGetInt(\"stream.max-syn-queued\", &value)) == 1) {\n        if (value >= 0 && value <= 255) {\n            stream_config.max_syn_queued = (uint8_t)value;\n        } else {\n            stream_config.max_syn_queued = (uint8_t)STREAMTCP_DEFAULT_MAX_SYN_QUEUED;\n        }\n    } else {\n        stream_config.max_syn_queued = (uint8_t)STREAMTCP_DEFAULT_MAX_SYN_QUEUED;\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"max-syn-queued\\\": %\" PRIu8, stream_config.max_syn_queued);\n    }\n\n    if ((ConfGetInt(\"stream.max-synack-queued\", &value)) == 1) {\n        if (value >= 0 && value <= 255) {\n            stream_config.max_synack_queued = (uint8_t)value;\n        } else {\n            stream_config.max_synack_queued = (uint8_t)STREAMTCP_DEFAULT_MAX_SYNACK_QUEUED;\n        }\n    } else {\n        stream_config.max_synack_queued = (uint8_t)STREAMTCP_DEFAULT_MAX_SYNACK_QUEUED;\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"max-synack-queued\\\": %\"PRIu8, stream_config.max_synack_queued);\n    }\n\n    const char *temp_stream_reassembly_memcap_str;\n    if (ConfGet(\"stream.reassembly.memcap\", &temp_stream_reassembly_memcap_str) == 1) {\n        uint64_t stream_reassembly_memcap_copy;\n        if (ParseSizeStringU64(temp_stream_reassembly_memcap_str,\n                               &stream_reassembly_memcap_copy) < 0) {\n            SCLogError(\"Error parsing \"\n                       \"stream.reassembly.memcap \"\n                       \"from conf file - %s.  Killing engine\",\n                    temp_stream_reassembly_memcap_str);\n            exit(EXIT_FAILURE);\n        } else {\n            SC_ATOMIC_SET(stream_config.reassembly_memcap, stream_reassembly_memcap_copy);\n        }\n    } else {\n        SC_ATOMIC_SET(stream_config.reassembly_memcap , STREAMTCP_DEFAULT_REASSEMBLY_MEMCAP);\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly \\\"memcap\\\": %\"PRIu64\"\",\n                    SC_ATOMIC_GET(stream_config.reassembly_memcap));\n    }\n\n    const char *temp_stream_reassembly_depth_str;\n    if (ConfGet(\"stream.reassembly.depth\", &temp_stream_reassembly_depth_str) == 1) {\n        if (ParseSizeStringU32(temp_stream_reassembly_depth_str,\n                               &stream_config.reassembly_depth) < 0) {\n            SCLogError(\"Error parsing \"\n                       \"stream.reassembly.depth \"\n                       \"from conf file - %s.  Killing engine\",\n                    temp_stream_reassembly_depth_str);\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        stream_config.reassembly_depth = 0;\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly \\\"depth\\\": %\"PRIu32\"\", stream_config.reassembly_depth);\n    }\n\n    int randomize = 0;\n    if ((ConfGetBool(\"stream.reassembly.randomize-chunk-size\", &randomize)) == 0) {\n        /* randomize by default if value not set\n         * In ut mode we disable, to get predictable test results */\n        if (!(RunmodeIsUnittests()))\n            randomize = 1;\n    }\n\n    if (randomize) {\n        const char *temp_rdrange;\n        if (ConfGet(\"stream.reassembly.randomize-chunk-range\", &temp_rdrange) == 1) {\n            if (ParseSizeStringU16(temp_rdrange, &rdrange) < 0) {\n                SCLogError(\"Error parsing \"\n                           \"stream.reassembly.randomize-chunk-range \"\n                           \"from conf file - %s.  Killing engine\",\n                        temp_rdrange);\n                exit(EXIT_FAILURE);\n            } else if (rdrange >= 100) {\n                FatalError(\"stream.reassembly.randomize-chunk-range \"\n                           \"must be lower than 100\");\n            }\n        }\n    }\n\n    const char *temp_stream_reassembly_toserver_chunk_size_str;\n    if (ConfGet(\"stream.reassembly.toserver-chunk-size\",\n                &temp_stream_reassembly_toserver_chunk_size_str) == 1) {\n        if (ParseSizeStringU16(temp_stream_reassembly_toserver_chunk_size_str,\n                               &stream_config.reassembly_toserver_chunk_size) < 0) {\n            SCLogError(\"Error parsing \"\n                       \"stream.reassembly.toserver-chunk-size \"\n                       \"from conf file - %s.  Killing engine\",\n                    temp_stream_reassembly_toserver_chunk_size_str);\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        stream_config.reassembly_toserver_chunk_size =\n            STREAMTCP_DEFAULT_TOSERVER_CHUNK_SIZE;\n    }\n\n    if (randomize) {\n        long int r = RandomGetWrap();\n        stream_config.reassembly_toserver_chunk_size +=\n                (int)(stream_config.reassembly_toserver_chunk_size * ((double)r / RAND_MAX - 0.5) *\n                        rdrange / 100);\n    }\n    const char *temp_stream_reassembly_toclient_chunk_size_str;\n    if (ConfGet(\"stream.reassembly.toclient-chunk-size\",\n                &temp_stream_reassembly_toclient_chunk_size_str) == 1) {\n        if (ParseSizeStringU16(temp_stream_reassembly_toclient_chunk_size_str,\n                               &stream_config.reassembly_toclient_chunk_size) < 0) {\n            SCLogError(\"Error parsing \"\n                       \"stream.reassembly.toclient-chunk-size \"\n                       \"from conf file - %s.  Killing engine\",\n                    temp_stream_reassembly_toclient_chunk_size_str);\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        stream_config.reassembly_toclient_chunk_size =\n            STREAMTCP_DEFAULT_TOCLIENT_CHUNK_SIZE;\n    }\n\n    if (randomize) {\n        long int r = RandomGetWrap();\n        stream_config.reassembly_toclient_chunk_size +=\n                (int)(stream_config.reassembly_toclient_chunk_size * ((double)r / RAND_MAX - 0.5) *\n                        rdrange / 100);\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly \\\"toserver-chunk-size\\\": %\"PRIu16,\n            stream_config.reassembly_toserver_chunk_size);\n        SCLogConfig(\"stream.reassembly \\\"toclient-chunk-size\\\": %\"PRIu16,\n            stream_config.reassembly_toclient_chunk_size);\n    }\n\n    int enable_raw = 1;\n    if (ConfGetBool(\"stream.reassembly.raw\", &enable_raw) == 1) {\n        if (!enable_raw) {\n            stream_config.stream_init_flags = STREAMTCP_STREAM_FLAG_DISABLE_RAW;\n        }\n    } else {\n        enable_raw = 1;\n    }\n    if (!quiet)\n        SCLogConfig(\"stream.reassembly.raw: %s\", enable_raw ? \"enabled\" : \"disabled\");\n\n    /* default to true. Not many ppl (correctly) set up host-os policies, so be permissive. */\n    stream_config.liberal_timestamps = true;\n    int liberal_timestamps = 0;\n    if (ConfGetBool(\"stream.liberal-timestamps\", &liberal_timestamps) == 1) {\n        stream_config.liberal_timestamps = liberal_timestamps;\n    }\n    if (!quiet)\n        SCLogConfig(\"stream.liberal-timestamps: %s\", liberal_timestamps ? \"enabled\" : \"disabled\");\n\n    /* init the memcap/use tracking */\n    StreamTcpInitMemuse();\n    StatsRegisterGlobalCounter(\"tcp.memuse\", StreamTcpMemuseCounter);\n\n    StreamTcpReassembleInit(quiet);\n\n    /* set the default free function and flow state function\n     * values. */\n    FlowSetProtoFreeFunc(IPPROTO_TCP, StreamTcpSessionClear);\n\n#ifdef UNITTESTS\n    if (RunmodeIsUnittests()) {\n        SCMutexLock(&ssn_pool_mutex);\n        if (ssn_pool == NULL) {\n            ssn_pool = PoolThreadInit(1, /* thread */\n                    0, /* unlimited */\n                    stream_config.prealloc_sessions,\n                    sizeof(TcpSession),\n                    StreamTcpSessionPoolAlloc,\n                    StreamTcpSessionPoolInit, NULL,\n                    StreamTcpSessionPoolCleanup, NULL);\n        }\n        SCMutexUnlock(&ssn_pool_mutex);\n    }\n#endif\n}", "target": 1}
{"idx": 17, "func": "void StreamTcpInitConfig(bool quiet)\n{\n    intmax_t value = 0;\n    uint16_t rdrange = 10;\n\n    SCLogDebug(\"Initializing Stream\");\n\n    memset(&stream_config,  0, sizeof(stream_config));\n\n    SC_ATOMIC_INIT(stream_config.memcap);\n    SC_ATOMIC_INIT(stream_config.reassembly_memcap);\n\n    if ((ConfGetInt(\"stream.max-sessions\", &value)) == 1) {\n        SCLogWarning(\"max-sessions is obsolete. \"\n                     \"Number of concurrent sessions is now only limited by Flow and \"\n                     \"TCP stream engine memcaps.\");\n    }\n\n    if ((ConfGetInt(\"stream.prealloc-sessions\", &value)) == 1) {\n        stream_config.prealloc_sessions = (uint32_t)value;\n    } else {\n        if (RunmodeIsUnittests()) {\n            stream_config.prealloc_sessions = 128;\n        } else {\n            stream_config.prealloc_sessions = STREAMTCP_DEFAULT_PREALLOC;\n            if (ConfGetNode(\"stream.prealloc-sessions\") != NULL) {\n                WarnInvalidConfEntry(\"stream.prealloc_sessions\",\n                                     \"%\"PRIu32,\n                                     stream_config.prealloc_sessions);\n            }\n        }\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"prealloc-sessions\\\": %\"PRIu32\" (per thread)\",\n                stream_config.prealloc_sessions);\n    }\n\n    const char *temp_stream_memcap_str;\n    if (ConfGet(\"stream.memcap\", &temp_stream_memcap_str) == 1) {\n        uint64_t stream_memcap_copy;\n        if (ParseSizeStringU64(temp_stream_memcap_str, &stream_memcap_copy) < 0) {\n            SCLogError(\"Error parsing stream.memcap \"\n                       \"from conf file - %s.  Killing engine\",\n                    temp_stream_memcap_str);\n            exit(EXIT_FAILURE);\n        } else {\n            SC_ATOMIC_SET(stream_config.memcap, stream_memcap_copy);\n        }\n    } else {\n        SC_ATOMIC_SET(stream_config.memcap, STREAMTCP_DEFAULT_MEMCAP);\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"memcap\\\": %\"PRIu64, SC_ATOMIC_GET(stream_config.memcap));\n    }\n\n    int imidstream;\n    (void)ConfGetBool(\"stream.midstream\", &imidstream);\n    stream_config.midstream = imidstream != 0;\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"midstream\\\" session pickups: %s\", stream_config.midstream ? \"enabled\" : \"disabled\");\n    }\n\n    int async_oneside;\n    (void)ConfGetBool(\"stream.async-oneside\", &async_oneside);\n    stream_config.async_oneside = async_oneside != 0;\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"async-oneside\\\": %s\", stream_config.async_oneside ? \"enabled\" : \"disabled\");\n    }\n\n    int csum = 0;\n\n    if ((ConfGetBool(\"stream.checksum-validation\", &csum)) == 1) {\n        if (csum == 1) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION;\n        }\n    /* Default is that we validate the checksum of all the packets */\n    } else {\n        stream_config.flags |= STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION;\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"checksum-validation\\\": %s\",\n                stream_config.flags & STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION ?\n                \"enabled\" : \"disabled\");\n    }\n\n    const char *temp_stream_inline_str;\n    if (ConfGet(\"stream.inline\", &temp_stream_inline_str) == 1) {\n        int inl = 0;\n\n        /* checking for \"auto\" and falling back to boolean to provide\n         * backward compatibility */\n        if (strcmp(temp_stream_inline_str, \"auto\") == 0) {\n            if (EngineModeIsIPS()) {\n                stream_config.flags |= STREAMTCP_INIT_FLAG_INLINE;\n            }\n        } else if (ConfGetBool(\"stream.inline\", &inl) == 1) {\n            if (inl) {\n                stream_config.flags |= STREAMTCP_INIT_FLAG_INLINE;\n            }\n        }\n    } else {\n        /* default to 'auto' */\n        if (EngineModeIsIPS()) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_INLINE;\n        }\n    }\n    stream_config.ssn_memcap_policy = ExceptionPolicyParse(\"stream.memcap-policy\", true);\n    stream_config.reassembly_memcap_policy =\n            ExceptionPolicyParse(\"stream.reassembly.memcap-policy\", true);\n    stream_config.midstream_policy = ExceptionPolicyMidstreamParse(stream_config.midstream);\n\n    if (!quiet) {\n        SCLogConfig(\"stream.\\\"inline\\\": %s\",\n                    stream_config.flags & STREAMTCP_INIT_FLAG_INLINE\n                    ? \"enabled\" : \"disabled\");\n    }\n\n    int bypass = 0;\n    if ((ConfGetBool(\"stream.bypass\", &bypass)) == 1) {\n        if (bypass == 1) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_BYPASS;\n        }\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"bypass\\\": %s\",\n                    (stream_config.flags & STREAMTCP_INIT_FLAG_BYPASS)\n                    ? \"enabled\" : \"disabled\");\n    }\n\n    int drop_invalid = 0;\n    if ((ConfGetBool(\"stream.drop-invalid\", &drop_invalid)) == 1) {\n        if (drop_invalid == 1) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_DROP_INVALID;\n        }\n    } else {\n        stream_config.flags |= STREAMTCP_INIT_FLAG_DROP_INVALID;\n    }\n\n    const char *temp_urgpol = NULL;\n    if (ConfGet(\"stream.reassembly.urgent.policy\", &temp_urgpol) == 1 && temp_urgpol != NULL) {\n        if (strcmp(temp_urgpol, \"inline\") == 0) {\n            stream_config.urgent_policy = TCP_STREAM_URGENT_INLINE;\n        } else if (strcmp(temp_urgpol, \"drop\") == 0) {\n            stream_config.urgent_policy = TCP_STREAM_URGENT_DROP;\n        } else if (strcmp(temp_urgpol, \"oob\") == 0) {\n            stream_config.urgent_policy = TCP_STREAM_URGENT_OOB;\n        } else if (strcmp(temp_urgpol, \"gap\") == 0) {\n            stream_config.urgent_policy = TCP_STREAM_URGENT_GAP;\n        } else {\n            FatalError(\"stream.reassembly.urgent.policy: invalid value '%s'\", temp_urgpol);\n        }\n    } else {\n        stream_config.urgent_policy = TCP_STREAM_URGENT_DEFAULT;\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly.urgent.policy\\\": %s\", UrgentPolicyToString(stream_config.urgent_policy));\n    }\n    if (stream_config.urgent_policy == TCP_STREAM_URGENT_OOB) {\n        const char *temp_urgoobpol = NULL;\n        if (ConfGet(\"stream.reassembly.urgent.oob-limit-policy\", &temp_urgoobpol) == 1 &&\n                temp_urgoobpol != NULL) {\n            if (strcmp(temp_urgoobpol, \"inline\") == 0) {\n                stream_config.urgent_oob_limit_policy = TCP_STREAM_URGENT_INLINE;\n            } else if (strcmp(temp_urgoobpol, \"drop\") == 0) {\n                stream_config.urgent_oob_limit_policy = TCP_STREAM_URGENT_DROP;\n            } else if (strcmp(temp_urgoobpol, \"gap\") == 0) {\n                stream_config.urgent_oob_limit_policy = TCP_STREAM_URGENT_GAP;\n            } else {\n                FatalError(\"stream.reassembly.urgent.oob-limit-policy: invalid value '%s'\", temp_urgoobpol);\n            }\n        } else {\n            stream_config.urgent_oob_limit_policy = TCP_STREAM_URGENT_DEFAULT;\n        }\n        if (!quiet) {\n            SCLogConfig(\"stream.reassembly.urgent.oob-limit-policy\\\": %s\", UrgentPolicyToString(stream_config.urgent_oob_limit_policy));\n        }\n    }\n\n    if ((ConfGetInt(\"stream.max-syn-queued\", &value)) == 1) {\n        if (value >= 0 && value <= 255) {\n            stream_config.max_syn_queued = (uint8_t)value;\n        } else {\n            stream_config.max_syn_queued = (uint8_t)STREAMTCP_DEFAULT_MAX_SYN_QUEUED;\n        }\n    } else {\n        stream_config.max_syn_queued = (uint8_t)STREAMTCP_DEFAULT_MAX_SYN_QUEUED;\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"max-syn-queued\\\": %\" PRIu8, stream_config.max_syn_queued);\n    }\n\n    if ((ConfGetInt(\"stream.max-synack-queued\", &value)) == 1) {\n        if (value >= 0 && value <= 255) {\n            stream_config.max_synack_queued = (uint8_t)value;\n        } else {\n            stream_config.max_synack_queued = (uint8_t)STREAMTCP_DEFAULT_MAX_SYNACK_QUEUED;\n        }\n    } else {\n        stream_config.max_synack_queued = (uint8_t)STREAMTCP_DEFAULT_MAX_SYNACK_QUEUED;\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"max-synack-queued\\\": %\"PRIu8, stream_config.max_synack_queued);\n    }\n\n    const char *temp_stream_reassembly_memcap_str;\n    if (ConfGet(\"stream.reassembly.memcap\", &temp_stream_reassembly_memcap_str) == 1) {\n        uint64_t stream_reassembly_memcap_copy;\n        if (ParseSizeStringU64(temp_stream_reassembly_memcap_str,\n                               &stream_reassembly_memcap_copy) < 0) {\n            SCLogError(\"Error parsing \"\n                       \"stream.reassembly.memcap \"\n                       \"from conf file - %s.  Killing engine\",\n                    temp_stream_reassembly_memcap_str);\n            exit(EXIT_FAILURE);\n        } else {\n            SC_ATOMIC_SET(stream_config.reassembly_memcap, stream_reassembly_memcap_copy);\n        }\n    } else {\n        SC_ATOMIC_SET(stream_config.reassembly_memcap , STREAMTCP_DEFAULT_REASSEMBLY_MEMCAP);\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly \\\"memcap\\\": %\"PRIu64\"\",\n                    SC_ATOMIC_GET(stream_config.reassembly_memcap));\n    }\n\n    const char *temp_stream_reassembly_depth_str;\n    if (ConfGet(\"stream.reassembly.depth\", &temp_stream_reassembly_depth_str) == 1) {\n        if (ParseSizeStringU32(temp_stream_reassembly_depth_str,\n                               &stream_config.reassembly_depth) < 0) {\n            SCLogError(\"Error parsing \"\n                       \"stream.reassembly.depth \"\n                       \"from conf file - %s.  Killing engine\",\n                    temp_stream_reassembly_depth_str);\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        stream_config.reassembly_depth = 0;\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly \\\"depth\\\": %\"PRIu32\"\", stream_config.reassembly_depth);\n    }\n\n    int randomize = 0;\n    if ((ConfGetBool(\"stream.reassembly.randomize-chunk-size\", &randomize)) == 0) {\n        /* randomize by default if value not set\n         * In ut mode we disable, to get predictable test results */\n        if (!(RunmodeIsUnittests()))\n            randomize = 1;\n    }\n\n    if (randomize) {\n        const char *temp_rdrange;\n        if (ConfGet(\"stream.reassembly.randomize-chunk-range\", &temp_rdrange) == 1) {\n            if (ParseSizeStringU16(temp_rdrange, &rdrange) < 0) {\n                SCLogError(\"Error parsing \"\n                           \"stream.reassembly.randomize-chunk-range \"\n                           \"from conf file - %s.  Killing engine\",\n                        temp_rdrange);\n                exit(EXIT_FAILURE);\n            } else if (rdrange >= 100) {\n                FatalError(\"stream.reassembly.randomize-chunk-range \"\n                           \"must be lower than 100\");\n            }\n        }\n    }\n\n    const char *temp_stream_reassembly_toserver_chunk_size_str;\n    if (ConfGet(\"stream.reassembly.toserver-chunk-size\",\n                &temp_stream_reassembly_toserver_chunk_size_str) == 1) {\n        if (ParseSizeStringU16(temp_stream_reassembly_toserver_chunk_size_str,\n                               &stream_config.reassembly_toserver_chunk_size) < 0) {\n            SCLogError(\"Error parsing \"\n                       \"stream.reassembly.toserver-chunk-size \"\n                       \"from conf file - %s.  Killing engine\",\n                    temp_stream_reassembly_toserver_chunk_size_str);\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        stream_config.reassembly_toserver_chunk_size =\n            STREAMTCP_DEFAULT_TOSERVER_CHUNK_SIZE;\n    }\n\n    if (randomize) {\n        long int r = RandomGetWrap();\n        stream_config.reassembly_toserver_chunk_size +=\n                (int)(stream_config.reassembly_toserver_chunk_size * ((double)r / RAND_MAX - 0.5) *\n                        rdrange / 100);\n    }\n    const char *temp_stream_reassembly_toclient_chunk_size_str;\n    if (ConfGet(\"stream.reassembly.toclient-chunk-size\",\n                &temp_stream_reassembly_toclient_chunk_size_str) == 1) {\n        if (ParseSizeStringU16(temp_stream_reassembly_toclient_chunk_size_str,\n                               &stream_config.reassembly_toclient_chunk_size) < 0) {\n            SCLogError(\"Error parsing \"\n                       \"stream.reassembly.toclient-chunk-size \"\n                       \"from conf file - %s.  Killing engine\",\n                    temp_stream_reassembly_toclient_chunk_size_str);\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        stream_config.reassembly_toclient_chunk_size =\n            STREAMTCP_DEFAULT_TOCLIENT_CHUNK_SIZE;\n    }\n\n    if (randomize) {\n        long int r = RandomGetWrap();\n        stream_config.reassembly_toclient_chunk_size +=\n                (int)(stream_config.reassembly_toclient_chunk_size * ((double)r / RAND_MAX - 0.5) *\n                        rdrange / 100);\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly \\\"toserver-chunk-size\\\": %\"PRIu16,\n            stream_config.reassembly_toserver_chunk_size);\n        SCLogConfig(\"stream.reassembly \\\"toclient-chunk-size\\\": %\"PRIu16,\n            stream_config.reassembly_toclient_chunk_size);\n    }\n\n    int enable_raw = 1;\n    if (ConfGetBool(\"stream.reassembly.raw\", &enable_raw) == 1) {\n        if (!enable_raw) {\n            stream_config.stream_init_flags = STREAMTCP_STREAM_FLAG_DISABLE_RAW;\n        }\n    } else {\n        enable_raw = 1;\n    }\n    if (!quiet)\n        SCLogConfig(\"stream.reassembly.raw: %s\", enable_raw ? \"enabled\" : \"disabled\");\n\n    /* default to true. Not many ppl (correctly) set up host-os policies, so be permissive. */\n    stream_config.liberal_timestamps = true;\n    int liberal_timestamps = 0;\n    if (ConfGetBool(\"stream.liberal-timestamps\", &liberal_timestamps) == 1) {\n        stream_config.liberal_timestamps = liberal_timestamps;\n    }\n    if (!quiet)\n        SCLogConfig(\"stream.liberal-timestamps: %s\", liberal_timestamps ? \"enabled\" : \"disabled\");\n\n    /* init the memcap/use tracking */\n    StreamTcpInitMemuse();\n    StatsRegisterGlobalCounter(\"tcp.memuse\", StreamTcpMemuseCounter);\n\n    StreamTcpReassembleInit(quiet);\n\n    /* set the default free function and flow state function\n     * values. */\n    FlowSetProtoFreeFunc(IPPROTO_TCP, StreamTcpSessionClear);\n\n#ifdef UNITTESTS\n    if (RunmodeIsUnittests()) {\n        SCMutexLock(&ssn_pool_mutex);\n        if (ssn_pool == NULL) {\n            ssn_pool = PoolThreadInit(1, /* thread */\n                    0, /* unlimited */\n                    stream_config.prealloc_sessions,\n                    sizeof(TcpSession),\n                    StreamTcpSessionPoolAlloc,\n                    StreamTcpSessionPoolInit, NULL,\n                    StreamTcpSessionPoolCleanup, NULL);\n        }\n        SCMutexUnlock(&ssn_pool_mutex);\n    }\n#endif\n}", "target": 0}
{"idx": 18, "func": "static TcpSession *StreamTcpNewSession(ThreadVars *tv, StreamTcpThread *stt, Packet *p, int id)\n{\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    if (ssn == NULL) {\n        DEBUG_VALIDATE_BUG_ON(id < 0 || id > UINT16_MAX);\n        p->flow->protoctx = StreamTcpThreadCacheGetSession();\n        if (p->flow->protoctx != NULL) {\n#ifdef UNITTESTS\n            if (tv)\n#endif\n                StatsIncr(tv, stt->counter_tcp_ssn_from_cache);\n        } else {\n            p->flow->protoctx = PoolThreadGetById(ssn_pool, (uint16_t)id);\n            if (p->flow->protoctx != NULL)\n#ifdef UNITTESTS\n                if (tv)\n#endif\n                    StatsIncr(tv, stt->counter_tcp_ssn_from_pool);\n        }\n#ifdef DEBUG\n        SCMutexLock(&ssn_pool_mutex);\n        if (p->flow->protoctx != NULL)\n            ssn_pool_cnt++;\n        SCMutexUnlock(&ssn_pool_mutex);\n\n        if (unlikely((g_eps_stream_ssn_memcap != UINT64_MAX &&\n                      g_eps_stream_ssn_memcap == t_pcapcnt))) {\n            SCLogNotice(\"simulating memcap reached condition for packet %\" PRIu64, t_pcapcnt);\n            ExceptionPolicyApply(p, stream_config.ssn_memcap_policy, PKT_DROP_REASON_STREAM_MEMCAP);\n            StreamTcpSsnMemcapExceptionPolicyStatsIncr(tv, stt, stream_config.ssn_memcap_policy);\n            return NULL;\n        }\n#endif\n        ssn = (TcpSession *)p->flow->protoctx;\n        if (ssn == NULL) {\n            SCLogDebug(\"ssn_pool is empty\");\n            ExceptionPolicyApply(p, stream_config.ssn_memcap_policy, PKT_DROP_REASON_STREAM_MEMCAP);\n            StreamTcpSsnMemcapExceptionPolicyStatsIncr(tv, stt, stream_config.ssn_memcap_policy);\n            return NULL;\n        }\n\n        const TCPHdr *tcph = PacketGetTCP(p);\n        ssn->state = TCP_NONE;\n        ssn->reassembly_depth = stream_config.reassembly_depth;\n        ssn->tcp_packet_flags = tcph->th_flags;\n        ssn->server.flags = stream_config.stream_init_flags;\n        ssn->client.flags = stream_config.stream_init_flags;\n\n        StreamingBuffer x = STREAMING_BUFFER_INITIALIZER;\n        ssn->client.sb = x;\n        ssn->server.sb = x;\n\n        if (PKT_IS_TOSERVER(p)) {\n            ssn->client.tcp_flags = tcph->th_flags;\n            ssn->server.tcp_flags = 0;\n        } else if (PKT_IS_TOCLIENT(p)) {\n            ssn->server.tcp_flags = tcph->th_flags;\n            ssn->client.tcp_flags = 0;\n        }\n    }\n\n    return ssn;\n}", "target": 1}
{"idx": 19, "func": "static bool IsReassemblyMemcapExceptionPolicyStatsValid(enum ExceptionPolicy exception_policy)\n{\n    if (EngineModeIsIPS()) {\n        return stream_reassembly_memcap_eps_stats.valid_settings_ips[exception_policy];\n    }\n    return stream_reassembly_memcap_eps_stats.valid_settings_ids[exception_policy];\n}", "target": 0}
{"idx": 20, "func": "uint64_t StreamTcpGetMemcap(void)\n{\n    uint64_t memcapcopy = SC_ATOMIC_GET(stream_config.memcap);\n    return memcapcopy;\n}", "target": 1}
{"idx": 21, "func": "void StreamTcpStreamCleanup(TcpStream *stream)\n{\n    if (stream != NULL) {\n        StreamTcpSackFreeList(stream);\n        StreamTcpReturnStreamSegments(stream);\n        StreamingBufferClear(&stream->sb, &stream_config.sbcnf);\n    }\n}", "target": 0}
{"idx": 22, "func": "static void StreamTcp3whsSynAckUpdate(TcpSession *ssn, Packet *p, TcpStateQueue *q)\n{\n    TcpStateQueue update;\n    if (likely(q == NULL)) {\n        StreamTcp3whsSynAckToStateQueue(p, &update);\n        q = &update;\n    }\n\n    if (ssn->state != TCP_SYN_RECV) {\n        /* update state */\n        StreamTcpPacketSetState(p, ssn, TCP_SYN_RECV);\n        SCLogDebug(\"ssn %p: =~ ssn state is now TCP_SYN_RECV\", ssn);\n    }\n    /* sequence number & window */\n    ssn->server.isn = q->seq;\n    STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n    ssn->server.next_seq = ssn->server.isn + 1;\n\n    ssn->client.window = q->win;\n    SCLogDebug(\"ssn %p: window %\" PRIu32 \"\", ssn, ssn->server.window);\n\n    /* Set the timestamp values used to validate the timestamp of\n     * received packets.*/\n    if ((q->flags & STREAMTCP_QUEUE_FLAG_TS) &&\n            (ssn->client.flags & STREAMTCP_STREAM_FLAG_TIMESTAMP))\n    {\n        ssn->server.last_ts = q->ts;\n        SCLogDebug(\"ssn %p: ssn->server.last_ts %\" PRIu32\" \"\n                \"ssn->client.last_ts %\" PRIu32\"\", ssn,\n                ssn->server.last_ts, ssn->client.last_ts);\n        ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n        ssn->server.last_pkt_ts = q->pkt_ts;\n        if (ssn->server.last_ts == 0)\n            ssn->server.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n    } else {\n        ssn->client.last_ts = 0;\n        ssn->server.last_ts = 0;\n        ssn->client.flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n    }\n\n    ssn->client.last_ack = q->ack;\n    ssn->server.last_ack = ssn->server.isn + 1;\n\n    /** check for the presence of the ws ptr to determine if we\n     *  support wscale at all */\n    if ((ssn->flags & STREAMTCP_FLAG_SERVER_WSCALE) &&\n            (q->flags & STREAMTCP_QUEUE_FLAG_WS))\n    {\n        ssn->client.wscale = q->wscale;\n    } else {\n        ssn->client.wscale = 0;\n    }\n\n    if ((ssn->flags & STREAMTCP_FLAG_CLIENT_SACKOK) &&\n            (q->flags & STREAMTCP_QUEUE_FLAG_SACK)) {\n        ssn->flags |= STREAMTCP_FLAG_SACKOK;\n        SCLogDebug(\"ssn %p: SACK permitted for session\", ssn);\n    } else {\n        ssn->flags &= ~STREAMTCP_FLAG_SACKOK;\n    }\n\n    ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n    ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n    SCLogDebug(\"ssn %p: ssn->server.next_win %\" PRIu32 \"\", ssn,\n            ssn->server.next_win);\n    SCLogDebug(\"ssn %p: ssn->client.next_win %\" PRIu32 \"\", ssn,\n            ssn->client.next_win);\n    SCLogDebug(\"ssn %p: ssn->server.isn %\" PRIu32 \", \"\n            \"ssn->server.next_seq %\" PRIu32 \", \"\n            \"ssn->server.last_ack %\" PRIu32 \" \"\n            \"(ssn->client.last_ack %\" PRIu32 \")\", ssn,\n            ssn->server.isn, ssn->server.next_seq,\n            ssn->server.last_ack, ssn->client.last_ack);\n\n    /* unset the 4WHS flag as we received this SYN/ACK as part of a\n     * (so far) valid 3WHS */\n    if (ssn->flags & STREAMTCP_FLAG_4WHS)\n        SCLogDebug(\"ssn %p: STREAMTCP_FLAG_4WHS unset, normal SYN/ACK\"\n                \" so considering 3WHS\", ssn);\n\n    ssn->flags &=~ STREAMTCP_FLAG_4WHS;\n}\n\n/** \\internal\n *  \\brief detect timestamp anomalies when processing responses to the\n *         SYN packet.\n *  \\retval true packet is ok\n *  \\retval false packet is bad\n */", "target": 1}
{"idx": 23, "func": "static int StreamTcp3whsQueueSynAck(TcpSession *ssn, Packet *p)\n{\n    /* first see if this is already in our list */\n    if (StreamTcp3whsFindSynAckBySynAck(ssn, p) != NULL)\n        return 0;\n\n    if (ssn->queue_len == stream_config.max_synack_queued) {\n        SCLogDebug(\"ssn %p: =~ SYN/ACK queue limit reached\", ssn);\n        StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_FLOOD);\n        return -1;\n    }\n\n    if (StreamTcpCheckMemcap((uint32_t)sizeof(TcpStateQueue)) == 0) {\n        SCLogDebug(\"ssn %p: =~ SYN/ACK queue failed: stream memcap reached\", ssn);\n        return -1;\n    }\n\n    TcpStateQueue *q = SCCalloc(1, sizeof(*q));\n    if (unlikely(q == NULL)) {\n        SCLogDebug(\"ssn %p: =~ SYN/ACK queue failed: alloc failed\", ssn);\n        return -1;\n    }\n    StreamTcpIncrMemuse((uint64_t)sizeof(TcpStateQueue));\n\n    StreamTcp3whsSynAckToStateQueue(p, q);\n\n    /* put in list */\n    q->next = ssn->queue;\n    ssn->queue = q;\n    ssn->queue_len++;\n    return 0;\n}\n\n/** \\internal\n *  \\brief Find the Queued SYN/ACK that goes with this ACK\n *  \\retval q or NULL */", "target": 0}
{"idx": 24, "func": "void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)\n{\n    int r, rv;\n    ogs_nas_5gmm_cause_t gmm_cause;\n\n    amf_ue_t *amf_ue = NULL;\n    ran_ue_t *ran_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_nas_5gs_message_t *nas_message = NULL;\n    ogs_nas_security_header_type_t h;\n\n    ogs_nas_5gs_authentication_failure_t *authentication_failure = NULL;\n    ogs_nas_authentication_failure_parameter_t\n        *authentication_failure_parameter = NULL;\n\n    ogs_sbi_message_t *sbi_message = NULL;\n\n    ogs_assert(s);\n    ogs_assert(e);\n\n    amf_sm_debug(e);\n\n    sess = amf_sess_find_by_id(e->sess_id);\n    if (sess) {\n        amf_ue = amf_ue_find_by_id(sess->amf_ue_id);\n        ogs_assert(amf_ue);\n    } else {\n        amf_ue = amf_ue_find_by_id(e->amf_ue_id);\n        ogs_assert(amf_ue);\n    }\n\n    switch (e->h.id) {\n    case OGS_FSM_ENTRY_SIG:\n        break;\n    case OGS_FSM_EXIT_SIG:\n        break;\n    case AMF_EVENT_5GMM_MESSAGE:\n        nas_message = e->nas.message;\n        ogs_assert(nas_message);\n\n        ran_ue = ran_ue_find_by_id(amf_ue->ran_ue_id);\n        ogs_assert(ran_ue);\n\n        h.type = e->nas.type;\n\n        switch (nas_message->gmm.h.message_type) {\n        case OGS_NAS_5GS_AUTHENTICATION_RESPONSE:\n            rv = gmm_handle_authentication_response(\n                    amf_ue, &nas_message->gmm.authentication_response);\n\n            if (rv != OGS_OK) {\n                r = nas_5gs_send_authentication_reject(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n            }\n            break;\n\n        case OGS_NAS_5GS_AUTHENTICATION_FAILURE:\n            authentication_failure = &nas_message->gmm.authentication_failure;\n            ogs_assert(authentication_failure);\n            authentication_failure_parameter = &authentication_failure->\n                authentication_failure_parameter;\n            ogs_assert(authentication_failure_parameter);\n\n            ogs_debug(\"[%s] Authentication failure [%d]\", amf_ue->suci,\n                    authentication_failure->gmm_cause);\n\n            amf_metrics_inst_by_cause_add(authentication_failure->gmm_cause,\n                    AMF_METR_CTR_AMF_AUTH_FAIL, 1);\n\n            CLEAR_AMF_UE_TIMER(amf_ue->t3560);\n\n            switch (authentication_failure->gmm_cause) {\n            case OGS_5GMM_CAUSE_MAC_FAILURE:\n                ogs_warn(\"Authentication failure(MAC failure)\");\n                break;\n\n            case OGS_5GMM_CAUSE_NON_5G_AUTHENTICATION_UNACCEPTABLE:\n                ogs_error(\"Authentication failure\"\n                        \"(Non-5GS authentication unacceptable)\");\n                break;\n\n            case OGS_5GMM_CAUSE_NGKSI_ALREADY_IN_USE:\n                ogs_warn(\"Authentication failure(ngKSI already in use)\");\n                r = amf_ue_sbi_discover_and_send(\n                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                        amf_nausf_auth_build_authenticate,\n                        amf_ue, 0, NULL);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                return;\n\n            case OGS_5GMM_CAUSE_SYNCH_FAILURE:\n                ogs_warn(\"Authentication failure(Synch failure)\");\n                if (authentication_failure_parameter->length != OGS_AUTS_LEN) {\n                    ogs_error(\"Invalid AUTS Length [%d]\",\n                            authentication_failure_parameter->length);\n                    break;\n                }\n                r = amf_ue_sbi_discover_and_send(\n                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                        amf_nausf_auth_build_authenticate,\n                        amf_ue, 0, authentication_failure_parameter->auts);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                return;\n\n            default:\n                ogs_error(\"Unknown GMM_CAUSE{%d] in Authentication\"\n                        \" failure\",\n                        authentication_failure->gmm_cause);\n                break;\n            }\n\n            r = nas_5gs_send_authentication_reject(amf_ue);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n            OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n\n            break;\n        case OGS_NAS_5GS_REGISTRATION_REQUEST:\n            ogs_warn(\"Registration request\");\n            gmm_cause = gmm_handle_registration_request(\n                    amf_ue, h, e->ngap.code,\n                    &nas_message->gmm.registration_request);\n            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {\n                ogs_error(\"[%s] gmm_handle_registration_request() failed [%d]\",\n                            amf_ue->suci, gmm_cause);\n                r = nas_5gs_send_registration_reject(ran_ue, amf_ue, gmm_cause);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(s, gmm_state_exception);\n                break;\n            }\n\n            r = amf_ue_sbi_discover_and_send(\n                    OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                    amf_nausf_auth_build_authenticate, amf_ue, 0, NULL);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n            break;\n\n        case OGS_NAS_5GS_5GMM_STATUS:\n            ogs_warn(\"[%s] 5GMM STATUS : Cause[%d]\",\n                    amf_ue->suci, nas_message->gmm.gmm_status.gmm_cause);\n            break;\n\n        case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:\n            ogs_warn(\"[%s] Deregistration request\", amf_ue->supi);\n\n            gmm_handle_deregistration_request(\n                    amf_ue, &nas_message->gmm.deregistration_request_from_ue);\n            OGS_FSM_TRAN(s, &gmm_state_de_registered);\n            break;\n\n        default:\n            ogs_error(\"Unknown message[%d]\", nas_message->gmm.h.message_type);\n            break;\n        }\n        break;\n    case AMF_EVENT_5GMM_TIMER:\n        switch (e->h.timer_id) {\n        case AMF_TIMER_T3560:\n            if (amf_ue->t3560.retry_count >=\n                    amf_timer_cfg(AMF_TIMER_T3560)->max_count) {\n                ogs_warn(\"[%s] Retransmission failed. Stop retransmission\",\n                        amf_ue->suci);\n                r = nas_5gs_send_authentication_reject(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n            } else {\n                amf_ue->t3560.retry_count++;\n                r = nas_5gs_send_authentication_request(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n            }\n            break;\n        default:\n            ogs_error(\"[%s] Unknown timer[%s:%d]\", amf_ue->suci,\n                    amf_timer_get_name(e->h.timer_id), e->h.timer_id);\n            break;\n        }\n        break;\n    case OGS_EVENT_SBI_CLIENT:\n        sbi_message = e->h.sbi.message;\n        ogs_assert(sbi_message);\n\n        SWITCH(sbi_message->h.service.name)\n        CASE(OGS_SBI_SERVICE_NAME_NAUSF_AUTH)\n            SWITCH(sbi_message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_AUTHENTICATIONS)\n\n                if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n                    sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                    if (sbi_message->res_status ==\n                            OGS_SBI_HTTP_STATUS_NOT_FOUND) {\n                        ogs_warn(\"[%s] Cannot find SUCI [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    } else {\n                        ogs_error(\"[%s] HTTP response error [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    }\n                    r = nas_5gs_send_gmm_reject_from_sbi(\n                            amf_ue, sbi_message->res_status);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n                    OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    break;\n                }\n\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    rv = amf_nausf_auth_handle_authenticate(\n                            amf_ue, sbi_message);\n                    if (rv != OGS_OK) {\n                        ogs_error(\"[%s] Cannot handle SBI message\",\n                                amf_ue->suci);\n                        r = nas_5gs_send_authentication_reject(amf_ue);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    }\n                    break;\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    rv = amf_nausf_auth_handle_authenticate_confirmation(\n                            amf_ue, sbi_message);\n                    if (rv != OGS_OK) {\n                        ogs_error(\"[%s] Cannot handle SBI message\",\n                                amf_ue->suci);\n                        r = nas_5gs_send_authentication_reject(amf_ue);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    } else {\n                        amf_ue->selected_int_algorithm =\n                            amf_selected_int_algorithm(amf_ue);\n                        amf_ue->selected_enc_algorithm =\n                            amf_selected_enc_algorithm(amf_ue);\n\n                        if (amf_ue->selected_int_algorithm ==\n                                OGS_NAS_SECURITY_ALGORITHMS_EIA0) {\n                            ogs_error(\"Encrypt[0x%x] can be skipped \"\n                                \"with NEA0, but Integrity[0x%x] cannot be \"\n                                \"bypassed with NIA0\",\n                                amf_ue->selected_enc_algorithm,\n                                amf_ue->selected_int_algorithm);\n                            OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                            break;\n                        }\n\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_security_mode);\n                    }\n                    break;\n                DEFAULT\n                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n                            amf_ue->suci, sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[0]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_UECM)\n            if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n                sbi_message->res_status != OGS_SBI_HTTP_STATUS_NO_CONTENT &&\n                sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                ogs_error(\"[%s] HTTP response error [%d]\",\n                        amf_ue->supi, sbi_message->res_status);\n            }\n\n            SWITCH(sbi_message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_REGISTRATIONS)\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    /*\n                     * Issue #2733\n                     *\n                     * We need to ignore this message in this state.\n                     */\n                    ogs_error(\"[%s] Ignore SBI message\", amf_ue->supi);\n                    break;\n                DEFAULT\n                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n                            amf_ue->suci, sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[1]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        DEFAULT\n            ogs_error(\"Invalid service name [%s]\", sbi_message->h.service.name);\n            ogs_assert_if_reached();\n        END\n        break;\n\n    default:\n        ogs_error(\"Unknown event[%s]\", amf_event_get_name(e));\n        break;\n    }\n}", "target": 1}
{"idx": 25, "func": "void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)\n{\n    int r, rv;\n    ogs_nas_5gmm_cause_t gmm_cause;\n\n    amf_ue_t *amf_ue = NULL;\n    ran_ue_t *ran_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_nas_5gs_message_t *nas_message = NULL;\n    ogs_nas_security_header_type_t h;\n\n    ogs_nas_5gs_authentication_failure_t *authentication_failure = NULL;\n    ogs_nas_authentication_failure_parameter_t\n        *authentication_failure_parameter = NULL;\n\n    ogs_sbi_message_t *sbi_message = NULL;\n\n    ogs_assert(s);\n    ogs_assert(e);\n\n    amf_sm_debug(e);\n\n    sess = amf_sess_find_by_id(e->sess_id);\n    if (sess) {\n        amf_ue = amf_ue_find_by_id(sess->amf_ue_id);\n        ogs_assert(amf_ue);\n    } else {\n        amf_ue = amf_ue_find_by_id(e->amf_ue_id);\n        ogs_assert(amf_ue);\n    }\n\n    switch (e->h.id) {\n    case OGS_FSM_ENTRY_SIG:\n        break;\n    case OGS_FSM_EXIT_SIG:\n        break;\n    case AMF_EVENT_5GMM_MESSAGE:\n        nas_message = e->nas.message;\n        ogs_assert(nas_message);\n\n        ran_ue = ran_ue_find_by_id(amf_ue->ran_ue_id);\n        ogs_assert(ran_ue);\n\n        h.type = e->nas.type;\n\n        switch (nas_message->gmm.h.message_type) {\n        case OGS_NAS_5GS_AUTHENTICATION_RESPONSE:\n            rv = gmm_handle_authentication_response(\n                    amf_ue, &nas_message->gmm.authentication_response);\n\n            if (rv != OGS_OK) {\n                r = nas_5gs_send_authentication_reject(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n            }\n            break;\n\n        case OGS_NAS_5GS_AUTHENTICATION_FAILURE:\n            authentication_failure = &nas_message->gmm.authentication_failure;\n            ogs_assert(authentication_failure);\n            authentication_failure_parameter = &authentication_failure->\n                authentication_failure_parameter;\n            ogs_assert(authentication_failure_parameter);\n\n            ogs_debug(\"[%s] Authentication failure [%d]\", amf_ue->suci,\n                    authentication_failure->gmm_cause);\n\n            amf_metrics_inst_by_cause_add(authentication_failure->gmm_cause,\n                    AMF_METR_CTR_AMF_AUTH_FAIL, 1);\n\n            CLEAR_AMF_UE_TIMER(amf_ue->t3560);\n\n            switch (authentication_failure->gmm_cause) {\n            case OGS_5GMM_CAUSE_MAC_FAILURE:\n                ogs_warn(\"Authentication failure(MAC failure)\");\n                break;\n\n            case OGS_5GMM_CAUSE_NON_5G_AUTHENTICATION_UNACCEPTABLE:\n                ogs_error(\"Authentication failure\"\n                        \"(Non-5GS authentication unacceptable)\");\n                break;\n\n            case OGS_5GMM_CAUSE_NGKSI_ALREADY_IN_USE:\n                ogs_warn(\"Authentication failure(ngKSI already in use)\");\n                r = amf_ue_sbi_discover_and_send(\n                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                        amf_nausf_auth_build_authenticate,\n                        amf_ue, 0, NULL);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                return;\n\n            case OGS_5GMM_CAUSE_SYNCH_FAILURE:\n                ogs_warn(\"Authentication failure(Synch failure)\");\n                if (authentication_failure_parameter->length != OGS_AUTS_LEN) {\n                    ogs_error(\"Invalid AUTS Length [%d]\",\n                            authentication_failure_parameter->length);\n                    break;\n                }\n                r = amf_ue_sbi_discover_and_send(\n                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                        amf_nausf_auth_build_authenticate,\n                        amf_ue, 0, authentication_failure_parameter->auts);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                return;\n\n            default:\n                ogs_error(\"Unknown GMM_CAUSE{%d] in Authentication\"\n                        \" failure\",\n                        authentication_failure->gmm_cause);\n                break;\n            }\n\n            r = nas_5gs_send_authentication_reject(amf_ue);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n            OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n\n            break;\n        case OGS_NAS_5GS_REGISTRATION_REQUEST:\n            ogs_warn(\"Registration request\");\n            gmm_cause = gmm_handle_registration_request(\n                    amf_ue, h, e->ngap.code,\n                    &nas_message->gmm.registration_request);\n            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {\n                ogs_error(\"[%s] gmm_handle_registration_request() failed [%d]\",\n                            amf_ue->suci, gmm_cause);\n                r = nas_5gs_send_registration_reject(ran_ue, amf_ue, gmm_cause);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(s, gmm_state_exception);\n                break;\n            }\n\n            r = amf_ue_sbi_discover_and_send(\n                    OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                    amf_nausf_auth_build_authenticate, amf_ue, 0, NULL);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n            break;\n\n        case OGS_NAS_5GS_5GMM_STATUS:\n            ogs_warn(\"[%s] 5GMM STATUS : Cause[%d]\",\n                    amf_ue->suci, nas_message->gmm.gmm_status.gmm_cause);\n            break;\n\n        case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:\n            ogs_warn(\"[%s] Deregistration request\", amf_ue->supi);\n\n            gmm_handle_deregistration_request(\n                    amf_ue, &nas_message->gmm.deregistration_request_from_ue);\n            OGS_FSM_TRAN(s, &gmm_state_de_registered);\n            break;\n\n        default:\n            ogs_error(\"Unknown message[%d]\", nas_message->gmm.h.message_type);\n            break;\n        }\n        break;\n    case AMF_EVENT_5GMM_TIMER:\n        switch (e->h.timer_id) {\n        case AMF_TIMER_T3560:\n            if (amf_ue->t3560.retry_count >=\n                    amf_timer_cfg(AMF_TIMER_T3560)->max_count) {\n                ogs_warn(\"[%s] Retransmission failed. Stop retransmission\",\n                        amf_ue->suci);\n                r = nas_5gs_send_authentication_reject(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n            } else {\n                amf_ue->t3560.retry_count++;\n                r = nas_5gs_send_authentication_request(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n            }\n            break;\n        default:\n            ogs_error(\"[%s] Unknown timer[%s:%d]\", amf_ue->suci,\n                    amf_timer_get_name(e->h.timer_id), e->h.timer_id);\n            break;\n        }\n        break;\n    case OGS_EVENT_SBI_CLIENT:\n        sbi_message = e->h.sbi.message;\n        ogs_assert(sbi_message);\n\n        SWITCH(sbi_message->h.service.name)\n        CASE(OGS_SBI_SERVICE_NAME_NAUSF_AUTH)\n            SWITCH(sbi_message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_AUTHENTICATIONS)\n\n                if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n                    sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                    if (sbi_message->res_status ==\n                            OGS_SBI_HTTP_STATUS_NOT_FOUND) {\n                        ogs_warn(\"[%s] Cannot find SUCI [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    } else {\n                        ogs_error(\"[%s] HTTP response error [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    }\n                    r = nas_5gs_send_gmm_reject_from_sbi(\n                            amf_ue, sbi_message->res_status);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n                    OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    break;\n                }\n\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    rv = amf_nausf_auth_handle_authenticate(\n                            amf_ue, sbi_message);\n                    if (rv != OGS_OK) {\n                        ogs_error(\"[%s] Cannot handle SBI message\",\n                                amf_ue->suci);\n                        r = nas_5gs_send_authentication_reject(amf_ue);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    }\n                    break;\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    rv = amf_nausf_auth_handle_authenticate_confirmation(\n                            amf_ue, sbi_message);\n                    if (rv != OGS_OK) {\n                        ogs_error(\"[%s] Cannot handle SBI message\",\n                                amf_ue->suci);\n                        r = nas_5gs_send_authentication_reject(amf_ue);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    } else {\n                        amf_ue->selected_int_algorithm =\n                            amf_selected_int_algorithm(amf_ue);\n                        amf_ue->selected_enc_algorithm =\n                            amf_selected_enc_algorithm(amf_ue);\n\n                        if (amf_ue->selected_int_algorithm ==\n                                OGS_NAS_SECURITY_ALGORITHMS_EIA0) {\n                            ogs_error(\"Encrypt[0x%x] can be skipped \"\n                                \"with NEA0, but Integrity[0x%x] cannot be \"\n                                \"bypassed with NIA0\",\n                                amf_ue->selected_enc_algorithm,\n                                amf_ue->selected_int_algorithm);\n                            OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                            break;\n                        }\n\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_security_mode);\n                    }\n                    break;\n                DEFAULT\n                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n                            amf_ue->suci, sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[0]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_UECM)\n            if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n                sbi_message->res_status != OGS_SBI_HTTP_STATUS_NO_CONTENT &&\n                sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                ogs_error(\"[%s] HTTP response error [%d]\",\n                        amf_ue->supi, sbi_message->res_status);\n            }\n\n            SWITCH(sbi_message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_REGISTRATIONS)\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    /*\n                     * Issue #2733\n                     *\n                     * We need to ignore this message in this state.\n                     */\n                    ogs_error(\"[%s] Ignore SBI message\", amf_ue->supi);\n                    break;\n                DEFAULT\n                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n                            amf_ue->suci, sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[1]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NPCF_AM_POLICY_CONTROL)\n            SWITCH(sbi_message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_POLICIES)\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED) {\n                        ogs_error(\"[%s] HTTP response error [%d]\",\n                                amf_ue->supi, sbi_message->res_status);\n                    }\n                    ogs_error(\"[%s] Ignore SBI message\", amf_ue->supi);\n                    break;\n\n                DEFAULT\n                    ogs_error(\"Unknown method [%s]\", sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[0]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        DEFAULT\n            ogs_error(\"Invalid service name [%s]\", sbi_message->h.service.name);\n            ogs_assert_if_reached();\n        END\n        break;\n\n    default:\n        ogs_error(\"Unknown event[%s]\", amf_event_get_name(e));\n        break;\n    }\n}", "target": 0}
{"idx": 26, "func": "void isor_reader_get_sample(ISOMChannel *ch)\n{\n\tGF_Err e;\n\tBool skip_sample=GF_FALSE;\n\tu32 sample_desc_index;\n\tif (ch->sample) return;\n\n\tif (ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tif (!ch->owner->nodata)\n\t\t\tgf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);\n\t\tch->next_track = 0;\n\t}\n\n\tif (ch->to_init) {\n\t\tif (!ch->owner->nodata)\n\t\t\tgf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);\n\t\tinit_reader(ch);\n\t\tsample_desc_index = ch->last_sample_desc_index;\n\t} else if (ch->speed < 0) {\n\t\tif (ch->last_state == GF_EOS) {\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->static_sample->IsRAP) {\n\t\t\tch->last_rap_sample_time = ch->sample_time;\n\t\t}\n\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\tch->static_sample->alloc_size = 0;\n\n\t\tif ((e==GF_EOS) || (ch->static_sample->IsRAP)) {\n\t\t\tif (!ch->last_rap_sample_time) {\n\t\t\t\te = GF_EOS;\n\t\t\t} else {\n\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tif ((e==GF_EOS) && !ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\t\tch->sample = ch->static_sample;\n\n\t\tif (ch->sample->DTS == ch->sample_time) {\n\t\t\tif (!ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\tif (ch->sample) {\n\t\t\tch->sample_time = ch->sample->DTS;\n\t\t}\n\n\t} else if (ch->has_edit_list) {\n\t\tu32 prev_sample = ch->sample_num;\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\tch->static_sample->alloc_size = 0;\n\n\t\tif (e == GF_OK) {\n\t\t\tch->sample = ch->static_sample;\n\n\t\t\t/*we are in forced seek mode: fetch all samples before the one matching the sample time*/\n\t\t\tif (ch->edit_sync_frame) {\n\t\t\t\tch->edit_sync_frame++;\n\t\t\t\tif (ch->edit_sync_frame < ch->sample_num) {\n\t\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t\t\tif (ch->sample) {\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch->edit_sync_frame = 0;\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*if we get the same sample, figure out next interesting time (current sample + DTS gap to next sample should be a good bet)*/\n\t\t\t\tif (prev_sample == ch->sample_num) {\n\t\t\t\t\tif (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {\n\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 sample_num = ch->sample_num ? ch->sample_num : 1;\n\n\t\t\t\t\t\tif (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {\n\t\t\t\t\t\t\t//e = GF_EOS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tu32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);\n\t\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\t\tif (ch->sample_num == prev_sample) {\n\t\t\t\t\t\t\t\t\tch->sample_time += time_diff;\n\t\t\t\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*we jumped to another segment - if RAP is needed look for closest rap in decoding order and\n\t\t\t\tforce seek mode*/\n\t\t\t\tif (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {\n\t\t\t\t\tGF_ISOSample *found = ch->static_sample;\n\t\t\t\t\tu32 samp_num = ch->sample_num;\n\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\tch->sample = (e == GF_OK) ? ch->static_sample : NULL;\n\n\t\t\t\t\t/*if no sync point in the past, use the first non-sync for the given time*/\n\t\t\t\t\tif (!ch->sample || !ch->sample->data) {\n\t\t\t\t\t\tch->sample = ch->static_sample = found;\n\t\t\t\t\t\tch->sample_time = ch->sample->DTS;\n\t\t\t\t\t\tch->sample_num = samp_num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBool do_fetch = GF_TRUE;\n\t\tch->sample_num++;\n\t\tif (ch->sample_last && (ch->sample_last<ch->sample_num)) {\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->sap_only) {\n\t\t\tBool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);\n\t\t\tif (!is_rap) {\n\t\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);\n\t\t\t\tif (roll_type) is_rap = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!is_rap) {\n\t\t\t\tdo_fetch = GF_FALSE;\n\t\t\t} else if (ch->sap_only==2) {\n\t\t\t\tch->sap_only = 0;\n\t\t\t}\n\t\t}\n\t\tif (do_fetch) {\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\t/*if sync shadow / carousel RAP skip*/\n\t\t\tif (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {\n\t\t\t\tch->sample = NULL;\n\t\t\t\tch->sample_num++;\n\t\t\t\tif (ch->pck) {\n\t\t\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\t\t\tch->pck = NULL;\n\t\t\t\t}\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tskip_sample = GF_TRUE;\n\t\t}\n\t}\n\n\t//check scalable track change\n\tif (ch->sample && ch->sample->IsRAP && ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t\tch->sample = NULL;\n\t\tif (ch->pck) {\n\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\tch->pck = NULL;\n\t\t}\n\t\tisor_reader_get_sample(ch);\n\t\treturn;\n\t}\n\n\tif (!ch->sample) {\n\t\tu32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);\n\t\tch->sample_data_offset = 0;\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t\tif (ch->owner->mem_load_mode==2)\n\t\t\t\tch->owner->force_fetch = GF_TRUE;\n\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\tif (!ch->has_edit_list && ch->sample_num)\n\t\t\t\t\tch->sample_num--;\n\t\t\t} else {\n\t\t\t\tif (ch->to_init && ch->sample_num) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\", ch->sample_num, ch->track));\n\t\t\t\t\tch->last_state = GF_ISOM_INVALID_FILE;\n\t\t\t\t} else {\n\t\t\t\t\tif (!ch->eos_sent) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] File truncated, aborting read for track %d\\n\", ch->track));\n\t\t\t\t\t}\n\t\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!ch->sample_num\n\t\t         || ((ch->speed >= 0) && (ch->sample_num >= sample_count))\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t         || ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))\n#endif\n\t\t) {\n\n\t\t\tif (ch->owner->frag_type==1) {\n\t\t\t\t/*if sample cannot be found and file is fragmented, rewind sample*/\n\t\t\t\tif (ch->sample_num) ch->sample_num--;\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t} else if (ch->last_state != GF_EOS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d end of stream reached\\n\", ch->track));\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t} else {\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t}\n\t\t} else if (!skip_sample) {\n\t\t\te = gf_isom_last_error(ch->owner->mov);\n\t\t\tGF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));\n\n\t\t\tif ((e<GF_OK) && (e!=GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t//first sample fetched has DTS, we have a tfdt so ignore the hinted one\n\tif ((ch->sample_num==1) && ch->hint_first_tfdt && ch->sample->DTS) {\n\t\tch->hint_first_tfdt = 0;\n\t}\n\tch->sample->DTS += ch->hint_first_tfdt;\n\n\tif (sample_desc_index != ch->last_sample_desc_index) {\n\t\tif (!ch->owner->stsd) {\n\t\t\t//we used sample entry 1 by default to setup, if no active prev sample (edit list might trigger this)\n\t\t\t//and new sample desc is 1, do not reconfigure\n\t\t\tif (!ch->last_sample_desc_index && (sample_desc_index==1)) {\n\n\t\t\t} else {\n\t\t\t\tch->needs_pid_reconfig = 1;\n\t\t\t}\n\t\t}\n\t\tch->last_sample_desc_index = sample_desc_index;\n\t}\n\n\tch->last_state = GF_OK;\n\n\tch->sap_3 = GF_FALSE;\n\tch->sap_4_type = 0;\n\tch->roll = 0;\n\n\tif (ch->sample) {\n\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);\n\n\t\t/*still seeking or not ?\n\t\t 1- when speed is negative, the RAP found is \"after\" the seek point in playback order since we used backward RAP search: nothing to do\n\t\t 2- otherwise set DTS+CTS to start value\n\t\t */\n\t\tif ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {\n\t\t\tch->dts = ch->sample->DTS;\n\t\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\t\tch->seek_flag = 0;\n\t\t} else {\n\t\t\tch->cts = ch->start;\n\t\t\tch->seek_flag = 1;\n\t\t\tch->dts = ch->start;\n\t\t}\n\n\t\tif (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->sample->duration)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] End of Channel \"LLD\" (CTS \"LLD\")\\n\", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else {\n\t\tch->sender_ntp = ch->ntp_at_server_ntp = 0;\n\t}\n\n\tif (!ch->sample_num) return;\n\n\tgf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);\n\n\tif (ch->is_encrypted) {\n\t\t/*in case of CENC: we write sample auxiliary information to slh->sai; its size is in saiz*/\n\t\tif (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tisor_update_cenc_info(ch, GF_FALSE);\n\n\t\t} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tch->pck_encrypted = GF_TRUE;\n\t\t} else {\n\t\t\tch->pck_encrypted = GF_FALSE;\n\t\t}\n\t}\n\tif (ch->sample && ch->sample->nb_pack)\n\t\tch->sample_num += ch->sample->nb_pack-1;\n}", "target": 1}
{"idx": 27, "func": "void isor_reader_get_sample(ISOMChannel *ch)\n{\n\tGF_Err e;\n\tBool skip_sample=GF_FALSE;\n\tu32 sample_desc_index;\n\tif (ch->sample) return;\n\n\tif (ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tif (!ch->owner->nodata)\n\t\t\tgf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);\n\t\tch->next_track = 0;\n\t}\n\n\tif (ch->to_init) {\n\t\tif (!ch->owner->nodata)\n\t\t\tgf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);\n\t\tinit_reader(ch);\n\t\tsample_desc_index = ch->last_sample_desc_index;\n\t} else if (ch->speed < 0) {\n\t\tif (ch->last_state == GF_EOS) {\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->static_sample->IsRAP) {\n\t\t\tch->last_rap_sample_time = ch->sample_time;\n\t\t}\n\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\tch->static_sample->alloc_size = 0;\n\n\t\tif ((e==GF_EOS) || (ch->static_sample->IsRAP)) {\n\t\t\tif (!ch->last_rap_sample_time) {\n\t\t\t\te = GF_EOS;\n\t\t\t} else {\n\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tif ((e==GF_EOS) && !ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\t\tch->sample = ch->static_sample;\n\n\t\tif (ch->sample->DTS == ch->sample_time) {\n\t\t\tif (!ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\tif (ch->sample) {\n\t\t\tch->sample_time = ch->sample->DTS;\n\t\t}\n\n\t} else if (ch->has_edit_list) {\n\t\tu32 prev_sample = ch->sample_num;\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\tch->static_sample->alloc_size = 0;\n\n\t\tif (e == GF_OK) {\n\t\t\tch->sample = ch->static_sample;\n\n\t\t\t/*we are in forced seek mode: fetch all samples before the one matching the sample time*/\n\t\t\tif (ch->edit_sync_frame) {\n\t\t\t\tch->edit_sync_frame++;\n\t\t\t\tif (ch->edit_sync_frame < ch->sample_num) {\n\t\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t\t\tif (ch->sample) {\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch->edit_sync_frame = 0;\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*if we get the same sample, figure out next interesting time (current sample + DTS gap to next sample should be a good bet)*/\n\t\t\t\tif (prev_sample == ch->sample_num) {\n\t\t\t\t\tif (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {\n\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 sample_num = ch->sample_num ? ch->sample_num : 1;\n\n\t\t\t\t\t\tif (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {\n\t\t\t\t\t\t\t//e = GF_EOS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tu32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);\n\t\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\t\tif (ch->sample_num == prev_sample) {\n\t\t\t\t\t\t\t\t\tch->sample_time += time_diff;\n\t\t\t\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*we jumped to another segment - if RAP is needed look for closest rap in decoding order and\n\t\t\t\tforce seek mode*/\n\t\t\t\tif (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {\n\t\t\t\t\tGF_ISOSample *found = ch->static_sample;\n\t\t\t\t\tu32 samp_num = ch->sample_num;\n\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\tch->sample = (e == GF_OK) ? ch->static_sample : NULL;\n\n\t\t\t\t\t/*if no sync point in the past, use the first non-sync for the given time*/\n\t\t\t\t\tif (!ch->sample || !ch->sample->data) {\n\t\t\t\t\t\tch->sample = ch->static_sample = found;\n\t\t\t\t\t\tch->sample_time = ch->sample->DTS;\n\t\t\t\t\t\tch->sample_num = samp_num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBool do_fetch = GF_TRUE;\n\t\tch->sample_num++;\n\t\tif (ch->sample_last && (ch->sample_last<ch->sample_num)) {\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->sap_only) {\n\t\t\tBool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);\n\t\t\tif (!is_rap) {\n\t\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);\n\t\t\t\tif (roll_type) is_rap = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!is_rap) {\n\t\t\t\tdo_fetch = GF_FALSE;\n\t\t\t} else if (ch->sap_only==2) {\n\t\t\t\tch->sap_only = 0;\n\t\t\t}\n\t\t}\n\t\tif (do_fetch) {\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\t/*if sync shadow / carousel RAP skip*/\n\t\t\tif (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {\n\t\t\t\tch->sample = NULL;\n\t\t\t\tch->sample_num++;\n\t\t\t\tif (ch->pck) {\n\t\t\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\t\t\tch->pck = NULL;\n\t\t\t\t\tch->static_sample->alloc_size = ch->static_sample->dataLength = 0;\n\t\t\t\t}\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tskip_sample = GF_TRUE;\n\t\t}\n\t}\n\n\t//check scalable track change\n\tif (ch->sample && ch->sample->IsRAP && ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t\tch->sample = NULL;\n\t\tif (ch->pck) {\n\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\tch->pck = NULL;\n\t\t}\n\t\tisor_reader_get_sample(ch);\n\t\treturn;\n\t}\n\n\tif (!ch->sample) {\n\t\tu32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);\n\t\tch->sample_data_offset = 0;\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t\tif (ch->owner->mem_load_mode==2)\n\t\t\t\tch->owner->force_fetch = GF_TRUE;\n\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\tif (!ch->has_edit_list && ch->sample_num)\n\t\t\t\t\tch->sample_num--;\n\t\t\t} else {\n\t\t\t\tif (ch->to_init && ch->sample_num) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\", ch->sample_num, ch->track));\n\t\t\t\t\tch->last_state = GF_ISOM_INVALID_FILE;\n\t\t\t\t} else {\n\t\t\t\t\tif (!ch->eos_sent) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] File truncated, aborting read for track %d\\n\", ch->track));\n\t\t\t\t\t}\n\t\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!ch->sample_num\n\t\t         || ((ch->speed >= 0) && (ch->sample_num >= sample_count))\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t         || ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))\n#endif\n\t\t) {\n\n\t\t\tif (ch->owner->frag_type==1) {\n\t\t\t\t/*if sample cannot be found and file is fragmented, rewind sample*/\n\t\t\t\tif (ch->sample_num) ch->sample_num--;\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t} else if (ch->last_state != GF_EOS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d end of stream reached\\n\", ch->track));\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t} else {\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t}\n\t\t} else if (!skip_sample) {\n\t\t\te = gf_isom_last_error(ch->owner->mov);\n\t\t\tGF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));\n\n\t\t\tif ((e<GF_OK) && (e!=GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t//first sample fetched has DTS, we have a tfdt so ignore the hinted one\n\tif ((ch->sample_num==1) && ch->hint_first_tfdt && ch->sample->DTS) {\n\t\tch->hint_first_tfdt = 0;\n\t}\n\tch->sample->DTS += ch->hint_first_tfdt;\n\n\tif (sample_desc_index != ch->last_sample_desc_index) {\n\t\tif (!ch->owner->stsd) {\n\t\t\t//we used sample entry 1 by default to setup, if no active prev sample (edit list might trigger this)\n\t\t\t//and new sample desc is 1, do not reconfigure\n\t\t\tif (!ch->last_sample_desc_index && (sample_desc_index==1)) {\n\n\t\t\t} else {\n\t\t\t\tch->needs_pid_reconfig = 1;\n\t\t\t}\n\t\t}\n\t\tch->last_sample_desc_index = sample_desc_index;\n\t}\n\n\tch->last_state = GF_OK;\n\n\tch->sap_3 = GF_FALSE;\n\tch->sap_4_type = 0;\n\tch->roll = 0;\n\n\tif (ch->sample) {\n\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);\n\n\t\t/*still seeking or not ?\n\t\t 1- when speed is negative, the RAP found is \"after\" the seek point in playback order since we used backward RAP search: nothing to do\n\t\t 2- otherwise set DTS+CTS to start value\n\t\t */\n\t\tif ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {\n\t\t\tch->dts = ch->sample->DTS;\n\t\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\t\tch->seek_flag = 0;\n\t\t} else {\n\t\t\tch->cts = ch->start;\n\t\t\tch->seek_flag = 1;\n\t\t\tch->dts = ch->start;\n\t\t}\n\n\t\tif (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->sample->duration)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] End of Channel \"LLD\" (CTS \"LLD\")\\n\", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else {\n\t\tch->sender_ntp = ch->ntp_at_server_ntp = 0;\n\t}\n\n\tif (!ch->sample_num) return;\n\n\tgf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);\n\n\tif (ch->is_encrypted) {\n\t\t/*in case of CENC: we write sample auxiliary information to slh->sai; its size is in saiz*/\n\t\tif (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tisor_update_cenc_info(ch, GF_FALSE);\n\n\t\t} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tch->pck_encrypted = GF_TRUE;\n\t\t} else {\n\t\t\tch->pck_encrypted = GF_FALSE;\n\t\t}\n\t}\n\tif (ch->sample && ch->sample->nb_pack)\n\t\tch->sample_num += ch->sample->nb_pack-1;\n}", "target": 0}
{"idx": 28, "func": "static int create_spawnproc(h2o_configurator_command_t *cmd, yoml_t *node, const char *dirname, char *const *argv,\n                            struct sockaddr_un *sa, struct passwd *pw)\n{\n    int ret, listen_fd = -1, pipe_fds[2] = {-1, -1};\n\n    /* build socket path */\n    sa->sun_family = AF_UNIX;\n    ret = snprintf(sa->sun_path, sizeof(sa->sun_path), \"%s/_\", dirname);\n    if (ret < 0 || ret >= sizeof(sa->sun_path)) {\n        h2o_configurator_errprintf(cmd, node, \"unix socket path too long: %s\", dirname);\n        goto Error;\n    }\n\n    /* create socket */\n    if ((listen_fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n        h2o_configurator_errprintf(cmd, node, \"socket(2) failed: %s\", strerror(errno));\n        goto Error;\n    }\n    if (bind(listen_fd, (void *)sa, sizeof(*sa)) != 0) {\n        h2o_configurator_errprintf(cmd, node, \"bind(2) failed: %s\", strerror(errno));\n        goto Error;\n    }\n    if (listen(listen_fd, H2O_SOMAXCONN) != 0) {\n        h2o_configurator_errprintf(cmd, node, \"listen(2) failed: %s\", strerror(errno));\n        goto Error;\n    }\n    /* change ownership of socket */\n    if (pw != NULL && chown(sa->sun_path, pw->pw_uid, pw->pw_gid) != 0) {\n        h2o_configurator_errprintf(cmd, node, \"chown(2) failed to change ownership of socket:%s:%s\", sa->sun_path, strerror(errno));\n        goto Error;\n    }\n\n    /* create pipe which is used to notify the termination of the server */\n    if (pipe(pipe_fds) != 0) {\n        h2o_configurator_errprintf(cmd, node, \"pipe(2) failed: %s\", strerror(errno));\n        pipe_fds[0] = -1;\n        pipe_fds[1] = -1;\n        goto Error;\n    }\n    if (fcntl(pipe_fds[1], F_SETFD, FD_CLOEXEC) < 0)\n        goto Error;\n\n    /* spawn */\n    int mapped_fds[] = {listen_fd, 0,   /* listen_fd to 0 */\n                        pipe_fds[0], 5, /* pipe_fds[0] to 5 */\n                        -1};\n    pid_t pid = h2o_spawnp(argv[0], argv, mapped_fds, 0);\n    if (pid == -1) {\n        h2o_error_printf(\"[lib/handler/fastcgi.c] failed to launch helper program %s:%s\\n\", argv[0], strerror(errno));\n        goto Error;\n    }\n\n    close(listen_fd);\n    listen_fd = -1;\n    close(pipe_fds[0]);\n    pipe_fds[0] = -1;\n\n    return pipe_fds[1];\n\nError:\n    if (pipe_fds[0] != -1)\n        close(pipe_fds[0]);\n    if (pipe_fds[1])\n        close(pipe_fds[1]);\n    if (listen_fd != -1)\n        close(listen_fd);\n    unlink(sa->sun_path);\n    return -1;\n}", "target": 1}
{"idx": 29, "func": "static int create_spawnproc(h2o_configurator_command_t *cmd, yoml_t *node, const char *dirname, char *const *argv,\n                            struct sockaddr_un *sa, struct passwd *pw)\n{\n    int ret, listen_fd = -1, pipe_fds[2] = {-1, -1};\n\n    /* build socket path */\n    sa->sun_family = AF_UNIX;\n    ret = snprintf(sa->sun_path, sizeof(sa->sun_path), \"%s/_\", dirname);\n    if (ret < 0 || ret >= sizeof(sa->sun_path)) {\n        h2o_configurator_errprintf(cmd, node, \"unix socket path too long: %s\", dirname);\n        goto Error;\n    }\n\n    /* create socket */\n    if ((listen_fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n        h2o_configurator_errprintf(cmd, node, \"socket(2) failed: %s\", strerror(errno));\n        goto Error;\n    }\n    if (bind(listen_fd, (void *)sa, sizeof(*sa)) != 0) {\n        h2o_configurator_errprintf(cmd, node, \"bind(2) failed: %s\", strerror(errno));\n        goto Error;\n    }\n    if (listen(listen_fd, H2O_SOMAXCONN) != 0) {\n        h2o_configurator_errprintf(cmd, node, \"listen(2) failed: %s\", strerror(errno));\n        goto Error;\n    }\n    /* change ownership of socket */\n    if (pw != NULL && chown(sa->sun_path, pw->pw_uid, pw->pw_gid) != 0) {\n        h2o_configurator_errprintf(cmd, node, \"chown(2) failed to change ownership of socket:%s:%s\", sa->sun_path, strerror(errno));\n        goto Error;\n    }\n\n    /* create pipe which is used to notify the termination of the server */\n    if (pipe(pipe_fds) != 0) {\n        h2o_configurator_errprintf(cmd, node, \"pipe(2) failed: %s\", strerror(errno));\n        pipe_fds[0] = -1;\n        pipe_fds[1] = -1;\n        goto Error;\n    }\n    if (fcntl(pipe_fds[1], F_SETFD, FD_CLOEXEC) < 0)\n        goto Error;\n\n    /* spawn, mapping listen_fd to fd 0, read-side of the pipe to fd 5 */\n    int mapped_fds[] = {listen_fd, 0, -1, -1, -1};\n    if (pipe_fds[0] != 5) {\n        mapped_fds[2] = pipe_fds[0];\n        mapped_fds[3] = 5;\n    }\n    pid_t pid = h2o_spawnp(argv[0], argv, mapped_fds, 0);\n    if (pid == -1) {\n        h2o_error_printf(\"[lib/handler/fastcgi.c] failed to launch helper program %s:%s\\n\", argv[0], strerror(errno));\n        goto Error;\n    }\n\n    close(listen_fd);\n    listen_fd = -1;\n    close(pipe_fds[0]);\n    pipe_fds[0] = -1;\n\n    return pipe_fds[1];\n\nError:\n    if (pipe_fds[0] != -1)\n        close(pipe_fds[0]);\n    if (pipe_fds[1])\n        close(pipe_fds[1]);\n    if (listen_fd != -1)\n        close(listen_fd);\n    unlink(sa->sun_path);\n    return -1;\n}", "target": 0}
{"idx": 30, "func": "static int on_config_exit(h2o_configurator_t *_self, h2o_configurator_context_t *ctx, yoml_t *node)\n{\n    struct headers_configurator_t *self = (void *)_self;\n\n    if (ctx->pathconf != NULL && *self->cmds != NULL) {\n        if (*self->cmds != NULL)\n            h2o_mem_addref_shared(*self->cmds);\n        h2o_headers_register(ctx->pathconf, *self->cmds);\n    }\n\n    if (*self->cmds != NULL)\n        h2o_mem_release_shared(*self->cmds);\n    --self->cmds;\n    return 0;\n}", "target": 1}
{"idx": 31, "func": "static int on_config_exit(h2o_configurator_t *_self, h2o_configurator_context_t *ctx, yoml_t *node)\n{\n    struct headers_configurator_t *self = (void *)_self;\n\n    if (ctx->pathconf != NULL && !h2o_configurator_at_extension_level(ctx) && *self->cmds != NULL) {\n        if (*self->cmds != NULL)\n            h2o_mem_addref_shared(*self->cmds);\n        h2o_headers_register(ctx->pathconf, *self->cmds);\n    }\n\n    if (*self->cmds != NULL)\n        h2o_mem_release_shared(*self->cmds);\n    --self->cmds;\n    return 0;\n}", "target": 0}
{"idx": 32, "func": "DEFINE_2ARG(on_config_header_add, H2O_HEADERS_CMD_ADD)\nDEFINE_2ARG(on_config_header_append, H2O_HEADERS_CMD_APPEND)\nDEFINE_2ARG(on_config_header_merge, H2O_HEADERS_CMD_MERGE)\nDEFINE_2ARG(on_config_header_set, H2O_HEADERS_CMD_SET)\nDEFINE_2ARG(on_config_header_setifempty, H2O_HEADERS_CMD_SETIFEMPTY)\n\n#undef DEFINE_2ARG\n\nvoid h2o_configurator_define_headers_commands(h2o_globalconf_t *global_conf, h2o_configurator_t *conf, const char *prefix,\n                                              h2o_configurator_get_headers_commands_cb get_commands)\n{\n    struct headers_util_configurator_t *c = (void *)h2o_configurator_create(global_conf, sizeof(*c));\n    c->child = conf;\n    c->get_commands = get_commands;\n    size_t prefix_len = strlen(prefix);\n\n#define DEFINE_CMD_NAME(name, suffix)                                                                                              \\\n    char *name = h2o_mem_alloc(prefix_len + sizeof(suffix));                                                                       \\\n    memcpy(name, prefix, prefix_len);                                                                                              \\\n    memcpy(name + prefix_len, suffix, sizeof(suffix))\n\n    DEFINE_CMD_NAME(add_directive, \".add\");\n    DEFINE_CMD_NAME(append_directive, \".append\");\n    DEFINE_CMD_NAME(merge_directive, \".merge\");\n    DEFINE_CMD_NAME(set_directive, \".set\");\n    DEFINE_CMD_NAME(setifempty_directive, \".setifempty\");\n    DEFINE_CMD_NAME(unset_directive, \".unset\");\n    DEFINE_CMD_NAME(unsetunless_directive, \".unsetunless\");\n    DEFINE_CMD_NAME(cookie_unset_directive, \".cookie.unset\");\n    DEFINE_CMD_NAME(cookie_unsetunless_directive, \".cookie.unsetunless\");\n#undef DEFINE_CMD_NAME\n\n#define DEFINE_CMD(name, cb)                                                                                                       \\\n    h2o_configurator_define_command(&c->super, name,                                                                               \\\n                                    H2O_CONFIGURATOR_FLAG_ALL_LEVELS | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR |                       \\\n                                        H2O_CONFIGURATOR_FLAG_EXPECT_SEQUENCE | H2O_CONFIGURATOR_FLAG_EXPECT_MAPPING,              \\\n                                    cb)\n    DEFINE_CMD(add_directive, on_config_header_add);\n    DEFINE_CMD(append_directive, on_config_header_append);\n    DEFINE_CMD(merge_directive, on_config_header_merge);\n    DEFINE_CMD(set_directive, on_config_header_set);\n    DEFINE_CMD(setifempty_directive, on_config_header_setifempty);\n    DEFINE_CMD(unset_directive, on_config_header_unset);\n    DEFINE_CMD(unsetunless_directive, on_config_header_unsetunless);\n    DEFINE_CMD(cookie_unset_directive, on_config_cookie_unset);\n    DEFINE_CMD(cookie_unsetunless_directive, on_config_cookie_unsetunless);\n#undef DEFINE_CMD\n}", "target": 1}
{"idx": 33, "func": "DEFINE_2ARG(on_config_header_add, H2O_HEADERS_CMD_ADD)\nDEFINE_2ARG(on_config_header_append, H2O_HEADERS_CMD_APPEND)\nDEFINE_2ARG(on_config_header_merge, H2O_HEADERS_CMD_MERGE)\nDEFINE_2ARG(on_config_header_set, H2O_HEADERS_CMD_SET)\nDEFINE_2ARG(on_config_header_setifempty, H2O_HEADERS_CMD_SETIFEMPTY)\n\n#undef DEFINE_2ARG\n\nvoid h2o_configurator_define_headers_commands(h2o_globalconf_t *global_conf, h2o_configurator_t *conf, const char *prefix,\n                                              h2o_configurator_get_headers_commands_cb get_commands)\n{\n    struct headers_util_configurator_t *c = (void *)h2o_configurator_create(global_conf, sizeof(*c));\n    c->child = conf;\n    c->get_commands = get_commands;\n    size_t prefix_len = strlen(prefix);\n\n#define DEFINE_CMD_NAME(name, suffix)                                                                                              \\\n    char *name = h2o_mem_alloc(prefix_len + sizeof(suffix));                                                                       \\\n    memcpy(name, prefix, prefix_len);                                                                                              \\\n    memcpy(name + prefix_len, suffix, sizeof(suffix))\n\n    DEFINE_CMD_NAME(add_directive, \".add\");\n    DEFINE_CMD_NAME(append_directive, \".append\");\n    DEFINE_CMD_NAME(merge_directive, \".merge\");\n    DEFINE_CMD_NAME(set_directive, \".set\");\n    DEFINE_CMD_NAME(setifempty_directive, \".setifempty\");\n    DEFINE_CMD_NAME(unset_directive, \".unset\");\n    DEFINE_CMD_NAME(unsetunless_directive, \".unsetunless\");\n    DEFINE_CMD_NAME(cookie_unset_directive, \".cookie.unset\");\n    DEFINE_CMD_NAME(cookie_unsetunless_directive, \".cookie.unsetunless\");\n#undef DEFINE_CMD_NAME\n\n#define DEFINE_CMD(name, cb)                                                                                                       \\\n    h2o_configurator_define_command(&c->super, name,                                                                               \\\n                                    H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_PATH |       \\\n                                        H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR | H2O_CONFIGURATOR_FLAG_EXPECT_SEQUENCE |              \\\n                                        H2O_CONFIGURATOR_FLAG_EXPECT_MAPPING,                                                      \\\n                                    cb)\n    DEFINE_CMD(add_directive, on_config_header_add);\n    DEFINE_CMD(append_directive, on_config_header_append);\n    DEFINE_CMD(merge_directive, on_config_header_merge);\n    DEFINE_CMD(set_directive, on_config_header_set);\n    DEFINE_CMD(setifempty_directive, on_config_header_setifempty);\n    DEFINE_CMD(unset_directive, on_config_header_unset);\n    DEFINE_CMD(unsetunless_directive, on_config_header_unsetunless);\n    DEFINE_CMD(cookie_unset_directive, on_config_cookie_unset);\n    DEFINE_CMD(cookie_unsetunless_directive, on_config_cookie_unsetunless);\n#undef DEFINE_CMD\n}", "target": 0}
{"idx": 34, "func": "static int delegate_dynamic_request(h2o_req_t *req, h2o_iovec_t script_name, h2o_iovec_t path_info, const char *local_path,\n                                    size_t local_path_len, h2o_mimemap_type_t *mime_type)\n{\n    h2o_filereq_t *filereq;\n    h2o_handler_t *handler;\n\n    assert(mime_type->data.dynamic.pathconf.handlers.size == 1);\n\n    filereq = h2o_mem_alloc_pool(&req->pool, *filereq, 1);\n    filereq->script_name = script_name;\n    filereq->path_info = path_info;\n    filereq->local_path = h2o_strdup(&req->pool, local_path, local_path_len);\n\n    h2o_req_bind_conf(req, req->hostconf, &mime_type->data.dynamic.pathconf);\n    req->filereq = filereq;\n\n    handler = mime_type->data.dynamic.pathconf.handlers.entries[0];\n    return handler->on_req(handler, req);\n}", "target": 1}
{"idx": 35, "func": "static int delegate_dynamic_request(h2o_req_t *req, h2o_iovec_t script_name, h2o_iovec_t path_info, const char *local_path,\n                                    size_t local_path_len, h2o_mimemap_type_t *mime_type)\n{\n    h2o_filereq_t *filereq;\n\n    assert(mime_type->data.dynamic.pathconf.handlers.size == 1);\n    assert(mime_type->data.dynamic.pathconf._filters.size == 0);\n    assert(mime_type->data.dynamic.pathconf._loggers.size == 0);\n\n    /* setup CGI attributes (e.g., PATH_INFO) */\n    filereq = h2o_mem_alloc_pool(&req->pool, *filereq, 1);\n    filereq->script_name = script_name;\n    filereq->path_info = path_info;\n    filereq->local_path = h2o_strdup(&req->pool, local_path, local_path_len);\n    req->filereq = filereq;\n\n    /* apply environment */\n    if (mime_type->data.dynamic.pathconf.env != NULL)\n        h2o_req_apply_env(req, mime_type->data.dynamic.pathconf.env);\n\n    /* call the dynamic handler while retaining current hostconf or pathconf; in other words, filters and loggers of current\n     * path level is applied, rather than of the extension level */\n    h2o_handler_t *handler = mime_type->data.dynamic.pathconf.handlers.entries[0];\n    return handler->on_req(handler, req);\n}", "target": 0}
{"idx": 36, "func": "int LibRaw::phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, sum;\n#if 0\n  int val[4], dev[4], max;\n#endif\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {\n      {-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n      {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n  std::vector<unsigned> badCols;\n\n  if (!meta_length)\n    return 0;\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n  try\n  {\n    while (entries--)\n    {\n      checkCancel();\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n#if 1\n\t  if (ifp->eof())\n\t  {\n\t\t  // skip bad or unknown tag\n\t\t  fseek(ifp, save, SEEK_SET);\n\t\t  continue;\n\t  }\n#endif\n      if (tag == 0x0400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n#if 0\n            // Original code by Dave Coffin - it works better by\n            // not employing special logic for G1 channel below.\n            // Alternatively this column remap (including G1 channel\n            // logic) should be called prior to black subtraction\n            // unlike other corrections\n            for (row = 0; row < raw_height; row++)\n            {\n              if (FC(row - top_margin, col - left_margin)==1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = p1raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += p1raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) =\n                  0.5 + sum * 0.0732233 +\n                  (p1raw(row, col - 2) + p1raw(row, col + 2)) * 0.3535534;\n              }\n            }\n#else\n            // accumulae bad columns to be sorted later\n            badCols.push_back(col);\n#endif\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            unsigned count = 0;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += p1rawc(row + dir[i][0], col + dir[i][1], count);\n            if (count)\n              RAW(row, col) = (sum + (count >> 1)) / count;\n          }\n        }\n      }\n      else if (tag == 0x0419)\n      { /* Polynomial curve - output calibraion */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x041a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x0401)\n      { /* All-color flat fields - luma calibration*/\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x0416 || tag == 0x0410)\n      {\n        // 0x410 - luma calibration\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x040b)\n      { /* Red+blue flat field - croma calibration */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x0412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x041f && !qlin_applied)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n\t\tbool baddiv = false;\n        for (qr = 0; qr < 2; qr++)\n\t\t\tfor (qc = 0; qc < 2; qc++)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\t\tlc[qr][qc][i] = get4();\n\t\t\t\tif (lc[qr][qc][15] == 0)\n\t\t\t\t\tbaddiv = true;\n\t\t\t}\n\t\tif(baddiv)\n\t\t\tcontinue;\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x041e && !qmult_applied)\n      { /* Quadrant multipliers - output calibraion */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= (unsigned)ph1.split_row][col >= (unsigned)ph1.split_col] *\n                RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x0431 && !qmult_applied)\n      { /* Quadrant combined - four tile gain calibration */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (!badCols.empty())\n    {\n      qsort(badCols.data(), badCols.size(), sizeof(unsigned), unsigned_cmp);\n      bool prevIsolated = true;\n      for (i = 0; i < (int)badCols.size(); ++i)\n      {\n        bool nextIsolated = i == ((int)(badCols.size()-1)) || badCols[i+1]>badCols[i]+4;\n        for (row = 0; row < raw_height; ++row)\n          if (prevIsolated && nextIsolated)\n            phase_one_fix_pixel_grad(row,badCols[i]);\n          else\n            phase_one_fix_col_pixel_avg(row,badCols[i]);\n        prevIsolated = nextIsolated;\n      }\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n        checkCancel();\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n            frac = (j == 0 || j == head[1])\n                       ? 0\n                       : (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]);\n            mult[i - cip] = yval[0][k - 1] * frac + yval[0][k] * (1 - frac);\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n  return 0;\n}", "target": 1}
{"idx": 37, "func": "int LibRaw::phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, sum;\n#if 0\n  int val[4], dev[4], max;\n#endif\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {\n      {-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n      {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n  std::vector<unsigned> badCols;\n\n  if (!meta_length)\n    return 0;\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n  try\n  {\n    while (entries--)\n    {\n      checkCancel();\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n#if 1\n\t  if (ifp->eof())\n\t  {\n\t\t  // skip bad or unknown tag\n\t\t  fseek(ifp, save, SEEK_SET);\n\t\t  continue;\n\t  }\n#endif\n      if (tag == 0x0400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n#if 0\n            // Original code by Dave Coffin - it works better by\n            // not employing special logic for G1 channel below.\n            // Alternatively this column remap (including G1 channel\n            // logic) should be called prior to black subtraction\n            // unlike other corrections\n            for (row = 0; row < raw_height; row++)\n            {\n              if (FC(row - top_margin, col - left_margin)==1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = p1raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += p1raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) =\n                  0.5 + sum * 0.0732233 +\n                  (p1raw(row, col - 2) + p1raw(row, col + 2)) * 0.3535534;\n              }\n            }\n#else\n            // accumulae bad columns to be sorted later\n            badCols.push_back(col);\n#endif\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            unsigned count = 0;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += p1rawc(row + dir[i][0], col + dir[i][1], count);\n            if (count)\n              RAW(row, col) = (sum + (count >> 1)) / count;\n          }\n        }\n      }\n      else if (tag == 0x0419)\n      { /* Polynomial curve - output calibraion */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x041a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x0401)\n      { /* All-color flat fields - luma calibration*/\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x0416 || tag == 0x0410)\n      {\n        // 0x410 - luma calibration\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x040b)\n      { /* Red+blue flat field - croma calibration */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x0412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x041f && !qlin_applied)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n\t\tbool baddiv = false;\n        for (qr = 0; qr < 2; qr++)\n\t\t\tfor (qc = 0; qc < 2; qc++)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\t\tlc[qr][qc][i] = get4();\n\t\t\t\tif (lc[qr][qc][15] == 0)\n\t\t\t\t\tbaddiv = true;\n\t\t\t}\n\t\tif(baddiv)\n\t\t\tcontinue;\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x041e && !qmult_applied)\n      { /* Quadrant multipliers - output calibraion */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= (unsigned)ph1.split_row][col >= (unsigned)ph1.split_col] *\n                RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x0431 && !qmult_applied)\n      { /* Quadrant combined - four tile gain calibration */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (!badCols.empty())\n    {\n      qsort(badCols.data(), badCols.size(), sizeof(unsigned), unsigned_cmp);\n      bool prevIsolated = true;\n      for (i = 0; i < (int)badCols.size(); ++i)\n      {\n        bool nextIsolated = i == ((int)(badCols.size()-1)) || badCols[i+1]>badCols[i]+4;\n        for (row = 0; row < raw_height; ++row)\n          if (prevIsolated && nextIsolated)\n            phase_one_fix_pixel_grad(row,badCols[i]);\n          else\n            phase_one_fix_col_pixel_avg(row,badCols[i]);\n        prevIsolated = nextIsolated;\n      }\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n\t  unsigned w0 = head[1] * head[3], w1 = head[2] * head[4];\n\t  if (w0 > 10240000 || w1 > 10240000)\n\t\t  throw LIBRAW_EXCEPTION_ALLOC;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n        checkCancel();\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n\t\t\tif (j == 0 || j == head[1] || k < 1 || k >= w0+w1)\n\t\t\t\tfrac = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint xdiv = (xval[0][k] - xval[0][k - 1]);\n\t\t\t\tfrac = xdiv ? (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]) : 0;\n\t\t\t}\n\t\t\tif (k < w0 + w1)\n\t\t\t\tmult[i - cip] = yval[0][k > 0 ? k - 1 : 0] * frac + yval[0][k] * (1 - frac);\n\t\t\telse\n\t\t\t\tmult[i - cip] = 0;\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n  return 0;\n}", "target": 0}
{"idx": 38, "func": "int LibRaw::parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save, utmp;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n\n  ushort *rafdata;\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n\n  if (libraw_internal_data.unpacker_data.ifd0_offset == -1LL)\n    libraw_internal_data.unpacker_data.ifd0_offset = base;\n\n  entries = get2();\n  if (entries > 512)\n    return 1;\n\n  INT64 fsize = ifp->size();\n\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && savepos + len > 2 * fsize)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data,\n                        tag | (is_pana_raw ? 0x30000 : ((ifd + 1) << 20)), type,\n                        len, order, ifp, base);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n\n    if (!is_pana_raw)\n    { /* processing of EXIF tags that collide w/ PanasonicRaw tags */\n      switch (tag)\n      {\n      case 0x0001:\n        if (len == 4)\n          is_pana_raw = get4();\n        break;\n      case 0x000b: /* 11, Std. EXIF Software tag */\n        fgets(software, 64, ifp);\n        if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) ||\n            !strncmp(software, \"UFRaw\", 5) || !strncmp(software, \"Bibble\", 6) ||\n            !strcmp(software, \"Digital Photo Professional\"))\n          is_raw = 0;\n        break;\n      case 0x001c: /*  28, safeguard, probably not needed */\n      case 0x001d: /*  29, safeguard, probably not needed */\n      case 0x001e: /*  30, safeguard, probably not needed */\n        cblack[tag - 0x001c] = get2();\n        cblack[3] = cblack[1];\n        break;\n\n      case 0x0111: /* 273, StripOffset */\n        if (len > 1 && len < 16384)\n        {\n          off_t sav = ftell(ifp);\n          tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n          tiff_ifd[ifd].strip_offsets_count = len;\n          for (int ii = 0; ii < (int)len; ii++)\n            tiff_ifd[ifd].strip_offsets[ii] = get4() + base;\n          fseek(ifp, sav, SEEK_SET); // restore position\n        }\n        /* fallback */\n      case 0x0201: /* 513, JpegIFOffset */\n      case 0xf007: // 61447\n        tiff_ifd[ifd].offset = get4() + base;\n        if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n        {\n          fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n          if (ljpeg_start(&jh, 1))\n          {\n            if (!dng_version && !strcasecmp(make, \"SONY\") && tiff_ifd[ifd].phint == 32803 &&\n                tiff_ifd[ifd].comp == 7) // Sony/lossless compressed IFD\n            {\n              tiff_ifd[ifd].comp = 6;\n              tiff_ifd[ifd].bps = jh.bits;\n              tiff_ifd[ifd].samples = 1;\n            }\n            else\n            {\n              tiff_ifd[ifd].comp = 6;\n              tiff_ifd[ifd].bps = jh.bits;\n              tiff_ifd[ifd].t_width = jh.wide;\n              tiff_ifd[ifd].t_height = jh.high;\n              tiff_ifd[ifd].samples = jh.clrs;\n              if (!(jh.sraw || (jh.clrs & 1)))\n                tiff_ifd[ifd].t_width *= jh.clrs;\n              if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n              {\n                tiff_ifd[ifd].t_width /= 2;\n                tiff_ifd[ifd].t_height *= 2;\n              }\n              i = order;\n              parse_tiff(tiff_ifd[ifd].offset + 12);\n              order = i;\n            }\n          }\n        }\n        break;\n      }\n    }\n    else\n    { /* processing Panasonic-specific \"PanasonicRaw\" tags */\n      switch (tag)\n      {\n      case 0x0004: /*   4, SensorTopBorder */\n        imgdata.sizes.raw_inset_crops[0].ctop = get2();\n        break;\n      case 0x000a: /*  10, BitsPerSample */\n        pana_bpp = get2();\n\t\tpana_bpp = LIM(pana_bpp, 8, 16);\n        break;\n      case 0x000b: /*  11, Compression */\n        imPana.Compression = get2();\n        break;\n      case 0x000e: /*  14, LinearityLimitRed */\n      case 0x000f: /*  15, LinearityLimitGreen */\n      case 0x0010: /*  16, LinearityLimitBlue */\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (imgdata.color.linear_max[tag - 14] == 16383)\n            imgdata.color.linear_max[tag - 14] -= 64;\n        if (imgdata.color.linear_max[tag - 14] == 4095)\n          imgdata.color.linear_max[tag - 14] -= 16;\n        if (tag == 0x000f) // 15, LinearityLimitGreen\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        break;\n      case 0x0013: /*  19, WBInfo */\n        if ((i = get2()) > 0x100)\n          break;\n        for (c = 0; c < i; c++)\n        {\n          if ((j = get2()) < 0x100)\n          {\n\t\t\t  if (j >= 0) {\n\t\t\t\t  icWBC[j][0] = get2();\n\t\t\t\t  icWBC[j][2] = get2();\n\t\t\t\t  icWBC[j][1] = icWBC[j][3] =\n\t\t\t\t\t  0x100;\n\t\t\t  }\n          }\n          else // light source out of EXIF numbers range\n            get4();\n        }\n        break;\n      case 0x0018: /* 24, HighISOMultiplierRed */\n      case 0x0019: /* 25, HighISOMultiplierGreen */\n      case 0x001a: /* 26, HighISOMultiplierBlue */\n        imPana.HighISOMultiplier[tag - 0x0018] = get2();\n        break;\n      case 0x001c: /*  28, BlackLevelRed */\n      case 0x001d: /*  29, BlackLevelGreen */\n      case 0x001e: /*  30, BlackLevelBlue */\n        pana_black[tag - 0x001c] = get2();\n        break;\n      case 0x002d: /*  45, RawFormat */\n                   /* pana_encoding: tag 0x002d (45dec)\n                        not used - DMC-LX1/FZ30/FZ50/L1/LX1/LX2\n                        2 - RAW DMC-FZ8/FZ18\n                        3 - RAW DMC-L10\n                        4 - RW2 for most other models, including G9 in \"pixel shift off\"\n                      mode and YUNEEC CGO4            (must add 15 to black levels for\n                      RawFormat == 4)            5 - RW2 DC-GH5s; G9 in \"pixel shift on\"\n                      mode            6 - RW2            DC-S1, DC-S1R in \"pixel shift off\"\n                      mode            7 -            RW2 DC-S1R (probably            DC-S1 too) in\n                      \"pixel shift on\" mode\n                   */\n        pana_encoding = get2();\n        break;\n      case 0x002f: /*  47, CropTop */\n        imgdata.sizes.raw_inset_crops[0].ctop = get2();\n        break;\n      case 0x0030: /*  48, CropLeft */\n        imgdata.sizes.raw_inset_crops[0].cleft = get2();\n        break;\n      case 0x0031: /*  49, CropBottom */\n        imgdata.sizes.raw_inset_crops[0].cheight =\n            get2() - imgdata.sizes.raw_inset_crops[0].ctop;\n        break;\n      case 0x0032: /*  50, CropRight */\n        imgdata.sizes.raw_inset_crops[0].cwidth =\n            get2() - imgdata.sizes.raw_inset_crops[0].cleft;\n        break;\n      case 0x0037: /*  55, ISO if  ISO in 0x8827 & ISO in 0x0017 == 65535 */\n        if (iso_speed == 65535)\n          iso_speed = get4();\n        break;\n      case 0x011c: /* 284, Gamma */\n      {\n        int n = get2();\n        if (n >= 1024)\n          imPana.gamma = (float)n / 1024.0f;\n        else if (n >= 256)\n          imPana.gamma = (float)n / 256.0f;\n        else\n          imPana.gamma = (float)n / 100.0f;\n      }\n      break;\n      case 0x0120: /* 288, CameraIFD, contains tags 0x1xxx, 0x2xxx, 0x3xxx */\n      {\n        unsigned sorder = order;\n        unsigned long sbase = base;\n        base = ftell(ifp);\n        order = get2();\n        fseek(ifp, 2, SEEK_CUR);\n        fseek(ifp, INT64(get4()) - 8LL, SEEK_CUR);\n        parse_tiff_ifd(base);\n        base = sbase;\n        order = sorder;\n      }\n      break;\n      case 0x0121: /* 289, Multishot, 0 is Off, 65536 is Pixel Shift */\n        imPana.Multishot = get4();\n        break;\n      case 0x1001:\n      \tif (imPana.Multishot == 0) {\n      \t  imPana.Multishot = get4();\n      \t  if (imPana.Multishot)\n      \t    imPana.Multishot += 65535;\n      \t}\n        break;\n      case 0x1100:\n        imPana.FocusStepNear = get2();\n        break;\n      case 0x1101:\n        imPana.FocusStepCount = get2();\n        break;\n      case 0x1105:\n        imPana.ZoomPosition = get4();\n        break;\n      case 0x1201:\n        if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT)) {\n          imPana.LensManufacturer = fgetc(ifp);\n        } else if (type == 258) {\n          imPana.LensManufacturer = get4();\n          if (imPana.LensManufacturer >= 257) {\n            ilm.LensMount = LIBRAW_MOUNT_LPS_L;\n            ilm.LensFormat = LIBRAW_FORMAT_FF;\n          }\n        }\n        break;\n      case 0x1202:\n        if (ilm.LensMount == LIBRAW_MOUNT_LPS_L) {\n          if ((utmp = get2())) ilm.LensID = utmp;\n        } else if ((imPana.LensManufacturer != 0xff) &&\n                   (imPana.LensManufacturer != 0xffffffff)) {\n          if ((utmp = (fgetc(ifp) << 8) | fgetc(ifp)))\n            ilm.LensID = (imPana.LensManufacturer << 16) + utmp;\n        }\n        break;\n      case 0x1203: /* 4611, FocalLengthIn35mmFormat, contained in 0x0120\n                      CameraIFD */\n        if (imgdata.lens.FocalLengthIn35mmFormat < 0.65f)\n          imgdata.lens.FocalLengthIn35mmFormat = get2();\n        break;\n      case 0x2009: /* 8201, contained in 0x0120 CameraIFD */\n        if ((pana_encoding == 4) || (pana_encoding == 5))\n        {\n          i = MIN(8, len);\n          int permut[8] = {3, 2, 1, 0, 3 + 4, 2 + 4, 1 + 4, 0 + 4};\n          imPana.BlackLevelDim = len;\n          for (j = 0; j < i; j++)\n          {\n            imPana.BlackLevel[permut[j]] =\n                (float)(get2()) / (float)(powf(2.f, 14.f - pana_bpp));\n          }\n        }\n        break;\n      case 0x3420: /* 13344, WB_RedLevelAuto, contained in 0x0120 CameraIFD */\n        icWBC[LIBRAW_WBI_Auto][0] = get2();\n        icWBC[LIBRAW_WBI_Auto][1] = icWBC[LIBRAW_WBI_Auto][3] = 1024.0f;\n        break;\n      case 0x3421: /* 13345, WB_BlueLevelAuto, contained in 0x0120 CameraIFD */\n        icWBC[LIBRAW_WBI_Auto][2] = get2();\n        break;\n      case 0x0002: /*   2, ImageWidth */\n        tiff_ifd[ifd].t_width = getint(type);\n        break;\n      case 0x0003: /*   3, ImageHeight */\n        tiff_ifd[ifd].t_height = getint(type);\n        break;\n      case 0x0005: /*   5, SensorLeftBorder */\n        width = get2();\n        imgdata.sizes.raw_inset_crops[0].cleft = width;\n        break;\n      case 0x0006: /*   6, SensorBottomBorder */\n        height = get2();\n        imgdata.sizes.raw_inset_crops[0].cheight =\n            height - imgdata.sizes.raw_inset_crops[0].ctop;\n        break;\n      case 0x0007: /*   7, SensorRightBorder */\n        i = get2();\n        width += i;\n        imgdata.sizes.raw_inset_crops[0].cwidth =\n            i - imgdata.sizes.raw_inset_crops[0].cleft;\n        break;\n      case 0x0009: /*   9, CFAPattern */\n        if ((i = get2()))\n          filters = i;\n        break;\n      case 0x0011: /*  17, RedBalance */\n      case 0x0012: /*  18, BlueBalance */\n        if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT) && len == 1)\n          cam_mul[(tag - 0x0011) * 2] = get2() / 256.0;\n        break;\n      case 0x0017: /*  23, ISO */\n        if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT))\n          iso_speed = get2();\n        break;\n      case 0x0024: /*  36, WBRedLevel */\n      case 0x0025: /*  37, WBGreenLevel */\n      case 0x0026: /*  38, WBBlueLevel */\n        cam_mul[tag - 0x0024] = get2();\n        break;\n      case 0x0027: /*  39, WBInfo2 */\n        if ((i = get2()) > 0x100)\n          break;\n        for (c = 0; c < i; c++)\n        {\n          if ((j = get2()) < 0x100)\n          {\n           if(j >= 0) {\n            icWBC[j][0] = get2();\n            icWBC[j][1] = icWBC[j][3] = get2();\n            icWBC[j][2] = get2();\n            if (c == 1 && i > 6 && cam_mul[0] <= 0.001f)\n                for (int q = 0; q < 4; q++)\n                    cam_mul[q] = icWBC[j][q];\n\t   }\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n        break;\n      case 0x002e: /*  46, JpgFromRaw */\n        if ((type != LIBRAW_EXIFTAG_TYPE_UNDEFINED) || (fgetc(ifp) != 0xff) || (fgetc(ifp) != 0xd8))\n          break;\n        thumb_offset = ftell(ifp) - 2;\n        thumb_length = len;\n        break;\n\n      case 0x0118: /* 280, Panasonic RW2 offset */\n        if (type != LIBRAW_EXIFTAG_TYPE_LONG)\n          break;\n        load_raw = &LibRaw::panasonic_load_raw;\n        load_flags = 0x2008;\n      case 0x0111: /* 273, StripOffset */\n        if (len > 1 && len < 16384)\n        {\n          off_t sav = ftell(ifp);\n          tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n          tiff_ifd[ifd].strip_offsets_count = len;\n          for (int ii = 0; ii < (int)len; ii++)\n            tiff_ifd[ifd].strip_offsets[ii] = get4() + base;\n          fseek(ifp, sav, SEEK_SET); // restore position\n        }\n        /* fallthrough */\n        tiff_ifd[ifd].offset = get4() + base;\n        if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n        {\n          fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n          if (ljpeg_start(&jh, 1))\n          {\n            tiff_ifd[ifd].comp = 6;\n            tiff_ifd[ifd].t_width = jh.wide;\n            tiff_ifd[ifd].t_height = jh.high;\n            tiff_ifd[ifd].bps = jh.bits;\n            tiff_ifd[ifd].samples = jh.clrs;\n            if (!(jh.sraw || (jh.clrs & 1)))\n              tiff_ifd[ifd].t_width *= jh.clrs;\n            if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n            {\n              tiff_ifd[ifd].t_width /= 2;\n              tiff_ifd[ifd].t_height *= 2;\n            }\n            i = order;\n            parse_tiff(tiff_ifd[ifd].offset + 12);\n            order = i;\n          }\n        }\n        break;\n      }\n\n    } /* processing of Panasonic-specific tags finished */\n\n    switch (tag)\n    {            /* processing of general EXIF tags */\n    case 0xf000: /* 61440, Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 0x00fe: /* NewSubfileType */\n      tiff_ifd[ifd].newsubfiletype = getreal(type);\n      break;\n    case 0x0100: /* 256, ImageWidth */\n    case 0xf001: /* 61441, Fuji RAF RawImageFullWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 0x0101: /* 257, ImageHeight */\n    case 0xf002: /* 61442, Fuji RAF RawImageFullHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 0x0102: /* 258, BitsPerSample */\n    case 0xf003: /* 61443, Fuji RAF 0xf003 */\n      if(!tiff_ifd[ifd].samples || tag != 0x0102) // ??? already set by tag 0x115\n        tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < (unsigned)tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 0xf006: /* 61446, Fuji RAF 0xf006 */\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &LibRaw::packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 0x0103: /* 259, Compression */\n                 /*\n                    262\t = Kodak 262\n                  32767  = Sony ARW Compressed\n                  32769  = Packed RAW\n                  32770  = Samsung SRW Compressed\n                  32772  = Samsung SRW Compressed 2\n                  32867  = Kodak KDC Compressed\n                  34713  = Nikon NEF Compressed\n                  65000  = Kodak DCR Compressed\n                  65535  = Pentax PEF Compressed\n                 */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 0x0106: /* 262, PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 0x010e: /* 270, ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 0x010f: /* 271, Make */\n      fgets(make, 64, ifp);\n      break;\n    case 0x0110: /* 272, Model */\n      if (!strncmp(make, \"Hasselblad\", 10) && model[0] &&\n          (imHassy.format != LIBRAW_HF_Imacon))\n        break;\n      fgets(model, 64, ifp);\n      break;\n    case 0x0116: // 278\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n    case 0x0112: /* 274, Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 0x0115: /* 277, SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 0x0152: /* Extrasamples */\n      tiff_ifd[ifd].extrasamples = (getint(type) & 0xff) + 1024;\n      break;\n    case 0x0117: /* 279, StripByteCounts */\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int ii = 0; ii < (int)len; ii++)\n          tiff_ifd[ifd].strip_byte_counts[ii] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n      /* fallback */\n    case 0x0202: // 514\n    case 0xf008: // 61448\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 0xf00e: // 61454, FujiFilm \"As Shot\"\n      FORC3 cam_mul[GRBG_2_RGBG(c)] = getint(type);\n      break;\n    case 0x0131: /* 305, Software */\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) ||\n          !strncmp(software, \"UFRaw\", 5) || !strncmp(software, \"Bibble\", 6) ||\n          !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 0x0132: /* 306, DateTime */\n      get_timestamp(0);\n      break;\n    case 0x013b: /* 315, Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 0x013d: // 317\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 0x0142: /* 322, TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 0x0143: /* 323, TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 0x0144: /* 324, TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &LibRaw::sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 0x0145: // 325\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 0x014a: /* 330, SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &LibRaw::sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n        if (ifd >= int(sizeof tiff_ifd / sizeof tiff_ifd[0]))\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        break;\n      }\n      if (!strncmp(make, \"Hasselblad\", 10) &&\n          libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 0x0153: // 339\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 0x0190: // 400\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n    case 0x02bc: // 700\n      if ((tagtypeIs(LIBRAW_EXIFTAG_TYPE_BYTE) ||\n          tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII) ||\n          tagtypeIs(LIBRAW_EXIFTAG_TYPE_SBYTE) ||\n          tagtypeIs(LIBRAW_EXIFTOOLTAGTYPE_binary)) &&\n          (len > 1) && (len < 5100000))\n      {\n        xmpdata = (char *)calloc(xmplen = len + 1,1);\n        unsigned br = fread(xmpdata,1, len, ifp);\n        xmpdata[br] = 0;\n      }\n      break;\n    case 0x7000:\n      imSony.SonyRawFileType = get2();\n      break;\n    case 0x7010: // 28688\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= (int)sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 0x7200: // 29184, Sony SR2Private\n      sony_offset = get4();\n      break;\n    case 0x7201: // 29185, Sony SR2Private\n      sony_length = get4();\n      break;\n    case 0x7221: // 29217, Sony SR2Private\n      sony_key = get4();\n      break;\n    case 0x7250: // 29264, Sony SR2Private\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 0x7303: // 29443, Sony SR2SubIFD\n      FORC4 cam_mul[GRBG_2_RGBG(c)] = get2();\n      break;\n    case 0x7313: // 29459, Sony SR2SubIFD\n      FORC4 cam_mul[RGGB_2_RGBG(c)] = get2();\n      break;\n    case 0x7310: // 29456, Sony SR2SubIFD\n      FORC4 cblack[RGGB_2_RGBG(c)] = get2();\n      i = cblack[3];\n      FORC3 if (i > (int)cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n      break;\n    case 0x827d: /* 33405, Model2 */\n                 /*\n                  for Kodak ProBack 645 PB645x-yyyy 'x' is:\n                  'M' for Mamiya 645\n                  'C' for Contax 645\n                  'H' for Hasselblad H-series\n                 */\n      fgets(model2, 64, ifp);\n      break;\n    case 0x828d: /* 33421, CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        tiff_ifd[ifd].t_filters = filters = 9;\n      break;\n    case 0x828e: /* 33422, CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 0xfd09: /* 64777, Kodak P-series */\n      if (len == 36)\n      {\n        tiff_ifd[ifd].t_filters = filters = 9;\n        colors = 3;\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < (int)plen && colors < 4; i++)\n        {\n          if (cfa_pat[i] > 31)\n            continue; // Skip wrong data\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 0x8290: // 33424\n    case 0xfe00: // 65024\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 0x829a: /* 33434, ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 0x829d: /* 33437, FNumber */\n      aperture = getreal(type);\n      break;\n    case 0x9400:\n      imCommon.exifAmbientTemperature = getreal(type);\n      if ((imCommon.CameraTemperature > -273.15f) &&\n          ((OlyID == OlyID_TG_5) || (OlyID == OlyID_TG_6)))\n        imCommon.CameraTemperature +=\n            imCommon.exifAmbientTemperature;\n      break;\n    case 0x9401:\n      imCommon.exifHumidity = getreal(type);\n      break;\n    case 0x9402:\n      imCommon.exifPressure = getreal(type);\n      break;\n    case 0x9403:\n      imCommon.exifWaterDepth = getreal(type);\n      break;\n    case 0x9404:\n      imCommon.exifAcceleration = getreal(type);\n      break;\n    case 0x9405:\n      imCommon.exifCameraElevationAngle = getreal(type);\n      break;\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa420: /* 42016, ImageUniqueID */\n      stmread(imgdata.color.ImageUniqueID, len, ifp);\n      break;\n    case 0xc65d: /* 50781, RawDataUniqueID */\n      imgdata.color.RawDataUniqueID[16] = 0;\n      fread(imgdata.color.RawDataUniqueID, 1, 16, ifp);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      break;\n    case 0x8602: /* 34306, Leaf white balance */\n      FORC4\n      {\n        int q = get2();\n        if (q)\n          cam_mul[GRGB_2_RGBG(c)] = 4096.0 / q;\n      }\n      break;\n    case 0x8603: /* 34307, Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][GRGB_2_RGBG(c)]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 0x8606: /* 34310, Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 0x85ff: // 34303\n      strcpy(make, \"Leaf\");\n      break;\n    case 0x8769: /* 34665, EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 0x8825: /* 34853, GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n    }\n    break;\n    case 0x8773: /* 34675, InterColorProfile */\n    case 0xc68f: /* 50831, AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 0x9102: /* 37122, CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 0x920a: /* 37386, FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 0x9211: /* 37393, ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 0x9215: /* 37397, ExposureIndex */\n      imCommon.exifExposureIndex = getreal(type);\n      break;\n    case 0x9218: /* 37400, old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 0xa010: // 40976\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 0x8002: // 32770\n        load_raw = &LibRaw::samsung_load_raw;\n        break;\n      case 0x8004: // 32772\n        load_raw = &LibRaw::samsung2_load_raw;\n        break;\n      case 0x8005: // 32773\n        load_raw = &LibRaw::samsung3_load_raw;\n        break;\n      }\n      break;\n    case 0xb4c3: /* 46275, Imacon tags */\n      imHassy.format = LIBRAW_HF_Imacon;\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 0xb4c7: // 46279\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 0xb4c2: // 46274\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * (height * 6l) == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      c = unsigned(height) * unsigned(width) / 1000000;\n      if (c == 32)\n        c--;\n      sprintf(model, \"Ixpress %d-Mp\", c);\n      load_raw = &LibRaw::imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &LibRaw::unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 0xc516: /* 50454, Sinar tag */\n    case 0xc517: // 50455\n      if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n      if (fread(cbuf, 1, len, ifp) != (int)len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 0xc51a: // 50458\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 0xc51b: /* 50459, Hasselblad tag */\n      if (!libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n        i = order;\n        j = ftell(ifp);\n        c = tiff_nifds;\n        order = get2();\n        fseek(ifp, j + (get2(), get4()), SEEK_SET);\n        parse_tiff_ifd(j);\n        maximum = 0xffff;\n        tiff_nifds = c;\n        order = i;\n        break;\n      }\n    case 0xc612: /* 50706, DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 0xc614: /* 50708, UniqueCameraModel */\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      if (model[0])\n        break;\n      strncpy(make, imgdata.color.UniqueCameraModel,\n              MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 0xc616: /* 50710, CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      tiff_ifd[ifd].t_filters = filters;\n      break;\n    case 0xc617: /* 50711, CFALayout */\n      if (get2() == 2)\n        tiff_ifd[ifd].t_fuji_width = fuji_width = 1;\n      break;\n    case 0x0123: // 291\n    case 0xc618: /* 50712, LinearizationTable */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_LINTABLE;\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n      linear_table(len);\n      break;\n    case 0xc619: /* 50713, BlackLevelRepeatDim */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n      tiff_ifd[ifd].dng_levels.dng_fcblack[4] =\n          tiff_ifd[ifd].dng_levels.dng_cblack[4] = cblack[4] = get2();\n      tiff_ifd[ifd].dng_levels.dng_fcblack[5] =\n          tiff_ifd[ifd].dng_levels.dng_cblack[5] = cblack[5] = get2();\n      if (cblack[4] * cblack[5] >\n          (LIBRAW_CBLACK_SIZE -\n           7)) // Use last cblack item as DNG black level count\n        tiff_ifd[ifd].dng_levels.dng_fcblack[4] =\n            tiff_ifd[ifd].dng_levels.dng_fcblack[5] =\n                tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n                    tiff_ifd[ifd].dng_levels.dng_cblack[5] = cblack[4] =\n                        cblack[5] = 1;\n      break;\n\n    case 0xf00c:\n      if (imFuji.RAFDataGeneration != 4096)\n      {\n        unsigned fwb[4];\n        FORC4 fwb[c] = get4();\n        if (fwb[3] < 0x100)\n        {\n          FORC3 icWBC[fwb[3]][GRBG_2_RGBG(c)] = fwb[c];\n          icWBC[fwb[3]][3] = icWBC[fwb[3]][1];\n          if ((fwb[3] == 17) &&                                      // Tungsten WB\n              (libraw_internal_data.unpacker_data.lenRAFData > 3) &&\n              (libraw_internal_data.unpacker_data.lenRAFData < 10240000))\n          {\n            INT64 f_save = ftell(ifp);\n            rafdata = (ushort *)calloc(\n                sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData,1);\n            fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n            fread(rafdata, sizeof(ushort),\n                  libraw_internal_data.unpacker_data.lenRAFData, ifp);\n            fseek(ifp, f_save, SEEK_SET);\n\n            uchar *PrivateMknBuf = (uchar *)rafdata;\n            int PrivateMknLength = libraw_internal_data.unpacker_data.lenRAFData\n                                   << 1;\n            for (int pos = 0; pos < PrivateMknLength - 16; pos++)\n            {\n              if (!memcmp(PrivateMknBuf + pos, \"TSNERDTS\", 8)) // STDRENST\n              {\n                imFuji.isTSNERDTS = 1;\n                break;\n              }\n            }\n            int fj; // 31? (fj<<1)-0x3c : 34? (fj<<1)-0x4e : undef\n            int is34 = 0;\n            if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3, GFX 100S\n                (imFuji.RAFDataVersion == 0x0261) || // X100V, GFX 50S II\n                (imFuji.RAFDataVersion == 0x0262) || // X-T4\n                (imFuji.RAFDataVersion == 0x0263) || // X-H2S\n                (imFuji.RAFDataVersion == 0x0264) || // X-S10\n                (imFuji.RAFDataVersion == 0x0265) || // X-E4\n                (imFuji.RAFDataVersion == 0x0266) || // X-T30 II\n                !strcmp(model, \"X-Pro3\")     ||\n                !strcmp(model, \"GFX 100S\")   ||\n                !strcmp(model, \"GFX100S\")    ||\n                !strcmp(model, \"GFX 50S II\") ||\n                !strcmp(model, \"GFX50S II\")  ||\n                !strcmp(model, \"X100V\")      ||\n                !strcmp(model, \"X-T4\")       ||\n                !strcmp(model, \"X-H2S\")      ||\n                !strcmp(model, \"X-E4\")       ||\n                !strcmp(model, \"X-T30 II\")   ||\n                !strcmp(model, \"X-S10\"))\n// is34 cameras have 34 CCT values instead of 31, manual still claims 2500 to 10000 K\n// aligned 3000 K to Incandescent, as it is usual w/ other Fujifilm cameras\n              is34 = 1;\n\n            for (int fi = 0;\n                 fi < int(libraw_internal_data.unpacker_data.lenRAFData - 3); fi++) // looking for Tungsten WB\n            {\n              if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) &&\n                  (fwb[2] == rafdata[fi + 2])) // found Tungsten WB\n              {\n                if (rafdata[fi - 15] !=\n                    fwb[0]) // 15 is offset of Tungsten WB from the first\n                            // preset, Fine Weather WB\n                  continue;\n                for (int wb_ind = 0, ofst = fi - 15; wb_ind < (int)Fuji_wb_list1.size();\n                     wb_ind++, ofst += 3)\n                {\n                  icWBC[Fuji_wb_list1[wb_ind]][1] =\n                      icWBC[Fuji_wb_list1[wb_ind]][3] = rafdata[ofst];\n                  icWBC[Fuji_wb_list1[wb_ind]][0] = rafdata[ofst + 1];\n                  icWBC[Fuji_wb_list1[wb_ind]][2] = rafdata[ofst + 2];\n                }\n\n                if (is34)\n                  fi += 24;\n                fi += 96;\n                for (fj = fi; fj < (fi + 15); fj += 3) // looking for the end of the WB table\n                {\n                  if (rafdata[fj] != rafdata[fi])\n                  {\n                    fj -= 93;\n                    if (is34)\n                      fj -= 9;\n// printf (\"wb start in DNG: 0x%04x\\n\", fj*2-0x4e);\n                    for (int iCCT = 0, ofst = fj; iCCT < 31;\n                         iCCT++, ofst += 3)\n                    {\n                      icWBCCTC[iCCT][0] = FujiCCT_K[iCCT];\n                      icWBCCTC[iCCT][1] = rafdata[ofst + 1];\n                      icWBCCTC[iCCT][2] = icWBCCTC[iCCT][4] = rafdata[ofst];\n                      icWBCCTC[iCCT][3] = rafdata[ofst + 2];\n                    }\n                    break;\n                  }\n                }\n                free(rafdata);\n                break;\n              }\n            }\n          }\n        }\n        FORC4 fwb[c] = get4();\n        if (fwb[3] < 0x100) {\n          FORC3 icWBC[fwb[3]][GRBG_2_RGBG(c)] = fwb[c];\n          icWBC[fwb[3]][3] = icWBC[fwb[3]][1];\n        }\n      }\n      break;\n    case 0xf00d:\n      if (imFuji.RAFDataGeneration != 4096)\n      {\n        FORC3 icWBC[LIBRAW_WBI_Auto][GRBG_2_RGBG(c)] = getint(type);\n        icWBC[LIBRAW_WBI_Auto][3] = icWBC[LIBRAW_WBI_Auto][1];\n      }\n      break;\n    case 0xc615: /* 50709, LocalizedCameraModel */\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n    case 0xf00a: // 61450\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 0xc61a: /* 50714, BlackLevel */\n      if (tiff_ifd[ifd].samples > 1 &&\n          tiff_ifd[ifd].samples == (int)len) // LinearDNG, per-channel black\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        for (i = 0; i < 4 && i < (int)len; i++)\n        {\n          tiff_ifd[ifd].dng_levels.dng_fcblack[i] = getreal(type);\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] =\n              tiff_ifd[ifd].dng_levels.dng_fcblack[i] + 0.5;\n        }\n        // Record len in last cblack field\n        tiff_ifd[ifd].dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1] = len;\n\n        tiff_ifd[ifd].dng_levels.dng_fblack =\n            tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else if (tiff_ifd[ifd].samples > 1 // Linear DNG w repeat dim\n               && (tiff_ifd[ifd].samples * cblack[4] * cblack[5] == len))\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        tiff_ifd[ifd].dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1] =\n            cblack[LIBRAW_CBLACK_SIZE - 1] = len;\n        for (i = 0; i < (int)len && i < LIBRAW_CBLACK_SIZE - 7; i++)\n        {\n          tiff_ifd[ifd].dng_levels.dng_fcblack[i + 6] = getreal(type);\n          tiff_ifd[ifd].dng_levels.dng_cblack[i + 6] = cblack[i + 6] =\n              tiff_ifd[ifd].dng_levels.dng_fcblack[i + 6] + 0.5;\n        }\n      }\n      else if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        tiff_ifd[ifd].dng_levels.dng_fblack = getreal(type);\n        black = tiff_ifd[ifd].dng_levels.dng_black =\n            tiff_ifd[ifd].dng_levels.dng_fblack;\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(int(cblack[4] * cblack[5]))\n        {\n          tiff_ifd[ifd].dng_levels.dng_fcblack[6 + c] = getreal(type);\n          cblack[6 + c] = tiff_ifd[ifd].dng_levels.dng_fcblack[6 + c];\n        }\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n        if (tag == 0xc61a)\n        {\n          tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n          FORC(int(cblack[4] * cblack[5]))\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_fblack = 0;\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_fcblack[c] =\n              tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n      }\n      break;\n    case 0xc61b: /* 50715, BlackLevelDeltaH */\n    case 0xc61c: /* 50716, BlackLevelDeltaV */\n      for (num = i = 0; i < (int)len && i < 65536; i++)\n        num += getreal(type);\n      if (len > 0)\n      {\n        black += num / len + 0.5;\n        tiff_ifd[ifd].dng_levels.dng_fblack += num / float(len);\n        tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n      }\n      break;\n    case 0xc61d: /* 50717, WhiteLevel */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_WHITE;\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] = maximum = getint(type);\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < 4 && i < (int)len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n      break;\n    case 0xc61e: /* DefaultScale */\n    {\n      float q1 = getreal(type);\n      float q2 = getreal(type);\n      if (q1 > 0.00001f && q2 > 0.00001f)\n      {\n        pixel_aspect = q1 / q2;\n        if (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n          pixel_aspect = 1.0;\n      }\n    }\n    break;\n    case 0xc61f: /* 50719, DefaultCropOrigin */\n      if (len == 2)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPORIGIN;\n        tiff_ifd[ifd].dng_levels.default_crop[0] = getreal(type);\n        tiff_ifd[ifd].dng_levels.default_crop[1] = getreal(type);\n        if (!strncasecmp(make, \"SONY\", 4))\n        {\n          imgdata.sizes.raw_inset_crops[0].cleft =\n              tiff_ifd[ifd].dng_levels.default_crop[0];\n          imgdata.sizes.raw_inset_crops[0].ctop =\n              tiff_ifd[ifd].dng_levels.default_crop[1];\n        }\n      }\n      break;\n\n    case 0xc620: /* 50720, DefaultCropSize */\n      if (len == 2)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPSIZE;\n        tiff_ifd[ifd].dng_levels.default_crop[2] = getreal(type);\n        tiff_ifd[ifd].dng_levels.default_crop[3] = getreal(type);\n        if (!strncasecmp(make, \"SONY\", 4))\n        {\n          imgdata.sizes.raw_inset_crops[0].cwidth =\n              tiff_ifd[ifd].dng_levels.default_crop[2];\n          imgdata.sizes.raw_inset_crops[0].cheight =\n              tiff_ifd[ifd].dng_levels.default_crop[3];\n        }\n      }\n      break;\n\n    case 0xc7b5: /* 51125 DefaultUserCrop */\n      if (len == 4)\n      {\n          int cnt = 0;\n          FORC4\n          {\n              float v = getreal(type);\n              if (v >= 0.f && v <= 1.f)\n              {\n                  tiff_ifd[ifd].dng_levels.user_crop[c] = v;\n                  cnt++;\n              }\n          }\n          if(cnt == 4 // valid values\n              && tiff_ifd[ifd].dng_levels.user_crop[0] < tiff_ifd[ifd].dng_levels.user_crop[2] // top < bottom\n              && tiff_ifd[ifd].dng_levels.user_crop[1] < tiff_ifd[ifd].dng_levels.user_crop[3] // left < right\n              )\n            tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_USERCROP;\n      }\n      break;\n    case 0x74c7:\n      if ((len == 2) && !strncasecmp(make, \"SONY\", 4))\n      {\n        imgdata.sizes.raw_inset_crops[0].cleft = get4();\n        imgdata.sizes.raw_inset_crops[0].ctop = get4();\n      }\n      break;\n\n    case 0x74c8:\n      if ((len == 2) && !strncasecmp(make, \"SONY\", 4))\n      {\n        imgdata.sizes.raw_inset_crops[0].cwidth = get4();\n        imgdata.sizes.raw_inset_crops[0].cheight = get4();\n      }\n      break;\n\n    case 0xc65a: // 50778\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      tiff_ifd[ifd].dng_color[0].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;\n      break;\n    case 0xc65b: // 50779\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      tiff_ifd[ifd].dng_color[1].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;\n      break;\n\n    case 0xc621: /* 50721, ColorMatrix1 */\n    case 0xc622: /* 50722, ColorMatrix2 */\n    {\n      int chan = (len == 9) ? 3 : (len == 12 ? 4 : 0);\n      i = tag == 0xc621 ? 0 : 1;\n      if (chan)\n      {\n        tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_COLORMATRIX;\n        imHassy.nIFD_CM[i] = ifd;\n      }\n      FORC(chan) for (j = 0; j < 3; j++)\n      {\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] = cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n    }\n    break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n    {\n      int chan = (len == 9) ? 3 : (len == 12 ? 4 : 0);\n      i = tag == 0xc714 ? 0 : 1;\n      if (chan)\n        tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_FORWARDMATRIX;\n      for (j = 0; j < 3; j++)\n        FORC(chan)\n        {\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] = fm[j][c] =\n              getreal(type);\n        }\n    }\n    break;\n\n    case 0xc623: /* 50723, CameraCalibration1 */\n    case 0xc624: /* 50724, CameraCalibration2 */\n    {\n      int chan = (len == 9) ? 3 : (len == 16 ? 4 : 0);\n      j = tag == 0xc623 ? 0 : 1;\n      if (chan)\n        tiff_ifd[ifd].dng_color[j].parsedfields |= LIBRAW_DNGFM_CALIBRATION;\n      for (i = 0; i < chan; i++)\n        FORC(chan)\n        {\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] = cc[i][c] =\n              getreal(type);\n        }\n    }\n    break;\n    case 0xc627: /* 50727, AnalogBalance */\n      if (len >= 3)\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_ANALOGBALANCE;\n      for (c = 0; c < (int)len && c < 4; c++)\n      {\n        tiff_ifd[ifd].dng_levels.analogbalance[c] = ab[c] = getreal(type);\n      }\n      break;\n    case 0xc628: /* 50728, AsShotNeutral */\n      if (len >= 3)\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_ASSHOTNEUTRAL;\n      for (c = 0; c < (int)len && c < 4; c++)\n        tiff_ifd[ifd].dng_levels.asshotneutral[c] = asn[c] = getreal(type);\n      break;\n    case 0xc629: /* 50729, AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= LibRaw_constants::d65_white[c];\n      break;\n    case 0xc62a: /* DNG: 50730 BaselineExposure */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BASELINEEXPOSURE;\n      tiff_ifd[ifd].dng_levels.baseline_exposure = getreal(type);\n      break;\n    case 0xc62e: /* DNG: 50734 LinearResponseLimit */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_LINEARRESPONSELIMIT;\n      tiff_ifd[ifd].dng_levels.LinearResponseLimit = getreal(type);\n      break;\n\n    case 0xc634: /* 50740 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n      {\n        char mbuf[64];\n        INT64 curr_pos, start_pos = ftell(ifp);\n        unsigned MakN_order, m_sorder = order;\n        unsigned MakN_length;\n        unsigned pos_in_original_raw;\n        fread(mbuf, 1, 6, ifp);\n\n        if (!strcmp(mbuf, \"Adobe\"))\n        {\n          order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n          curr_pos = start_pos + 6;\n          while (curr_pos + 8 - start_pos <= len)\n          {\n            fread(mbuf, 1, 4, ifp);\n            curr_pos += 8;\n\n            if (!strncmp(mbuf, \"Pano\", 4))\n            { // PanasonicRaw, yes, they use \"Pano\" as signature\n              parseAdobePanoMakernote();\n            }\n\n            if (!strncmp(mbuf, \"MakN\", 4))\n            {\n              MakN_length = get4();\n              MakN_order = get2();\n              pos_in_original_raw = get4();\n              order = MakN_order;\n\n              INT64 save_pos = ifp->tell();\n              parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0,\n                                     AdobeDNG);\n\n              curr_pos = save_pos + MakN_length - 6;\n              fseek(ifp, curr_pos, SEEK_SET);\n\n              fread(mbuf, 1, 4, ifp);\n              curr_pos += 8;\n\n              if (!strncmp(mbuf, \"Pano \", 4))\n              {\n                parseAdobePanoMakernote();\n              }\n\n              if (!strncmp(mbuf, \"RAF \", 4))\n              { // Fujifilm Raw, AdobeRAF\n                parseAdobeRAFMakernote();\n              }\n\n              if (!strncmp(mbuf, \"SR2 \", 4))\n              {\n                order = 0x4d4d;\n                MakN_length = get4();\n                MakN_order = get2();\n                pos_in_original_raw = get4();\n                order = MakN_order;\n\n                unsigned *buf_SR2;\n                unsigned SR2SubIFDOffset = 0;\n                unsigned SR2SubIFDLength = 0;\n                unsigned SR2SubIFDKey = 0;\n                {\n                  int _base = curr_pos + 6 - pos_in_original_raw;\n                  unsigned _entries, _tag, _type, _len, _save;\n                  _entries = get2();\n                  while (_entries--)\n                  {\n                    tiff_get(_base, &_tag, &_type, &_len, &_save);\n\n                    if (_tag == 0x7200)\n                    {\n                      SR2SubIFDOffset = get4();\n                    }\n                    else if (_tag == 0x7201)\n                    {\n                      SR2SubIFDLength = get4();\n                    }\n                    else if (_tag == 0x7221)\n                    {\n                      SR2SubIFDKey = get4();\n                    }\n                    fseek(ifp, _save, SEEK_SET);\n                  }\n                }\n\n                if (SR2SubIFDLength && (SR2SubIFDLength < 10240000) &&\n                    (buf_SR2 = (unsigned *)calloc(SR2SubIFDLength + 1024,1)))\n                { // 1024b for safety\n                  fseek(ifp, SR2SubIFDOffset + base, SEEK_SET);\n                  fread(buf_SR2, SR2SubIFDLength, 1, ifp);\n                  sony_decrypt(buf_SR2, SR2SubIFDLength / 4, 1, SR2SubIFDKey);\n                  parseSonySR2((uchar *)buf_SR2, SR2SubIFDOffset,\n                               SR2SubIFDLength, AdobeDNG);\n\n                  free(buf_SR2);\n                }\n\n              } /* SR2 processed */\n              break;\n            }\n          }\n        }\n        else\n        {\n          fread(mbuf + 6, 1, 2, ifp);\n          if (!strcmp(mbuf, \"RICOH\") && ((sget2((uchar *)mbuf + 6) == 0x4949) ||\n                                         (sget2((uchar *)mbuf + 6) == 0x4d4d)))\n          {\n            is_PentaxRicohMakernotes = 1;\n          }\n          if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\") ||\n              is_PentaxRicohMakernotes)\n          {\n            fseek(ifp, start_pos, SEEK_SET);\n            parse_makernote_0xc634(base, 0, CameraDNG);\n          }\n        }\n        fseek(ifp, start_pos, SEEK_SET);\n        order = m_sorder;\n      }\n      if (dng_version)\n      {\n        break;\n      }\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 0xc640: // 50752\n      read_shorts(cr2_slice, 3);\n      break;\n    case 0xc68b: /* 50827, OriginalRawFileName */\n      stmread(imgdata.color.OriginalRawFileName, len, ifp);\n      break;\n    case 0xc68d: /* 50829 ActiveArea */\n      tiff_ifd[ifd].t_tm = top_margin = getint(type);\n      tiff_ifd[ifd].t_lm = left_margin = getint(type);\n      tiff_ifd[ifd].t_vheight = height = getint(type) - top_margin;\n      tiff_ifd[ifd].t_vwidth = width = getint(type) - left_margin;\n      break;\n    case 0xc68e: /* 50830 MaskedAreas */\n      for (i = 0; i < (int)len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 0xc71a: /* 50970, PreviewColorSpace */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_PREVIEWCS;\n      tiff_ifd[ifd].dng_levels.preview_colorspace = getint(type);\n      break;\n    case 0xc740: /* 51008, OpcodeList1 */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE1;\n      break;\n    case 0xc741: /* 51009, OpcodeList2 */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE2;\n      tiff_ifd[ifd].opcode2_offset = meta_offset = ftell(ifp);\n      break;\n    case 0xc74e: /* 51022, OpcodeList3 */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE3;\n      break;\n    case 0xfd04: /* 64772, Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &LibRaw::packed_load_raw;\n      break;\n    case 0xfe02: // 65026\n      if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII))\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 &&\n      (buf = (unsigned *)calloc(sony_length, 1)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n    parseSonySR2((uchar *)buf, sony_offset, sony_length, nonDNG);\n    free(buf);\n  }\n  for (i = 0; i < colors && i < 4; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++)\n        cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC\n    if (fabs(asn[c]) > 0.0001)\n      cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC if (fabs(cc[c][c]) > 0.0001) pre_mul[c] /= cc[c][c];\n  return 0;\n}", "target": 1}
{"idx": 39, "func": "int LibRaw::parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save, utmp;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n\n  ushort *rafdata;\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n\n  if (libraw_internal_data.unpacker_data.ifd0_offset == -1LL)\n    libraw_internal_data.unpacker_data.ifd0_offset = base;\n\n  entries = get2();\n  if (entries > 512)\n    return 1;\n\n  INT64 fsize = ifp->size();\n\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && savepos + len > 2 * fsize)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data,\n                        tag | (is_pana_raw ? 0x30000 : ((ifd + 1) << 20)), type,\n                        len, order, ifp, base);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n\n    if (!is_pana_raw)\n    { /* processing of EXIF tags that collide w/ PanasonicRaw tags */\n      switch (tag)\n      {\n      case 0x0001:\n        if (len == 4)\n          is_pana_raw = get4();\n        break;\n      case 0x000b: /* 11, Std. EXIF Software tag */\n        fgets(software, 64, ifp);\n        if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) ||\n            !strncmp(software, \"UFRaw\", 5) || !strncmp(software, \"Bibble\", 6) ||\n            !strcmp(software, \"Digital Photo Professional\"))\n          is_raw = 0;\n        break;\n      case 0x001c: /*  28, safeguard, probably not needed */\n      case 0x001d: /*  29, safeguard, probably not needed */\n      case 0x001e: /*  30, safeguard, probably not needed */\n        cblack[tag - 0x001c] = get2();\n        cblack[3] = cblack[1];\n        break;\n\n      case 0x0111: /* 273, StripOffset */\n        if (len > 1 && len < 16384)\n        {\n          off_t sav = ftell(ifp);\n          tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n          tiff_ifd[ifd].strip_offsets_count = len;\n          for (int ii = 0; ii < (int)len; ii++)\n            tiff_ifd[ifd].strip_offsets[ii] = get4() + base;\n          fseek(ifp, sav, SEEK_SET); // restore position\n        }\n        /* fallback */\n      case 0x0201: /* 513, JpegIFOffset */\n      case 0xf007: // 61447\n        tiff_ifd[ifd].offset = get4() + base;\n        if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n        {\n          fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n          if (ljpeg_start(&jh, 1))\n          {\n            if (!dng_version && !strcasecmp(make, \"SONY\") && tiff_ifd[ifd].phint == 32803 &&\n                tiff_ifd[ifd].comp == 7) // Sony/lossless compressed IFD\n            {\n              tiff_ifd[ifd].comp = 6;\n              tiff_ifd[ifd].bps = jh.bits;\n              tiff_ifd[ifd].samples = 1;\n            }\n            else\n            {\n              tiff_ifd[ifd].comp = 6;\n              tiff_ifd[ifd].bps = jh.bits;\n              tiff_ifd[ifd].t_width = jh.wide;\n              tiff_ifd[ifd].t_height = jh.high;\n              tiff_ifd[ifd].samples = jh.clrs;\n              if (!(jh.sraw || (jh.clrs & 1)))\n                tiff_ifd[ifd].t_width *= jh.clrs;\n              if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n              {\n                tiff_ifd[ifd].t_width /= 2;\n                tiff_ifd[ifd].t_height *= 2;\n              }\n              i = order;\n              parse_tiff(tiff_ifd[ifd].offset + 12);\n              order = i;\n            }\n          }\n        }\n        break;\n      }\n    }\n    else\n    { /* processing Panasonic-specific \"PanasonicRaw\" tags */\n      switch (tag)\n      {\n      case 0x0004: /*   4, SensorTopBorder */\n        imgdata.sizes.raw_inset_crops[0].ctop = get2();\n        break;\n      case 0x000a: /*  10, BitsPerSample */\n        pana_bpp = get2();\n\t\tpana_bpp = LIM(pana_bpp, 8, 16);\n        break;\n      case 0x000b: /*  11, Compression */\n        imPana.Compression = get2();\n        break;\n      case 0x000e: /*  14, LinearityLimitRed */\n      case 0x000f: /*  15, LinearityLimitGreen */\n      case 0x0010: /*  16, LinearityLimitBlue */\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (imgdata.color.linear_max[tag - 14] == 16383)\n            imgdata.color.linear_max[tag - 14] -= 64;\n        if (imgdata.color.linear_max[tag - 14] == 4095)\n          imgdata.color.linear_max[tag - 14] -= 16;\n        if (tag == 0x000f) // 15, LinearityLimitGreen\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        break;\n      case 0x0013: /*  19, WBInfo */\n        if ((i = get2()) > 0x100)\n          break;\n        for (c = 0; c < i; c++)\n        {\n          if ((j = get2()) < 0x100)\n          {\n\t\t\t  if (j >= 0) {\n\t\t\t\t  icWBC[j][0] = get2();\n\t\t\t\t  icWBC[j][2] = get2();\n\t\t\t\t  icWBC[j][1] = icWBC[j][3] =\n\t\t\t\t\t  0x100;\n\t\t\t  }\n          }\n          else // light source out of EXIF numbers range\n            get4();\n        }\n        break;\n      case 0x0018: /* 24, HighISOMultiplierRed */\n      case 0x0019: /* 25, HighISOMultiplierGreen */\n      case 0x001a: /* 26, HighISOMultiplierBlue */\n        imPana.HighISOMultiplier[tag - 0x0018] = get2();\n        break;\n      case 0x001c: /*  28, BlackLevelRed */\n      case 0x001d: /*  29, BlackLevelGreen */\n      case 0x001e: /*  30, BlackLevelBlue */\n        pana_black[tag - 0x001c] = get2();\n        break;\n      case 0x002d: /*  45, RawFormat */\n                   /* pana_encoding: tag 0x002d (45dec)\n                        not used - DMC-LX1/FZ30/FZ50/L1/LX1/LX2\n                        2 - RAW DMC-FZ8/FZ18\n                        3 - RAW DMC-L10\n                        4 - RW2 for most other models, including G9 in \"pixel shift off\"\n                      mode and YUNEEC CGO4            (must add 15 to black levels for\n                      RawFormat == 4)            5 - RW2 DC-GH5s; G9 in \"pixel shift on\"\n                      mode            6 - RW2            DC-S1, DC-S1R in \"pixel shift off\"\n                      mode            7 -            RW2 DC-S1R (probably            DC-S1 too) in\n                      \"pixel shift on\" mode\n                   */\n        pana_encoding = get2();\n        break;\n      case 0x002f: /*  47, CropTop */\n        imgdata.sizes.raw_inset_crops[0].ctop = get2();\n        break;\n      case 0x0030: /*  48, CropLeft */\n        imgdata.sizes.raw_inset_crops[0].cleft = get2();\n        break;\n      case 0x0031: /*  49, CropBottom */\n        imgdata.sizes.raw_inset_crops[0].cheight =\n            get2() - imgdata.sizes.raw_inset_crops[0].ctop;\n        break;\n      case 0x0032: /*  50, CropRight */\n        imgdata.sizes.raw_inset_crops[0].cwidth =\n            get2() - imgdata.sizes.raw_inset_crops[0].cleft;\n        break;\n      case 0x0037: /*  55, ISO if  ISO in 0x8827 & ISO in 0x0017 == 65535 */\n        if (iso_speed == 65535)\n          iso_speed = get4();\n        break;\n      case 0x011c: /* 284, Gamma */\n      {\n        int n = get2();\n        if (n >= 1024)\n          imPana.gamma = (float)n / 1024.0f;\n        else if (n >= 256)\n          imPana.gamma = (float)n / 256.0f;\n        else\n          imPana.gamma = (float)n / 100.0f;\n      }\n      break;\n      case 0x0120: /* 288, CameraIFD, contains tags 0x1xxx, 0x2xxx, 0x3xxx */\n      {\n        unsigned sorder = order;\n        unsigned long sbase = base;\n        base = ftell(ifp);\n        order = get2();\n        fseek(ifp, 2, SEEK_CUR);\n        fseek(ifp, INT64(get4()) - 8LL, SEEK_CUR);\n        parse_tiff_ifd(base);\n        base = sbase;\n        order = sorder;\n      }\n      break;\n      case 0x0121: /* 289, Multishot, 0 is Off, 65536 is Pixel Shift */\n        imPana.Multishot = get4();\n        break;\n      case 0x1001:\n      \tif (imPana.Multishot == 0) {\n      \t  imPana.Multishot = get4();\n      \t  if (imPana.Multishot)\n      \t    imPana.Multishot += 65535;\n      \t}\n        break;\n      case 0x1100:\n        imPana.FocusStepNear = get2();\n        break;\n      case 0x1101:\n        imPana.FocusStepCount = get2();\n        break;\n      case 0x1105:\n        imPana.ZoomPosition = get4();\n        break;\n      case 0x1201:\n        if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT)) {\n          imPana.LensManufacturer = fgetc(ifp);\n        } else if (type == 258) {\n          imPana.LensManufacturer = get4();\n          if (imPana.LensManufacturer >= 257) {\n            ilm.LensMount = LIBRAW_MOUNT_LPS_L;\n            ilm.LensFormat = LIBRAW_FORMAT_FF;\n          }\n        }\n        break;\n      case 0x1202:\n        if (ilm.LensMount == LIBRAW_MOUNT_LPS_L) {\n          if ((utmp = get2())) ilm.LensID = utmp;\n        } else if ((imPana.LensManufacturer != 0xff) &&\n                   (imPana.LensManufacturer != 0xffffffff)) {\n          if ((utmp = (fgetc(ifp) << 8) | fgetc(ifp)))\n            ilm.LensID = (imPana.LensManufacturer << 16) + utmp;\n        }\n        break;\n      case 0x1203: /* 4611, FocalLengthIn35mmFormat, contained in 0x0120\n                      CameraIFD */\n        if (imgdata.lens.FocalLengthIn35mmFormat < 0.65f)\n          imgdata.lens.FocalLengthIn35mmFormat = get2();\n        break;\n      case 0x2009: /* 8201, contained in 0x0120 CameraIFD */\n        if ((pana_encoding == 4) || (pana_encoding == 5))\n        {\n          i = MIN(8, len);\n          int permut[8] = {3, 2, 1, 0, 3 + 4, 2 + 4, 1 + 4, 0 + 4};\n          imPana.BlackLevelDim = len;\n          for (j = 0; j < i; j++)\n          {\n            imPana.BlackLevel[permut[j]] =\n                (float)(get2()) / (float)(powf(2.f, 14.f - pana_bpp));\n          }\n        }\n        break;\n      case 0x3420: /* 13344, WB_RedLevelAuto, contained in 0x0120 CameraIFD */\n        icWBC[LIBRAW_WBI_Auto][0] = get2();\n        icWBC[LIBRAW_WBI_Auto][1] = icWBC[LIBRAW_WBI_Auto][3] = 1024.0f;\n        break;\n      case 0x3421: /* 13345, WB_BlueLevelAuto, contained in 0x0120 CameraIFD */\n        icWBC[LIBRAW_WBI_Auto][2] = get2();\n        break;\n      case 0x0002: /*   2, ImageWidth */\n        tiff_ifd[ifd].t_width = getint(type);\n        break;\n      case 0x0003: /*   3, ImageHeight */\n        tiff_ifd[ifd].t_height = getint(type);\n        break;\n      case 0x0005: /*   5, SensorLeftBorder */\n        width = get2();\n        imgdata.sizes.raw_inset_crops[0].cleft = width;\n        break;\n      case 0x0006: /*   6, SensorBottomBorder */\n        height = get2();\n        imgdata.sizes.raw_inset_crops[0].cheight =\n            height - imgdata.sizes.raw_inset_crops[0].ctop;\n        break;\n      case 0x0007: /*   7, SensorRightBorder */\n        i = get2();\n        width += i;\n        imgdata.sizes.raw_inset_crops[0].cwidth =\n            i - imgdata.sizes.raw_inset_crops[0].cleft;\n        break;\n      case 0x0009: /*   9, CFAPattern */\n        if ((i = get2()))\n          filters = i;\n        break;\n      case 0x0011: /*  17, RedBalance */\n      case 0x0012: /*  18, BlueBalance */\n        if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT) && len == 1)\n          cam_mul[(tag - 0x0011) * 2] = get2() / 256.0;\n        break;\n      case 0x0017: /*  23, ISO */\n        if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT))\n          iso_speed = get2();\n        break;\n      case 0x0024: /*  36, WBRedLevel */\n      case 0x0025: /*  37, WBGreenLevel */\n      case 0x0026: /*  38, WBBlueLevel */\n        cam_mul[tag - 0x0024] = get2();\n        break;\n      case 0x0027: /*  39, WBInfo2 */\n        if ((i = get2()) > 0x100)\n          break;\n        for (c = 0; c < i; c++)\n        {\n          if ((j = get2()) < 0x100)\n          {\n           if(j >= 0) {\n            icWBC[j][0] = get2();\n            icWBC[j][1] = icWBC[j][3] = get2();\n            icWBC[j][2] = get2();\n            if (c == 1 && i > 6 && cam_mul[0] <= 0.001f)\n                for (int q = 0; q < 4; q++)\n                    cam_mul[q] = icWBC[j][q];\n\t   }\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n        break;\n      case 0x002e: /*  46, JpgFromRaw */\n        if ((type != LIBRAW_EXIFTAG_TYPE_UNDEFINED) || (fgetc(ifp) != 0xff) || (fgetc(ifp) != 0xd8))\n          break;\n        thumb_offset = ftell(ifp) - 2;\n        thumb_length = len;\n        break;\n\n      case 0x0118: /* 280, Panasonic RW2 offset */\n        if (type != LIBRAW_EXIFTAG_TYPE_LONG)\n          break;\n        load_raw = &LibRaw::panasonic_load_raw;\n        load_flags = 0x2008;\n      case 0x0111: /* 273, StripOffset */\n        if (len > 1 && len < 16384)\n        {\n          off_t sav = ftell(ifp);\n          tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n          tiff_ifd[ifd].strip_offsets_count = len;\n          for (int ii = 0; ii < (int)len; ii++)\n            tiff_ifd[ifd].strip_offsets[ii] = get4() + base;\n          fseek(ifp, sav, SEEK_SET); // restore position\n        }\n        /* fallthrough */\n        tiff_ifd[ifd].offset = get4() + base;\n        if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n        {\n          fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n          if (ljpeg_start(&jh, 1))\n          {\n            tiff_ifd[ifd].comp = 6;\n            tiff_ifd[ifd].t_width = jh.wide;\n            tiff_ifd[ifd].t_height = jh.high;\n            tiff_ifd[ifd].bps = jh.bits;\n            tiff_ifd[ifd].samples = jh.clrs;\n            if (!(jh.sraw || (jh.clrs & 1)))\n              tiff_ifd[ifd].t_width *= jh.clrs;\n            if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n            {\n              tiff_ifd[ifd].t_width /= 2;\n              tiff_ifd[ifd].t_height *= 2;\n            }\n            i = order;\n            parse_tiff(tiff_ifd[ifd].offset + 12);\n            order = i;\n          }\n        }\n        break;\n      }\n\n    } /* processing of Panasonic-specific tags finished */\n\n    switch (tag)\n    {            /* processing of general EXIF tags */\n    case 0xf000: /* 61440, Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 0x00fe: /* NewSubfileType */\n      tiff_ifd[ifd].newsubfiletype = getreal(type);\n      break;\n    case 0x0100: /* 256, ImageWidth */\n    case 0xf001: /* 61441, Fuji RAF RawImageFullWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 0x0101: /* 257, ImageHeight */\n    case 0xf002: /* 61442, Fuji RAF RawImageFullHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 0x0102: /* 258, BitsPerSample */\n    case 0xf003: /* 61443, Fuji RAF 0xf003 */\n      if(!tiff_ifd[ifd].samples || tag != 0x0102) // ??? already set by tag 0x115\n        tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < (unsigned)tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 0xf006: /* 61446, Fuji RAF 0xf006 */\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &LibRaw::packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 0x0103: /* 259, Compression */\n                 /*\n                    262\t = Kodak 262\n                  32767  = Sony ARW Compressed\n                  32769  = Packed RAW\n                  32770  = Samsung SRW Compressed\n                  32772  = Samsung SRW Compressed 2\n                  32867  = Kodak KDC Compressed\n                  34713  = Nikon NEF Compressed\n                  65000  = Kodak DCR Compressed\n                  65535  = Pentax PEF Compressed\n                 */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 0x0106: /* 262, PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 0x010e: /* 270, ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 0x010f: /* 271, Make */\n      fgets(make, 64, ifp);\n      break;\n    case 0x0110: /* 272, Model */\n      if (!strncmp(make, \"Hasselblad\", 10) && model[0] &&\n          (imHassy.format != LIBRAW_HF_Imacon))\n        break;\n      fgets(model, 64, ifp);\n      break;\n    case 0x0116: // 278\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n    case 0x0112: /* 274, Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 0x0115: /* 277, SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 0x0152: /* Extrasamples */\n      tiff_ifd[ifd].extrasamples = (getint(type) & 0xff) + 1024;\n      break;\n    case 0x0117: /* 279, StripByteCounts */\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int ii = 0; ii < (int)len; ii++)\n          tiff_ifd[ifd].strip_byte_counts[ii] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n      /* fallback */\n    case 0x0202: // 514\n    case 0xf008: // 61448\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 0xf00e: // 61454, FujiFilm \"As Shot\"\n      FORC3 cam_mul[GRBG_2_RGBG(c)] = getint(type);\n      break;\n    case 0x0131: /* 305, Software */\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) ||\n          !strncmp(software, \"UFRaw\", 5) || !strncmp(software, \"Bibble\", 6) ||\n          !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 0x0132: /* 306, DateTime */\n      get_timestamp(0);\n      break;\n    case 0x013b: /* 315, Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 0x013d: // 317\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 0x0142: /* 322, TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 0x0143: /* 323, TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 0x0144: /* 324, TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &LibRaw::sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 0x0145: // 325\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 0x014a: /* 330, SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &LibRaw::sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n        if (ifd >= int(sizeof tiff_ifd / sizeof tiff_ifd[0]))\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        break;\n      }\n      if (!strncmp(make, \"Hasselblad\", 10) &&\n          libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 0x0153: // 339\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 0x0190: // 400\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n    case 0x02bc: // 700\n      if ((tagtypeIs(LIBRAW_EXIFTAG_TYPE_BYTE) ||\n          tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII) ||\n          tagtypeIs(LIBRAW_EXIFTAG_TYPE_SBYTE) ||\n          tagtypeIs(LIBRAW_EXIFTOOLTAGTYPE_binary)) &&\n          (len > 1) && (len < 5100000))\n      {\n        xmpdata = (char *)calloc(xmplen = len + 1,1);\n        unsigned br = fread(xmpdata,1, len, ifp);\n        xmpdata[br] = 0;\n      }\n      break;\n    case 0x7000:\n      imSony.SonyRawFileType = get2();\n      break;\n    case 0x7010: // 28688\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= (int)sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 0x7200: // 29184, Sony SR2Private\n      sony_offset = get4();\n      break;\n    case 0x7201: // 29185, Sony SR2Private\n      sony_length = get4();\n      break;\n    case 0x7221: // 29217, Sony SR2Private\n      sony_key = get4();\n      break;\n    case 0x7250: // 29264, Sony SR2Private\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 0x7303: // 29443, Sony SR2SubIFD\n      FORC4 cam_mul[GRBG_2_RGBG(c)] = get2();\n      break;\n    case 0x7313: // 29459, Sony SR2SubIFD\n      FORC4 cam_mul[RGGB_2_RGBG(c)] = get2();\n      break;\n    case 0x7310: // 29456, Sony SR2SubIFD\n      FORC4 cblack[RGGB_2_RGBG(c)] = get2();\n      i = cblack[3];\n      FORC3 if (i > (int)cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n      break;\n    case 0x827d: /* 33405, Model2 */\n                 /*\n                  for Kodak ProBack 645 PB645x-yyyy 'x' is:\n                  'M' for Mamiya 645\n                  'C' for Contax 645\n                  'H' for Hasselblad H-series\n                 */\n      fgets(model2, 64, ifp);\n      break;\n    case 0x828d: /* 33421, CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        tiff_ifd[ifd].t_filters = filters = 9;\n      break;\n    case 0x828e: /* 33422, CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 0xfd09: /* 64777, Kodak P-series */\n      if (len == 36)\n      {\n        tiff_ifd[ifd].t_filters = filters = 9;\n        colors = 3;\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < (int)plen && colors < 4; i++)\n        {\n          if (cfa_pat[i] > 31)\n            continue; // Skip wrong data\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 0x8290: // 33424\n    case 0xfe00: // 65024\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 0x829a: /* 33434, ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 0x829d: /* 33437, FNumber */\n      aperture = getreal(type);\n      break;\n    case 0x9400:\n      imCommon.exifAmbientTemperature = getreal(type);\n      if ((imCommon.CameraTemperature > -273.15f) &&\n          ((OlyID == OlyID_TG_5) || (OlyID == OlyID_TG_6)))\n        imCommon.CameraTemperature +=\n            imCommon.exifAmbientTemperature;\n      break;\n    case 0x9401:\n      imCommon.exifHumidity = getreal(type);\n      break;\n    case 0x9402:\n      imCommon.exifPressure = getreal(type);\n      break;\n    case 0x9403:\n      imCommon.exifWaterDepth = getreal(type);\n      break;\n    case 0x9404:\n      imCommon.exifAcceleration = getreal(type);\n      break;\n    case 0x9405:\n      imCommon.exifCameraElevationAngle = getreal(type);\n      break;\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa420: /* 42016, ImageUniqueID */\n      stmread(imgdata.color.ImageUniqueID, len, ifp);\n      break;\n    case 0xc65d: /* 50781, RawDataUniqueID */\n      imgdata.color.RawDataUniqueID[16] = 0;\n      fread(imgdata.color.RawDataUniqueID, 1, 16, ifp);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      break;\n    case 0x8602: /* 34306, Leaf white balance */\n      FORC4\n      {\n        int q = get2();\n        if (q)\n          cam_mul[GRGB_2_RGBG(c)] = 4096.0 / q;\n      }\n      break;\n    case 0x8603: /* 34307, Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][GRGB_2_RGBG(c)]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 0x8606: /* 34310, Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 0x85ff: // 34303\n      strcpy(make, \"Leaf\");\n      break;\n    case 0x8769: /* 34665, EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 0x8825: /* 34853, GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n    }\n    break;\n    case 0x8773: /* 34675, InterColorProfile */\n    case 0xc68f: /* 50831, AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 0x9102: /* 37122, CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 0x920a: /* 37386, FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 0x9211: /* 37393, ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 0x9215: /* 37397, ExposureIndex */\n      imCommon.exifExposureIndex = getreal(type);\n      break;\n    case 0x9218: /* 37400, old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 0xa010: // 40976\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 0x8002: // 32770\n        load_raw = &LibRaw::samsung_load_raw;\n        break;\n      case 0x8004: // 32772\n        load_raw = &LibRaw::samsung2_load_raw;\n        break;\n      case 0x8005: // 32773\n        load_raw = &LibRaw::samsung3_load_raw;\n        break;\n      }\n      break;\n    case 0xb4c3: /* 46275, Imacon tags */\n      imHassy.format = LIBRAW_HF_Imacon;\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 0xb4c7: // 46279\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 0xb4c2: // 46274\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * (height * 6l) == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      c = unsigned(height) * unsigned(width) / 1000000;\n      if (c == 32)\n        c--;\n      sprintf(model, \"Ixpress %d-Mp\", c);\n      load_raw = &LibRaw::imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &LibRaw::unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 0xc516: /* 50454, Sinar tag */\n    case 0xc517: // 50455\n      if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n      if (fread(cbuf, 1, len, ifp) != (int)len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 0xc51a: // 50458\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 0xc51b: /* 50459, Hasselblad tag */\n      if (!libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n        i = order;\n        j = ftell(ifp);\n        c = tiff_nifds;\n        order = get2();\n        fseek(ifp, j + (get2(), get4()), SEEK_SET);\n        parse_tiff_ifd(j);\n        maximum = 0xffff;\n        tiff_nifds = c;\n        order = i;\n        break;\n      }\n    case 0xc612: /* 50706, DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 0xc614: /* 50708, UniqueCameraModel */\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      if (model[0])\n        break;\n      strncpy(make, imgdata.color.UniqueCameraModel,\n              MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 0xc616: /* 50710, CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      tiff_ifd[ifd].t_filters = filters;\n      break;\n    case 0xc617: /* 50711, CFALayout */\n      if (get2() == 2)\n        tiff_ifd[ifd].t_fuji_width = fuji_width = 1;\n      break;\n    case 0x0123: // 291\n    case 0xc618: /* 50712, LinearizationTable */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_LINTABLE;\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n      linear_table(len);\n      break;\n    case 0xc619: /* 50713, BlackLevelRepeatDim */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n      tiff_ifd[ifd].dng_levels.dng_fcblack[4] =\n          tiff_ifd[ifd].dng_levels.dng_cblack[4] = cblack[4] = get2();\n      tiff_ifd[ifd].dng_levels.dng_fcblack[5] =\n          tiff_ifd[ifd].dng_levels.dng_cblack[5] = cblack[5] = get2();\n      if (cblack[4] * cblack[5] >\n          (LIBRAW_CBLACK_SIZE -\n           7)) // Use last cblack item as DNG black level count\n        tiff_ifd[ifd].dng_levels.dng_fcblack[4] =\n            tiff_ifd[ifd].dng_levels.dng_fcblack[5] =\n                tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n                    tiff_ifd[ifd].dng_levels.dng_cblack[5] = cblack[4] =\n                        cblack[5] = 1;\n      break;\n\n    case 0xf00c:\n      if (imFuji.RAFDataGeneration != 4096)\n      {\n        unsigned fwb[4];\n        FORC4 fwb[c] = get4();\n        if (fwb[3] < 0x100)\n        {\n          FORC3 icWBC[fwb[3]][GRBG_2_RGBG(c)] = fwb[c];\n          icWBC[fwb[3]][3] = icWBC[fwb[3]][1];\n          if ((fwb[3] == 17) &&                                      // Tungsten WB\n              (libraw_internal_data.unpacker_data.lenRAFData > 3) &&\n              (libraw_internal_data.unpacker_data.lenRAFData < 10240000))\n          {\n            INT64 f_save = ftell(ifp);\n            rafdata = (ushort *)calloc(\n                sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData,1);\n            fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n            fread(rafdata, sizeof(ushort),\n                  libraw_internal_data.unpacker_data.lenRAFData, ifp);\n            fseek(ifp, f_save, SEEK_SET);\n\n            uchar *PrivateMknBuf = (uchar *)rafdata;\n            int PrivateMknLength = libraw_internal_data.unpacker_data.lenRAFData\n                                   << 1;\n            for (int pos = 0; pos < PrivateMknLength - 16; pos++)\n            {\n              if (!memcmp(PrivateMknBuf + pos, \"TSNERDTS\", 8)) // STDRENST\n              {\n                imFuji.isTSNERDTS = 1;\n                break;\n              }\n            }\n            int fj; // 31? (fj<<1)-0x3c : 34? (fj<<1)-0x4e : undef\n            int is34 = 0;\n            if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3, GFX 100S\n                (imFuji.RAFDataVersion == 0x0261) || // X100V, GFX 50S II\n                (imFuji.RAFDataVersion == 0x0262) || // X-T4\n                (imFuji.RAFDataVersion == 0x0263) || // X-H2S\n                (imFuji.RAFDataVersion == 0x0264) || // X-S10\n                (imFuji.RAFDataVersion == 0x0265) || // X-E4\n                (imFuji.RAFDataVersion == 0x0266) || // X-T30 II\n                !strcmp(model, \"X-Pro3\")     ||\n                !strcmp(model, \"GFX 100S\")   ||\n                !strcmp(model, \"GFX100S\")    ||\n                !strcmp(model, \"GFX 50S II\") ||\n                !strcmp(model, \"GFX50S II\")  ||\n                !strcmp(model, \"X100V\")      ||\n                !strcmp(model, \"X-T4\")       ||\n                !strcmp(model, \"X-H2S\")      ||\n                !strcmp(model, \"X-E4\")       ||\n                !strcmp(model, \"X-T30 II\")   ||\n                !strcmp(model, \"X-S10\"))\n// is34 cameras have 34 CCT values instead of 31, manual still claims 2500 to 10000 K\n// aligned 3000 K to Incandescent, as it is usual w/ other Fujifilm cameras\n              is34 = 1;\n\n            for (int fi = 0;\n                 fi < int(libraw_internal_data.unpacker_data.lenRAFData - 3); fi++) // looking for Tungsten WB\n            {\n              if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) &&\n                  (fwb[2] == rafdata[fi + 2])) // found Tungsten WB\n              {\n                if (fi > 14 && rafdata[fi - 15] !=\n                    fwb[0]) // 15 is offset of Tungsten WB from the first\n                            // preset, Fine Weather WB\n                  continue;\n\t\t\t\tif (fi >= 15)\n\t\t\t\t{\n\t\t\t\t\tfor (int wb_ind = 0, ofst = fi - 15; wb_ind < (int)Fuji_wb_list1.size();\n\t\t\t\t\t\twb_ind++, ofst += 3)\n\t\t\t\t\t{\n\t\t\t\t\t\ticWBC[Fuji_wb_list1[wb_ind]][1] =\n\t\t\t\t\t\t\ticWBC[Fuji_wb_list1[wb_ind]][3] = rafdata[ofst];\n\t\t\t\t\t\ticWBC[Fuji_wb_list1[wb_ind]][0] = rafdata[ofst + 1];\n\t\t\t\t\t\ticWBC[Fuji_wb_list1[wb_ind]][2] = rafdata[ofst + 2];\n\t\t\t\t\t}\n\t\t\t\t}\n\n                if (is34)\n                  fi += 24;\n                fi += 96;\n                for (fj = fi; fj < (fi + 15); fj += 3) // looking for the end of the WB table\n                {\n\t\t\t\t\tif (fj > libraw_internal_data.unpacker_data.lenRAFData - 3)\n\t\t\t\t\t\tbreak;\n                  if (rafdata[fj] != rafdata[fi])\n                  {\n                    fj -= 93;\n                    if (is34)\n                      fj -= 9;\n//printf (\"wb start in DNG: 0x%04x\\n\", fj*2-0x4e);\n                    for (int iCCT = 0, ofst = fj; iCCT < 31 \n\t\t\t\t\t\t&& ofst < libraw_internal_data.unpacker_data.lenRAFData - 3;\n                         iCCT++, ofst += 3)\n                    {\n                      icWBCCTC[iCCT][0] = FujiCCT_K[iCCT];\n                      icWBCCTC[iCCT][1] = rafdata[ofst + 1];\n                      icWBCCTC[iCCT][2] = icWBCCTC[iCCT][4] = rafdata[ofst];\n                      icWBCCTC[iCCT][3] = rafdata[ofst + 2];\n                    }\n                    break;\n                  }\n                }\n                free(rafdata);\n                break;\n              }\n            }\n          }\n        }\n        FORC4 fwb[c] = get4();\n        if (fwb[3] < 0x100) {\n          FORC3 icWBC[fwb[3]][GRBG_2_RGBG(c)] = fwb[c];\n          icWBC[fwb[3]][3] = icWBC[fwb[3]][1];\n        }\n      }\n      break;\n    case 0xf00d:\n      if (imFuji.RAFDataGeneration != 4096)\n      {\n        FORC3 icWBC[LIBRAW_WBI_Auto][GRBG_2_RGBG(c)] = getint(type);\n        icWBC[LIBRAW_WBI_Auto][3] = icWBC[LIBRAW_WBI_Auto][1];\n      }\n      break;\n    case 0xc615: /* 50709, LocalizedCameraModel */\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n    case 0xf00a: // 61450\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 0xc61a: /* 50714, BlackLevel */\n      if (tiff_ifd[ifd].samples > 1 &&\n          tiff_ifd[ifd].samples == (int)len) // LinearDNG, per-channel black\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        for (i = 0; i < 4 && i < (int)len; i++)\n        {\n          tiff_ifd[ifd].dng_levels.dng_fcblack[i] = getreal(type);\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] =\n              tiff_ifd[ifd].dng_levels.dng_fcblack[i] + 0.5;\n        }\n        // Record len in last cblack field\n        tiff_ifd[ifd].dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1] = len;\n\n        tiff_ifd[ifd].dng_levels.dng_fblack =\n            tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else if (tiff_ifd[ifd].samples > 1 // Linear DNG w repeat dim\n               && (tiff_ifd[ifd].samples * cblack[4] * cblack[5] == len))\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        tiff_ifd[ifd].dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1] =\n            cblack[LIBRAW_CBLACK_SIZE - 1] = len;\n        for (i = 0; i < (int)len && i < LIBRAW_CBLACK_SIZE - 7; i++)\n        {\n          tiff_ifd[ifd].dng_levels.dng_fcblack[i + 6] = getreal(type);\n          tiff_ifd[ifd].dng_levels.dng_cblack[i + 6] = cblack[i + 6] =\n              tiff_ifd[ifd].dng_levels.dng_fcblack[i + 6] + 0.5;\n        }\n      }\n      else if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        tiff_ifd[ifd].dng_levels.dng_fblack = getreal(type);\n        black = tiff_ifd[ifd].dng_levels.dng_black =\n            tiff_ifd[ifd].dng_levels.dng_fblack;\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(int(cblack[4] * cblack[5]))\n        {\n          tiff_ifd[ifd].dng_levels.dng_fcblack[6 + c] = getreal(type);\n          cblack[6 + c] = tiff_ifd[ifd].dng_levels.dng_fcblack[6 + c];\n        }\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n        if (tag == 0xc61a)\n        {\n          tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n          FORC(int(cblack[4] * cblack[5]))\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_fblack = 0;\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_fcblack[c] =\n              tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n      }\n      break;\n    case 0xc61b: /* 50715, BlackLevelDeltaH */\n    case 0xc61c: /* 50716, BlackLevelDeltaV */\n      for (num = i = 0; i < (int)len && i < 65536; i++)\n        num += getreal(type);\n      if (len > 0)\n      {\n        black += num / len + 0.5;\n        tiff_ifd[ifd].dng_levels.dng_fblack += num / float(len);\n        tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n      }\n      break;\n    case 0xc61d: /* 50717, WhiteLevel */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_WHITE;\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] = maximum = getint(type);\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < 4 && i < (int)len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n      break;\n    case 0xc61e: /* DefaultScale */\n    {\n      float q1 = getreal(type);\n      float q2 = getreal(type);\n      if (q1 > 0.00001f && q2 > 0.00001f)\n      {\n        pixel_aspect = q1 / q2;\n        if (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n          pixel_aspect = 1.0;\n      }\n    }\n    break;\n    case 0xc61f: /* 50719, DefaultCropOrigin */\n      if (len == 2)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPORIGIN;\n        tiff_ifd[ifd].dng_levels.default_crop[0] = getreal(type);\n        tiff_ifd[ifd].dng_levels.default_crop[1] = getreal(type);\n        if (!strncasecmp(make, \"SONY\", 4))\n        {\n          imgdata.sizes.raw_inset_crops[0].cleft =\n              tiff_ifd[ifd].dng_levels.default_crop[0];\n          imgdata.sizes.raw_inset_crops[0].ctop =\n              tiff_ifd[ifd].dng_levels.default_crop[1];\n        }\n      }\n      break;\n\n    case 0xc620: /* 50720, DefaultCropSize */\n      if (len == 2)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPSIZE;\n        tiff_ifd[ifd].dng_levels.default_crop[2] = getreal(type);\n        tiff_ifd[ifd].dng_levels.default_crop[3] = getreal(type);\n        if (!strncasecmp(make, \"SONY\", 4))\n        {\n          imgdata.sizes.raw_inset_crops[0].cwidth =\n              tiff_ifd[ifd].dng_levels.default_crop[2];\n          imgdata.sizes.raw_inset_crops[0].cheight =\n              tiff_ifd[ifd].dng_levels.default_crop[3];\n        }\n      }\n      break;\n\n    case 0xc7b5: /* 51125 DefaultUserCrop */\n      if (len == 4)\n      {\n          int cnt = 0;\n          FORC4\n          {\n              float v = getreal(type);\n              if (v >= 0.f && v <= 1.f)\n              {\n                  tiff_ifd[ifd].dng_levels.user_crop[c] = v;\n                  cnt++;\n              }\n          }\n          if(cnt == 4 // valid values\n              && tiff_ifd[ifd].dng_levels.user_crop[0] < tiff_ifd[ifd].dng_levels.user_crop[2] // top < bottom\n              && tiff_ifd[ifd].dng_levels.user_crop[1] < tiff_ifd[ifd].dng_levels.user_crop[3] // left < right\n              )\n            tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_USERCROP;\n      }\n      break;\n    case 0x74c7:\n      if ((len == 2) && !strncasecmp(make, \"SONY\", 4))\n      {\n        imgdata.sizes.raw_inset_crops[0].cleft = get4();\n        imgdata.sizes.raw_inset_crops[0].ctop = get4();\n      }\n      break;\n\n    case 0x74c8:\n      if ((len == 2) && !strncasecmp(make, \"SONY\", 4))\n      {\n        imgdata.sizes.raw_inset_crops[0].cwidth = get4();\n        imgdata.sizes.raw_inset_crops[0].cheight = get4();\n      }\n      break;\n\n    case 0xc65a: // 50778\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      tiff_ifd[ifd].dng_color[0].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;\n      break;\n    case 0xc65b: // 50779\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      tiff_ifd[ifd].dng_color[1].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;\n      break;\n\n    case 0xc621: /* 50721, ColorMatrix1 */\n    case 0xc622: /* 50722, ColorMatrix2 */\n    {\n      int chan = (len == 9) ? 3 : (len == 12 ? 4 : 0);\n      i = tag == 0xc621 ? 0 : 1;\n      if (chan)\n      {\n        tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_COLORMATRIX;\n        imHassy.nIFD_CM[i] = ifd;\n      }\n      FORC(chan) for (j = 0; j < 3; j++)\n      {\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] = cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n    }\n    break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n    {\n      int chan = (len == 9) ? 3 : (len == 12 ? 4 : 0);\n      i = tag == 0xc714 ? 0 : 1;\n      if (chan)\n        tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_FORWARDMATRIX;\n      for (j = 0; j < 3; j++)\n        FORC(chan)\n        {\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] = fm[j][c] =\n              getreal(type);\n        }\n    }\n    break;\n\n    case 0xc623: /* 50723, CameraCalibration1 */\n    case 0xc624: /* 50724, CameraCalibration2 */\n    {\n      int chan = (len == 9) ? 3 : (len == 16 ? 4 : 0);\n      j = tag == 0xc623 ? 0 : 1;\n      if (chan)\n        tiff_ifd[ifd].dng_color[j].parsedfields |= LIBRAW_DNGFM_CALIBRATION;\n      for (i = 0; i < chan; i++)\n        FORC(chan)\n        {\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] = cc[i][c] =\n              getreal(type);\n        }\n    }\n    break;\n    case 0xc627: /* 50727, AnalogBalance */\n      if (len >= 3)\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_ANALOGBALANCE;\n      for (c = 0; c < (int)len && c < 4; c++)\n      {\n        tiff_ifd[ifd].dng_levels.analogbalance[c] = ab[c] = getreal(type);\n      }\n      break;\n    case 0xc628: /* 50728, AsShotNeutral */\n      if (len >= 3)\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_ASSHOTNEUTRAL;\n      for (c = 0; c < (int)len && c < 4; c++)\n        tiff_ifd[ifd].dng_levels.asshotneutral[c] = asn[c] = getreal(type);\n      break;\n    case 0xc629: /* 50729, AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= LibRaw_constants::d65_white[c];\n      break;\n    case 0xc62a: /* DNG: 50730 BaselineExposure */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BASELINEEXPOSURE;\n      tiff_ifd[ifd].dng_levels.baseline_exposure = getreal(type);\n      break;\n    case 0xc62e: /* DNG: 50734 LinearResponseLimit */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_LINEARRESPONSELIMIT;\n      tiff_ifd[ifd].dng_levels.LinearResponseLimit = getreal(type);\n      break;\n\n    case 0xc634: /* 50740 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n      {\n        char mbuf[64];\n        INT64 curr_pos, start_pos = ftell(ifp);\n        unsigned MakN_order, m_sorder = order;\n        unsigned MakN_length;\n        unsigned pos_in_original_raw;\n        fread(mbuf, 1, 6, ifp);\n\n        if (!strcmp(mbuf, \"Adobe\"))\n        {\n          order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n          curr_pos = start_pos + 6;\n          while (curr_pos + 8 - start_pos <= len)\n          {\n            fread(mbuf, 1, 4, ifp);\n            curr_pos += 8;\n\n            if (!strncmp(mbuf, \"Pano\", 4))\n            { // PanasonicRaw, yes, they use \"Pano\" as signature\n              parseAdobePanoMakernote();\n            }\n\n            if (!strncmp(mbuf, \"MakN\", 4))\n            {\n              MakN_length = get4();\n              MakN_order = get2();\n              pos_in_original_raw = get4();\n              order = MakN_order;\n\n              INT64 save_pos = ifp->tell();\n              parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0,\n                                     AdobeDNG);\n\n              curr_pos = save_pos + MakN_length - 6;\n              fseek(ifp, curr_pos, SEEK_SET);\n\n              fread(mbuf, 1, 4, ifp);\n              curr_pos += 8;\n\n              if (!strncmp(mbuf, \"Pano \", 4))\n              {\n                parseAdobePanoMakernote();\n              }\n\n              if (!strncmp(mbuf, \"RAF \", 4))\n              { // Fujifilm Raw, AdobeRAF\n                parseAdobeRAFMakernote();\n              }\n\n              if (!strncmp(mbuf, \"SR2 \", 4))\n              {\n                order = 0x4d4d;\n                MakN_length = get4();\n                MakN_order = get2();\n                pos_in_original_raw = get4();\n                order = MakN_order;\n\n                unsigned *buf_SR2;\n                unsigned SR2SubIFDOffset = 0;\n                unsigned SR2SubIFDLength = 0;\n                unsigned SR2SubIFDKey = 0;\n                {\n                  int _base = curr_pos + 6 - pos_in_original_raw;\n                  unsigned _entries, _tag, _type, _len, _save;\n                  _entries = get2();\n                  while (_entries--)\n                  {\n                    tiff_get(_base, &_tag, &_type, &_len, &_save);\n\n                    if (_tag == 0x7200)\n                    {\n                      SR2SubIFDOffset = get4();\n                    }\n                    else if (_tag == 0x7201)\n                    {\n                      SR2SubIFDLength = get4();\n                    }\n                    else if (_tag == 0x7221)\n                    {\n                      SR2SubIFDKey = get4();\n                    }\n                    fseek(ifp, _save, SEEK_SET);\n                  }\n                }\n\n                if (SR2SubIFDLength && (SR2SubIFDLength < 10240000) &&\n                    (buf_SR2 = (unsigned *)calloc(SR2SubIFDLength + 1024,1)))\n                { // 1024b for safety\n                  fseek(ifp, SR2SubIFDOffset + base, SEEK_SET);\n                  fread(buf_SR2, SR2SubIFDLength, 1, ifp);\n                  sony_decrypt(buf_SR2, SR2SubIFDLength / 4, 1, SR2SubIFDKey);\n                  parseSonySR2((uchar *)buf_SR2, SR2SubIFDOffset,\n                               SR2SubIFDLength, AdobeDNG);\n\n                  free(buf_SR2);\n                }\n\n              } /* SR2 processed */\n              break;\n            }\n          }\n        }\n        else\n        {\n          fread(mbuf + 6, 1, 2, ifp);\n          if (!strcmp(mbuf, \"RICOH\") && ((sget2((uchar *)mbuf + 6) == 0x4949) ||\n                                         (sget2((uchar *)mbuf + 6) == 0x4d4d)))\n          {\n            is_PentaxRicohMakernotes = 1;\n          }\n          if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\") ||\n              is_PentaxRicohMakernotes)\n          {\n            fseek(ifp, start_pos, SEEK_SET);\n            parse_makernote_0xc634(base, 0, CameraDNG);\n          }\n        }\n        fseek(ifp, start_pos, SEEK_SET);\n        order = m_sorder;\n      }\n      if (dng_version)\n      {\n        break;\n      }\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 0xc640: // 50752\n      read_shorts(cr2_slice, 3);\n      break;\n    case 0xc68b: /* 50827, OriginalRawFileName */\n      stmread(imgdata.color.OriginalRawFileName, len, ifp);\n      break;\n    case 0xc68d: /* 50829 ActiveArea */\n      tiff_ifd[ifd].t_tm = top_margin = getint(type);\n      tiff_ifd[ifd].t_lm = left_margin = getint(type);\n      tiff_ifd[ifd].t_vheight = height = getint(type) - top_margin;\n      tiff_ifd[ifd].t_vwidth = width = getint(type) - left_margin;\n      break;\n    case 0xc68e: /* 50830 MaskedAreas */\n      for (i = 0; i < (int)len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 0xc71a: /* 50970, PreviewColorSpace */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_PREVIEWCS;\n      tiff_ifd[ifd].dng_levels.preview_colorspace = getint(type);\n      break;\n    case 0xc740: /* 51008, OpcodeList1 */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE1;\n      break;\n    case 0xc741: /* 51009, OpcodeList2 */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE2;\n      tiff_ifd[ifd].opcode2_offset = meta_offset = ftell(ifp);\n      break;\n    case 0xc74e: /* 51022, OpcodeList3 */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE3;\n      break;\n    case 0xfd04: /* 64772, Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &LibRaw::packed_load_raw;\n      break;\n    case 0xfe02: // 65026\n      if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII))\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 &&\n      (buf = (unsigned *)calloc(sony_length, 1)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n    parseSonySR2((uchar *)buf, sony_offset, sony_length, nonDNG);\n    free(buf);\n  }\n  for (i = 0; i < colors && i < 4; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++)\n        cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC\n    if (fabs(asn[c]) > 0.0001)\n      cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC if (fabs(cc[c][c]) > 0.0001) pre_mul[c] /= cc[c][c];\n  return 0;\n}", "target": 0}
{"idx": 40, "func": "void gmm_state_exception(ogs_fsm_t *s, amf_event_t *e)\n{\n    int xact_count = 0, r;\n    ogs_nas_5gmm_cause_t gmm_cause;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n    ran_ue_t *ran_ue = NULL;\n    ogs_nas_5gs_message_t *nas_message = NULL;\n    ogs_nas_security_header_type_t h;\n    ogs_sbi_message_t *sbi_message = NULL;\n\n    ogs_assert(s);\n    ogs_assert(e);\n\n    amf_sm_debug(e);\n\n    sess = amf_sess_find_by_id(e->sess_id);\n    if (sess) {\n        amf_ue = amf_ue_find_by_id(sess->amf_ue_id);\n        ogs_assert(amf_ue);\n    } else {\n        amf_ue = amf_ue_find_by_id(e->amf_ue_id);\n        ogs_assert(amf_ue);\n    }\n\n    switch (e->h.id) {\n    case OGS_FSM_ENTRY_SIG:\n        AMF_UE_CLEAR_PAGING_INFO(amf_ue);\n        AMF_UE_CLEAR_N2_TRANSFER(amf_ue, pdu_session_resource_setup_request);\n        AMF_UE_CLEAR_5GSM_MESSAGE(amf_ue);\n        CLEAR_AMF_UE_ALL_TIMERS(amf_ue);\n\n        if (amf_ue->amf_ue_context_transfer_state == UE_CONTEXT_TRANSFER_NEW_AMF_STATE) {\n            /*\n            * UE context transfer message has been sent\n            * to old AMF after Registration request.\n            * Now Registrations status update needs to be sent.\n            */\n            ogs_sbi_discovery_option_t *discovery_option = NULL;\n            ogs_guami_t guami;\n            int state = e->h.sbi.state;\n\n            discovery_option = ogs_sbi_discovery_option_new();\n            ogs_assert(discovery_option);\n\n            memcpy(&guami.plmn_id, &amf_ue->home_plmn_id,\n                    sizeof(ogs_plmn_id_t));\n            memcpy(&guami.amf_id, &amf_ue->old_guti.amf_id,\n                    sizeof(ogs_amf_id_t));\n\n            ogs_sbi_discovery_option_set_guami(discovery_option, &guami);\n\n            r = amf_ue_sbi_discover_and_send(\n                    OGS_SBI_SERVICE_TYPE_NAMF_COMM, discovery_option,\n                    amf_namf_comm_build_registration_status_update,\n                    amf_ue, state,\n                    (void *)OpenAPI_ue_context_transfer_status_NOT_TRANSFERRED);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n\n            amf_ue->amf_ue_context_transfer_state = REGISTRATION_STATUS_UPDATE_NEW_AMF_STATE;\n            break;\n        }\n\n        xact_count = amf_sess_xact_count(amf_ue);\n\n        amf_sbi_send_release_all_sessions(\n                ran_ue_find_by_id(amf_ue->ran_ue_id), amf_ue,\n                AMF_RELEASE_SM_CONTEXT_NO_STATE);\n\n        if (!AMF_SESSION_RELEASE_PENDING(amf_ue) &&\n            amf_sess_xact_count(amf_ue) == xact_count) {\n            r = ngap_send_ran_ue_context_release_command(\n                    ran_ue_find_by_id(amf_ue->ran_ue_id),\n                    NGAP_Cause_PR_nas, NGAP_CauseNas_normal_release,\n                    NGAP_UE_CTX_REL_UE_CONTEXT_REMOVE, 0);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n        }\n        break;\n    case OGS_FSM_EXIT_SIG:\n        break;\n\n    case AMF_EVENT_5GMM_MESSAGE:\n        nas_message = e->nas.message;\n        ogs_assert(nas_message);\n\n        ran_ue = ran_ue_find_by_id(amf_ue->ran_ue_id);\n        ogs_assert(ran_ue);\n\n        h.type = e->nas.type;\n\n        xact_count = amf_sess_xact_count(amf_ue);\n\n        switch (nas_message->gmm.h.message_type) {\n        case OGS_NAS_5GS_REGISTRATION_REQUEST:\n            ogs_info(\"Registration request\");\n            gmm_cause = gmm_handle_registration_request(\n                    amf_ue, h, e->ngap.code,\n                    &nas_message->gmm.registration_request);\n            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {\n                ogs_error(\"gmm_handle_registration_request() failed [%d]\",\n                            gmm_cause);\n                r = nas_5gs_send_registration_reject(ran_ue, amf_ue, gmm_cause);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(s, gmm_state_exception);\n                break;\n            }\n\n            if (!AMF_UE_HAVE_SUCI(amf_ue)) {\n                CLEAR_AMF_UE_TIMER(amf_ue->t3570);\n                r = nas_5gs_send_identity_request(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n\n                OGS_FSM_TRAN(s, &gmm_state_de_registered);\n                break;\n            }\n\n            if (h.integrity_protected && SECURITY_CONTEXT_IS_VALID(amf_ue)) {\n\n                /*\n                 * If the OLD RAN_UE is being maintained in AMF-UE Context,\n                 * it deletes the NG Context after exchanging\n                 * the UEContextReleaseCommand/Complete with the gNB\n                 */\n                CLEAR_NG_CONTEXT(amf_ue);\n\n                gmm_cause = gmm_handle_registration_update(\n                        ran_ue, amf_ue, &nas_message->gmm.registration_request);\n                if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {\n                    ogs_error(\"[%s] gmm_handle_registration_update() \"\n                                \"failed [%d]\", amf_ue->suci, gmm_cause);\n                    r = nas_5gs_send_registration_reject(\n                            ran_ue, amf_ue, gmm_cause);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n                    OGS_FSM_TRAN(s, gmm_state_exception);\n                    break;\n                }\n\n                if (amf_sess_xact_count(amf_ue) == xact_count) {\n\n                    if (amf_update_allowed_nssai(amf_ue) == false) {\n                        ogs_error(\"No Allowed-NSSAI\");\n                        r = nas_5gs_send_gmm_reject(\n                                ran_ue, amf_ue,\n                                OGS_5GMM_CAUSE_NO_NETWORK_SLICES_AVAILABLE);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(s, gmm_state_exception);\n                        break;\n                    }\n\n                    if (!PCF_AM_POLICY_ASSOCIATED(amf_ue)) {\n                        r = amf_ue_sbi_discover_and_send(\n                                OGS_SBI_SERVICE_TYPE_NPCF_AM_POLICY_CONTROL,\n                                NULL,\n                                amf_npcf_am_policy_control_build_create,\n                                amf_ue, 0, NULL);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(s, &gmm_state_initial_context_setup);\n                        break;\n                    }\n\n                    CLEAR_AMF_UE_TIMER(amf_ue->t3550);\n                    r = nas_5gs_send_registration_accept(amf_ue);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n                }\n\n                if (amf_ue->next.m_tmsi)\n                    OGS_FSM_TRAN(s, &gmm_state_initial_context_setup);\n                else\n                    OGS_FSM_TRAN(s, &gmm_state_registered);\n\n            } else {\n\n                amf_sbi_send_release_all_sessions(\n                        ran_ue, amf_ue, AMF_RELEASE_SM_CONTEXT_NO_STATE);\n\n                if (!AMF_SESSION_RELEASE_PENDING(amf_ue) &&\n                    amf_sess_xact_count(amf_ue) == xact_count) {\n                    r = amf_ue_sbi_discover_and_send(\n                            OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                            amf_nausf_auth_build_authenticate,\n                            amf_ue, 0, NULL);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n                }\n\n                OGS_FSM_TRAN(s, &gmm_state_authentication);\n            }\n            break;\n\n        default:\n            ogs_error(\"Unknown message [%d]\", nas_message->gmm.h.message_type);\n        }\n        break;\n    case OGS_EVENT_SBI_CLIENT:\n        sbi_message = e->h.sbi.message;\n        ogs_assert(sbi_message);\n\n        ran_ue_t *ran_ue = ran_ue_find_by_id(amf_ue->ran_ue_id);\n        ogs_assert(ran_ue);\n\n        SWITCH(sbi_message->h.service.name)\n        CASE(OGS_SBI_SERVICE_NAME_NAMF_COMM)\n            SWITCH(sbi_message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_CONTEXTS)\n                SWITCH(sbi_message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_TRANSFER_UPDATE)\n                    if (amf_ue->amf_ue_context_transfer_state != REGISTRATION_STATUS_UPDATE_NEW_AMF_STATE) {\n                        ogs_error(\"UE context transfer state not correct\");\n                    }\n                    if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                        ogs_error(\"[%s] HTTP response error [%d]\",\n                                amf_ue->supi, sbi_message->res_status);\n                    }\n                    r = amf_namf_comm_handle_registration_status_update_response(sbi_message, amf_ue);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n\n                    amf_ue->amf_ue_context_transfer_state = UE_CONTEXT_INITIAL_STATE;\n\n                    /* Continue with release command */\n                    xact_count = amf_sess_xact_count(amf_ue);\n                    amf_sbi_send_release_all_sessions(\n                            ran_ue, amf_ue, AMF_RELEASE_SM_CONTEXT_NO_STATE);\n\n                    if (!AMF_SESSION_RELEASE_PENDING(amf_ue) &&\n                        amf_sess_xact_count(amf_ue) == xact_count) {\n                        r = ngap_send_ran_ue_context_release_command(\n                                ran_ue_find_by_id(amf_ue->ran_ue_id),\n                                NGAP_Cause_PR_nas, NGAP_CauseNas_normal_release,\n                                NGAP_UE_CTX_REL_UE_CONTEXT_REMOVE, 0);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                    }\n                    break;\n\n                DEFAULT\n                    ogs_error(\"Invalid resource name [%s]\",\n                            sbi_message->h.resource.component[2]);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[0]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        DEFAULT\n            ogs_error(\"Invalid service name [%s]\", sbi_message->h.service.name);\n            ogs_assert_if_reached();\n\n        END\n        break;\n\n    default:\n        ogs_error(\"Unknown event[%s]\", amf_event_get_name(e));\n    }\n}", "target": 1}
{"idx": 41, "func": "void gmm_state_exception(ogs_fsm_t *s, amf_event_t *e)\n{\n    int xact_count = 0, r;\n    ogs_nas_5gmm_cause_t gmm_cause;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n    ran_ue_t *ran_ue = NULL;\n    ogs_nas_5gs_message_t *nas_message = NULL;\n    ogs_nas_security_header_type_t h;\n    ogs_sbi_message_t *sbi_message = NULL;\n\n    ogs_assert(s);\n    ogs_assert(e);\n\n    amf_sm_debug(e);\n\n    sess = amf_sess_find_by_id(e->sess_id);\n    if (sess) {\n        amf_ue = amf_ue_find_by_id(sess->amf_ue_id);\n        ogs_assert(amf_ue);\n    } else {\n        amf_ue = amf_ue_find_by_id(e->amf_ue_id);\n        ogs_assert(amf_ue);\n    }\n\n    switch (e->h.id) {\n    case OGS_FSM_ENTRY_SIG:\n        AMF_UE_CLEAR_PAGING_INFO(amf_ue);\n        AMF_UE_CLEAR_N2_TRANSFER(amf_ue, pdu_session_resource_setup_request);\n        AMF_UE_CLEAR_5GSM_MESSAGE(amf_ue);\n        CLEAR_AMF_UE_ALL_TIMERS(amf_ue);\n\n        if (amf_ue->amf_ue_context_transfer_state == UE_CONTEXT_TRANSFER_NEW_AMF_STATE) {\n            /*\n            * UE context transfer message has been sent\n            * to old AMF after Registration request.\n            * Now Registrations status update needs to be sent.\n            */\n            ogs_sbi_discovery_option_t *discovery_option = NULL;\n            ogs_guami_t guami;\n            int state = e->h.sbi.state;\n\n            discovery_option = ogs_sbi_discovery_option_new();\n            ogs_assert(discovery_option);\n\n            memcpy(&guami.plmn_id, &amf_ue->home_plmn_id,\n                    sizeof(ogs_plmn_id_t));\n            memcpy(&guami.amf_id, &amf_ue->old_guti.amf_id,\n                    sizeof(ogs_amf_id_t));\n\n            ogs_sbi_discovery_option_set_guami(discovery_option, &guami);\n\n            r = amf_ue_sbi_discover_and_send(\n                    OGS_SBI_SERVICE_TYPE_NAMF_COMM, discovery_option,\n                    amf_namf_comm_build_registration_status_update,\n                    amf_ue, state,\n                    (void *)OpenAPI_ue_context_transfer_status_NOT_TRANSFERRED);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n\n            amf_ue->amf_ue_context_transfer_state = REGISTRATION_STATUS_UPDATE_NEW_AMF_STATE;\n            break;\n        }\n\n        xact_count = amf_sess_xact_count(amf_ue);\n\n        amf_sbi_send_release_all_sessions(\n                ran_ue_find_by_id(amf_ue->ran_ue_id), amf_ue,\n                AMF_RELEASE_SM_CONTEXT_NO_STATE);\n\n        if (!AMF_SESSION_RELEASE_PENDING(amf_ue) &&\n            amf_sess_xact_count(amf_ue) == xact_count) {\n            r = ngap_send_ran_ue_context_release_command(\n                    ran_ue_find_by_id(amf_ue->ran_ue_id),\n                    NGAP_Cause_PR_nas, NGAP_CauseNas_normal_release,\n                    NGAP_UE_CTX_REL_UE_CONTEXT_REMOVE, 0);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n        }\n        break;\n    case OGS_FSM_EXIT_SIG:\n        break;\n\n    case AMF_EVENT_5GMM_MESSAGE:\n        nas_message = e->nas.message;\n        ogs_assert(nas_message);\n\n        ran_ue = ran_ue_find_by_id(amf_ue->ran_ue_id);\n        ogs_assert(ran_ue);\n\n        h.type = e->nas.type;\n\n        xact_count = amf_sess_xact_count(amf_ue);\n\n        switch (nas_message->gmm.h.message_type) {\n        case OGS_NAS_5GS_REGISTRATION_REQUEST:\n            ogs_info(\"Registration request\");\n            gmm_cause = gmm_handle_registration_request(\n                    amf_ue, h, e->ngap.code,\n                    &nas_message->gmm.registration_request);\n            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {\n                ogs_error(\"gmm_handle_registration_request() failed [%d]\",\n                            gmm_cause);\n                r = nas_5gs_send_registration_reject(ran_ue, amf_ue, gmm_cause);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(s, gmm_state_exception);\n                break;\n            }\n\n            if (!AMF_UE_HAVE_SUCI(amf_ue)) {\n                CLEAR_AMF_UE_TIMER(amf_ue->t3570);\n                r = nas_5gs_send_identity_request(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n\n                OGS_FSM_TRAN(s, &gmm_state_de_registered);\n                break;\n            }\n\n            if (h.integrity_protected && SECURITY_CONTEXT_IS_VALID(amf_ue)) {\n\n                /*\n                 * If the OLD RAN_UE is being maintained in AMF-UE Context,\n                 * it deletes the NG Context after exchanging\n                 * the UEContextReleaseCommand/Complete with the gNB\n                 */\n                CLEAR_NG_CONTEXT(amf_ue);\n\n                gmm_cause = gmm_handle_registration_update(\n                        ran_ue, amf_ue, &nas_message->gmm.registration_request);\n                if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {\n                    ogs_error(\"[%s] gmm_handle_registration_update() \"\n                                \"failed [%d]\", amf_ue->suci, gmm_cause);\n                    r = nas_5gs_send_registration_reject(\n                            ran_ue, amf_ue, gmm_cause);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n                    OGS_FSM_TRAN(s, gmm_state_exception);\n                    break;\n                }\n\n                if (amf_sess_xact_count(amf_ue) == xact_count) {\n\n                    if (amf_update_allowed_nssai(amf_ue) == false) {\n                        ogs_error(\"No Allowed-NSSAI\");\n                        r = nas_5gs_send_gmm_reject(\n                                ran_ue, amf_ue,\n                                OGS_5GMM_CAUSE_NO_NETWORK_SLICES_AVAILABLE);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(s, gmm_state_exception);\n                        break;\n                    }\n\n                    if (!PCF_AM_POLICY_ASSOCIATED(amf_ue)) {\n                        r = amf_ue_sbi_discover_and_send(\n                                OGS_SBI_SERVICE_TYPE_NPCF_AM_POLICY_CONTROL,\n                                NULL,\n                                amf_npcf_am_policy_control_build_create,\n                                amf_ue, 0, NULL);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(s, &gmm_state_initial_context_setup);\n                        break;\n                    }\n\n                    CLEAR_AMF_UE_TIMER(amf_ue->t3550);\n                    r = nas_5gs_send_registration_accept(amf_ue);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n                }\n\n                if (amf_ue->next.m_tmsi)\n                    OGS_FSM_TRAN(s, &gmm_state_initial_context_setup);\n                else\n                    OGS_FSM_TRAN(s, &gmm_state_registered);\n\n            } else {\n\n                amf_sbi_send_release_all_sessions(\n                        ran_ue, amf_ue, AMF_RELEASE_SM_CONTEXT_NO_STATE);\n\n                if (!AMF_SESSION_RELEASE_PENDING(amf_ue) &&\n                    amf_sess_xact_count(amf_ue) == xact_count) {\n                    r = amf_ue_sbi_discover_and_send(\n                            OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                            amf_nausf_auth_build_authenticate,\n                            amf_ue, 0, NULL);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n                }\n\n                OGS_FSM_TRAN(s, &gmm_state_authentication);\n            }\n            break;\n\n        default:\n            ogs_error(\"Unknown message [%d]\", nas_message->gmm.h.message_type);\n        }\n        break;\n    case OGS_EVENT_SBI_CLIENT:\n        sbi_message = e->h.sbi.message;\n        ogs_assert(sbi_message);\n\n        ran_ue_t *ran_ue = ran_ue_find_by_id(amf_ue->ran_ue_id);\n        ogs_assert(ran_ue);\n\n        SWITCH(sbi_message->h.service.name)\n        CASE(OGS_SBI_SERVICE_NAME_NAUSF_AUTH)\n            SWITCH(sbi_message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_AUTHENTICATIONS)\n\n                if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n                    sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK &&\n                    sbi_message->res_status != OGS_SBI_HTTP_STATUS_NO_CONTENT) {\n                    if (sbi_message->res_status ==\n                            OGS_SBI_HTTP_STATUS_NOT_FOUND) {\n                        ogs_warn(\"[%s] Cannot find SUCI [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    } else {\n                        ogs_error(\"[%s] HTTP response error [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    }\n                }\n\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    ogs_warn(\"[%s] Ignore SBI message\", amf_ue->suci);\n                    break;\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    ogs_warn(\"[%s] Ignore SBI message\", amf_ue->suci);\n                    break;\n                CASE(OGS_SBI_HTTP_METHOD_DELETE)\n                    ogs_warn(\"[%s] Ignore SBI message\", amf_ue->suci);\n                    break;\n                DEFAULT\n                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n                            amf_ue->suci, sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_5G_AKA)\n            CASE(OGS_SBI_RESOURCE_NAME_5G_AKA_CONFIRMATION)\n            CASE(OGS_SBI_RESOURCE_NAME_EAP_SESSION)\n                ogs_warn(\"[%s] Ignore SBI message\", amf_ue->supi);\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[0]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NAMF_COMM)\n            SWITCH(sbi_message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_CONTEXTS)\n                SWITCH(sbi_message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_TRANSFER_UPDATE)\n                    if (amf_ue->amf_ue_context_transfer_state != REGISTRATION_STATUS_UPDATE_NEW_AMF_STATE) {\n                        ogs_error(\"UE context transfer state not correct\");\n                    }\n                    if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                        ogs_error(\"[%s] HTTP response error [%d]\",\n                                amf_ue->supi, sbi_message->res_status);\n                    }\n                    r = amf_namf_comm_handle_registration_status_update_response(sbi_message, amf_ue);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n\n                    amf_ue->amf_ue_context_transfer_state = UE_CONTEXT_INITIAL_STATE;\n\n                    /* Continue with release command */\n                    xact_count = amf_sess_xact_count(amf_ue);\n                    amf_sbi_send_release_all_sessions(\n                            ran_ue, amf_ue, AMF_RELEASE_SM_CONTEXT_NO_STATE);\n\n                    if (!AMF_SESSION_RELEASE_PENDING(amf_ue) &&\n                        amf_sess_xact_count(amf_ue) == xact_count) {\n                        r = ngap_send_ran_ue_context_release_command(\n                                ran_ue_find_by_id(amf_ue->ran_ue_id),\n                                NGAP_Cause_PR_nas, NGAP_CauseNas_normal_release,\n                                NGAP_UE_CTX_REL_UE_CONTEXT_REMOVE, 0);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                    }\n                    break;\n\n                DEFAULT\n                    ogs_error(\"Invalid resource name [%s]\",\n                            sbi_message->h.resource.component[2]);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[0]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        DEFAULT\n            ogs_error(\"Invalid service name [%s]\", sbi_message->h.service.name);\n            ogs_assert_if_reached();\n\n        END\n        break;\n\n    default:\n        ogs_error(\"Unknown event[%s]\", amf_event_get_name(e));\n    }\n}", "target": 0}
{"idx": 42, "func": "Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const\n{\n  uint32_t image_type = m_heif_file->get_item_type_4cc(id);\n  if (image_type == fourcc(\"grid\") ||\n      image_type == fourcc(\"iden\") ||\n      image_type == fourcc(\"iovl\")) {\n    auto iref_box = m_heif_file->get_iref_box();\n    if (!iref_box) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n\n    std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(\"dimg\"));\n\n    // TODO: check whether this really can be recursive (e.g. overlay of grid images)\n\n    if (image_references.empty() || image_references[0] == id) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n    else {\n      return get_id_of_non_virtual_child_image(image_references[0], out);\n    }\n  }\n  else {\n    out = id;\n    return Error::Ok;\n  }\n}", "target": 1}
{"idx": 43, "func": "Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const\n{\n  uint32_t image_type = m_heif_file->get_item_type_4cc(id);\n  if (image_type == fourcc(\"grid\") ||\n      image_type == fourcc(\"iden\") ||\n      image_type == fourcc(\"iovl\")) {\n    auto iref_box = m_heif_file->get_iref_box();\n    if (!iref_box) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n\n    std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(\"dimg\"));\n\n    // TODO: check whether this really can be recursive (e.g. overlay of grid images)\n\n    if (image_references.empty() || image_references[0] == id) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n    else {\n      return get_id_of_non_virtual_child_image(image_references[0], out);\n    }\n  }\n  else {\n    if (m_all_images.find(id) == m_all_images.end()) {\n      std::stringstream sstr;\n      sstr << \"Image item \" << id << \" referenced, but it does not exist\\n\";\n\n      return Error(heif_error_Invalid_input,\n        heif_suberror_Nonexisting_item_referenced,\n        sstr.str());\n    }\n    else if (dynamic_cast<ImageItem_Error*>(m_all_images.find(id)->second.get())) {\n      // Should er return an error here or leave it to the follow-up code to detect that?\n    }\n\n    out = id;\n    return Error::Ok;\n  }\n}", "target": 0}
{"idx": 44, "func": "std::shared_ptr<Decoder> ImageItem_AVC::get_decoder() const\n{\n  return m_decoder;\n}", "target": 1}
{"idx": 45, "func": "Result<std::shared_ptr<Decoder>> ImageItem_AVC::get_decoder() const\n{\n  return {m_decoder};\n}", "target": 0}
{"idx": 46, "func": "heif_compression_format get_compression_format() const override { return heif_compression_AVC; }\n\n  Error on_load_file() override;\n\nprotected:\n  std::shared_ptr<Decoder> get_decoder() const override;\n\npublic:\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override;\n\n  std::shared_ptr<class Decoder_AVC> m_decoder;\n};\n\n#endif", "target": 1}
{"idx": 47, "func": "heif_compression_format get_compression_format() const override { return heif_compression_AVC; }\n\n  Error on_load_file() override;\n\nprotected:\n  Result<std::shared_ptr<Decoder>> get_decoder() const override;\n\npublic:\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override;\n\n  std::shared_ptr<class Decoder_AVC> m_decoder;\n};\n\n#endif", "target": 0}
{"idx": 48, "func": "std::shared_ptr<class Decoder> ImageItem_AVIF::get_decoder() const\n{\n  return m_decoder;\n}", "target": 1}
{"idx": 49, "func": "Result<std::shared_ptr<class Decoder>> ImageItem_AVIF::get_decoder() const\n{\n  return {m_decoder};\n}", "target": 0}
{"idx": 50, "func": "heif_compression_format get_compression_format() const override { return heif_compression_AV1; }\n\n  Error on_load_file() override;\n\npublic:\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override;\n\nprotected:\n  Result<std::vector<uint8_t>> read_bitstream_configuration_data() const override;\n\n  std::shared_ptr<class Decoder> get_decoder() const override;\n\nprivate:\n  std::shared_ptr<class Decoder_AVIF> m_decoder;\n};\n\n#endif", "target": 1}
{"idx": 51, "func": "heif_compression_format get_compression_format() const override { return heif_compression_AV1; }\n\n  Error on_load_file() override;\n\npublic:\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override;\n\nprotected:\n  Result<std::vector<uint8_t>> read_bitstream_configuration_data() const override;\n\n  Result<std::shared_ptr<class Decoder>> get_decoder() const override;\n\nprivate:\n  std::shared_ptr<class Decoder_AVIF> m_decoder;\n};\n\n#endif", "target": 0}
{"idx": 52, "func": "std::shared_ptr<Decoder> ImageItem_Grid::get_decoder() const\n{\n  heif_item_id child;\n  Error err = get_context()->get_id_of_non_virtual_child_image(get_id(), child);\n  if (err) {\n    return nullptr;\n  }\n\n  auto image = get_context()->get_image(child, true);\n  if (image->get_item_error()) {\n    return nullptr;\n  }\n\n  return image->get_decoder();\n}", "target": 1}
{"idx": 53, "func": "Result<std::shared_ptr<Decoder>> ImageItem_Grid::get_decoder() const\n{\n  heif_item_id child;\n  Error err = get_context()->get_id_of_non_virtual_child_image(get_id(), child);\n  if (err) {\n    return {err};\n  }\n\n  auto image = get_context()->get_image(child, true);\n  if (!image) {\n    return Error{heif_error_Invalid_input,\n      heif_suberror_Nonexisting_item_referenced};\n  }\n  else if (auto err = image->get_item_error()) {\n    return err;\n  }\n\n  return image->get_decoder();\n}", "target": 0}
{"idx": 54, "func": "Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override {\n    return Error{heif_error_Unsupported_feature,\n                 heif_suberror_Unspecified, \"Cannot encode image to 'grid'\"};\n  }\n\n  Result<std::shared_ptr<HeifPixelImage>> decode_compressed_image(const struct heif_decoding_options& options,\n                                                                  bool decode_tile_only, uint32_t tile_x0, uint32_t tile_y0) const override;\n\nprotected:\n  std::shared_ptr<Decoder> get_decoder() const override;\n\npublic:\n\n  // --- grid specific", "target": 1}
{"idx": 55, "func": "Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override {\n    return Error{heif_error_Unsupported_feature,\n                 heif_suberror_Unspecified, \"Cannot encode image to 'grid'\"};\n  }\n\n  Result<std::shared_ptr<HeifPixelImage>> decode_compressed_image(const struct heif_decoding_options& options,\n                                                                  bool decode_tile_only, uint32_t tile_x0, uint32_t tile_y0) const override;\n\nprotected:\n  Result<std::shared_ptr<Decoder>> get_decoder() const override;\n\npublic:\n\n  // --- grid specific", "target": 0}
{"idx": 56, "func": "std::shared_ptr<class Decoder> ImageItem_HEVC::get_decoder() const\n{\n  return m_decoder;\n}", "target": 1}
{"idx": 57, "func": "Result<std::shared_ptr<class Decoder>> ImageItem_HEVC::get_decoder() const\n{\n  return {m_decoder};\n}", "target": 0}
{"idx": 58, "func": "heif_compression_format get_compression_format() const override { return heif_compression_HEVC; }\n\n  Error on_load_file() override;\n\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override;\n\n  // currently not used\n  void set_preencoded_hevc_image(const std::vector<uint8_t>& data);\n\nprotected:\n  Result<std::vector<uint8_t>> read_bitstream_configuration_data() const override;\n\n  std::shared_ptr<class Decoder> get_decoder() const override;\n\nprivate:\n  std::shared_ptr<class Decoder_HEVC> m_decoder;\n};\n\n#endif", "target": 1}
{"idx": 59, "func": "heif_compression_format get_compression_format() const override { return heif_compression_HEVC; }\n\n  Error on_load_file() override;\n\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override;\n\n  // currently not used\n  void set_preencoded_hevc_image(const std::vector<uint8_t>& data);\n\nprotected:\n  Result<std::vector<uint8_t>> read_bitstream_configuration_data() const override;\n\n  Result<std::shared_ptr<class Decoder>> get_decoder() const override;\n\nprivate:\n  std::shared_ptr<class Decoder_HEVC> m_decoder;\n};\n\n#endif", "target": 0}
{"idx": 60, "func": "int ImageItem::get_chroma_bits_per_pixel() const\n{\n  auto decoder = get_decoder();\n  assert(decoder);\n\n  return decoder->get_chroma_bits_per_pixel();\n}", "target": 1}
{"idx": 61, "func": "int ImageItem::get_luma_bits_per_pixel() const\n{\n  auto decoderResult = get_decoder();\n  if (decoderResult.error) {\n    return decoderResult.error;\n  }\n\n  auto decoder = decoderResult.value;\n\n  return decoder->get_luma_bits_per_pixel();\n}", "target": 0}
{"idx": 62, "func": "virtual std::shared_ptr<class Decoder> get_decoder() const { return nullptr; }\n\nprivate:\n  HeifContext* m_heif_context;\n  std::vector<std::shared_ptr<Box>> m_properties;\n\n  heif_item_id m_id = 0;\n  uint32_t m_width = 0, m_height = 0;  // after all transformations have been applied\n  bool m_is_primary = false;\n\n  bool m_is_thumbnail = false;\n\n  std::vector<std::shared_ptr<ImageItem>> m_thumbnails;\n\n  bool m_is_alpha_channel = false;\n  bool m_premultiplied_alpha = false;\n  std::shared_ptr<ImageItem> m_alpha_channel;\n\n  bool m_is_depth_channel = false;\n  std::shared_ptr<ImageItem> m_depth_channel;\n\n  bool m_has_depth_representation_info = false;\n  struct heif_depth_representation_info m_depth_representation_info;\n\n  bool m_is_aux_image = false;\n  std::string m_aux_image_type;\n  std::vector<std::shared_ptr<ImageItem>> m_aux_images;\n\n  std::vector<std::shared_ptr<ImageMetadata>> m_metadata;\n\n  std::shared_ptr<const color_profile_nclx> m_color_profile_nclx;\n  std::shared_ptr<const color_profile_raw> m_color_profile_icc;\n\n  bool m_miaf_compatible = true;\n\n  std::vector<heif_item_id> m_region_item_ids;\n\n  bool m_has_intrinsic_matrix = false;\n  Box_cmin::AbsoluteIntrinsicMatrix m_intrinsic_matrix{};\n\n  bool m_has_extrinsic_matrix = false;\n  Box_cmex::ExtrinsicMatrix m_extrinsic_matrix{};\n\n  std::vector<Error> m_decoding_warnings;\n\nprotected:\n  // Result<std::vector<uint8_t>> read_bitstream_configuration_data_override(heif_item_id itemId, heif_compression_format format) const;", "target": 1}
{"idx": 63, "func": "virtual Result<std::shared_ptr<class Decoder>> get_decoder() const { return {nullptr}; }\n\nprivate:\n  HeifContext* m_heif_context;\n  std::vector<std::shared_ptr<Box>> m_properties;\n\n  heif_item_id m_id = 0;\n  uint32_t m_width = 0, m_height = 0;  // after all transformations have been applied\n  bool m_is_primary = false;\n\n  bool m_is_thumbnail = false;\n\n  std::vector<std::shared_ptr<ImageItem>> m_thumbnails;\n\n  bool m_is_alpha_channel = false;\n  bool m_premultiplied_alpha = false;\n  std::shared_ptr<ImageItem> m_alpha_channel;\n\n  bool m_is_depth_channel = false;\n  std::shared_ptr<ImageItem> m_depth_channel;\n\n  bool m_has_depth_representation_info = false;\n  struct heif_depth_representation_info m_depth_representation_info;\n\n  bool m_is_aux_image = false;\n  std::string m_aux_image_type;\n  std::vector<std::shared_ptr<ImageItem>> m_aux_images;\n\n  std::vector<std::shared_ptr<ImageMetadata>> m_metadata;\n\n  std::shared_ptr<const color_profile_nclx> m_color_profile_nclx;\n  std::shared_ptr<const color_profile_raw> m_color_profile_icc;\n\n  bool m_miaf_compatible = true;\n\n  std::vector<heif_item_id> m_region_item_ids;\n\n  bool m_has_intrinsic_matrix = false;\n  Box_cmin::AbsoluteIntrinsicMatrix m_intrinsic_matrix{};\n\n  bool m_has_extrinsic_matrix = false;\n  Box_cmex::ExtrinsicMatrix m_extrinsic_matrix{};\n\n  std::vector<Error> m_decoding_warnings;\n\nprotected:\n  // Result<std::vector<uint8_t>> read_bitstream_configuration_data_override(heif_item_id itemId, heif_compression_format format) const;", "target": 0}
{"idx": 64, "func": "std::shared_ptr<Decoder> ImageItem_JPEG::get_decoder() const\n{\n  return m_decoder;\n}", "target": 1}
{"idx": 65, "func": "Result<std::shared_ptr<Decoder>> ImageItem_JPEG::get_decoder() const\n{\n  return {m_decoder};\n}", "target": 0}
{"idx": 66, "func": "heif_compression_format get_compression_format() const override { return heif_compression_JPEG; }\n\n\n  Error on_load_file() override;\n\npublic:\n\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                        struct heif_encoder* encoder,\n                                        const struct heif_encoding_options& options,\n                                        enum heif_image_input_class input_class) override;\n\nprotected:\n  std::shared_ptr<Decoder> get_decoder() const override;\n\n  Result<std::vector<uint8_t>> read_bitstream_configuration_data() const override;\n\nprivate:\n  std::shared_ptr<class Decoder_JPEG> m_decoder;\n};\n\n#endif // LIBHEIF_JPEG_H", "target": 1}
{"idx": 67, "func": "heif_compression_format get_compression_format() const override { return heif_compression_JPEG; }\n\n\n  Error on_load_file() override;\n\npublic:\n\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                        struct heif_encoder* encoder,\n                                        const struct heif_encoding_options& options,\n                                        enum heif_image_input_class input_class) override;\n\nprotected:\n  Result<std::shared_ptr<Decoder>> get_decoder() const override;\n\n  Result<std::vector<uint8_t>> read_bitstream_configuration_data() const override;\n\nprivate:\n  std::shared_ptr<class Decoder_JPEG> m_decoder;\n};\n\n#endif // LIBHEIF_JPEG_H", "target": 0}
{"idx": 68, "func": "std::shared_ptr<Decoder> ImageItem_JPEG2000::get_decoder() const\n{\n  return m_decoder;\n}", "target": 1}
{"idx": 69, "func": "Result<std::shared_ptr<Decoder>> ImageItem_JPEG2000::get_decoder() const\n{\n  return {m_decoder};\n}", "target": 0}
{"idx": 70, "func": "heif_compression_format get_compression_format() const override { return heif_compression_JPEG2000; }\n\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override;\n\nprotected:\n  Result<std::vector<uint8_t>> read_bitstream_configuration_data() const override;\n\n  std::shared_ptr<Decoder> get_decoder() const override;\n\npublic:\n  Error on_load_file() override;\n\nprivate:\n  std::shared_ptr<class Decoder_JPEG2000> m_decoder;\n};\n\n#endif // LIBHEIF_JPEG2000_H", "target": 1}
{"idx": 71, "func": "heif_compression_format get_compression_format() const override { return heif_compression_JPEG2000; }\n\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override;\n\nprotected:\n  Result<std::vector<uint8_t>> read_bitstream_configuration_data() const override;\n\n  Result<std::shared_ptr<Decoder>> get_decoder() const override;\n\npublic:\n  Error on_load_file() override;\n\nprivate:\n  std::shared_ptr<class Decoder_JPEG2000> m_decoder;\n};\n\n#endif // LIBHEIF_JPEG2000_H", "target": 0}
{"idx": 72, "func": "std::shared_ptr<Decoder> ImageItem_uncompressed::get_decoder() const\n{\n  return m_decoder;\n}", "target": 1}
{"idx": 73, "func": "Result<std::shared_ptr<Decoder>> ImageItem_uncompressed::get_decoder() const\n{\n  return {m_decoder};\n}", "target": 0}
{"idx": 74, "func": "bool is_ispe_essential() const override { return true; }\n\n  void get_tile_size(uint32_t& w, uint32_t& h) const override;\n\n  // Code from encode_uncompressed_image() has been moved to here.\n\n  Result<std::shared_ptr<HeifPixelImage>> decode_compressed_image(const struct heif_decoding_options& options,\n                                                                  bool decode_tile_only, uint32_t tile_x0, uint32_t tile_y0) const override;\n\n  heif_image_tiling get_heif_image_tiling() const override;\n\n  Error on_load_file() override;\n\npublic:\n\n  // --- encoding\n\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override;\n\n  static Result<std::shared_ptr<ImageItem_uncompressed>> add_unci_item(HeifContext* ctx,\n                                                                const heif_unci_image_parameters* parameters,\n                                                                const struct heif_encoding_options* encoding_options,\n                                                                const std::shared_ptr<const HeifPixelImage>& prototype);\n\n  Error add_image_tile(uint32_t tile_x, uint32_t tile_y, const std::shared_ptr<const HeifPixelImage>& image);\n\nprotected:\n  std::shared_ptr<Decoder> get_decoder() const override;\n\nprivate:\n  std::shared_ptr<class Decoder_uncompressed> m_decoder;\n  /*\n  Result<ImageItem::CodedImageData> generate_headers(const std::shared_ptr<const HeifPixelImage>& src_image,\n                                                     const heif_unci_image_parameters* parameters,\n                                                     const struct heif_encoding_options* options);\n                                                     */\n\n  uint64_t m_next_tile_write_pos = 0;\n};\n\n#endif //LIBHEIF_UNC_IMAGE_H", "target": 1}
{"idx": 75, "func": "bool is_ispe_essential() const override { return true; }\n\n  void get_tile_size(uint32_t& w, uint32_t& h) const override;\n\n  // Code from encode_uncompressed_image() has been moved to here.\n\n  Result<std::shared_ptr<HeifPixelImage>> decode_compressed_image(const struct heif_decoding_options& options,\n                                                                  bool decode_tile_only, uint32_t tile_x0, uint32_t tile_y0) const override;\n\n  heif_image_tiling get_heif_image_tiling() const override;\n\n  Error on_load_file() override;\n\npublic:\n\n  // --- encoding\n\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override;\n\n  static Result<std::shared_ptr<ImageItem_uncompressed>> add_unci_item(HeifContext* ctx,\n                                                                const heif_unci_image_parameters* parameters,\n                                                                const struct heif_encoding_options* encoding_options,\n                                                                const std::shared_ptr<const HeifPixelImage>& prototype);\n\n  Error add_image_tile(uint32_t tile_x, uint32_t tile_y, const std::shared_ptr<const HeifPixelImage>& image);\n\nprotected:\n  Result<std::shared_ptr<Decoder>> get_decoder() const override;\n\nprivate:\n  std::shared_ptr<class Decoder_uncompressed> m_decoder;\n  /*\n  Result<ImageItem::CodedImageData> generate_headers(const std::shared_ptr<const HeifPixelImage>& src_image,\n                                                     const heif_unci_image_parameters* parameters,\n                                                     const struct heif_encoding_options* options);\n                                                     */\n\n  uint64_t m_next_tile_write_pos = 0;\n};\n\n#endif //LIBHEIF_UNC_IMAGE_H", "target": 0}
{"idx": 76, "func": "std::shared_ptr<Decoder> ImageItem_VVC::get_decoder() const\n{\n  return m_decoder;\n}", "target": 1}
{"idx": 77, "func": "Result<std::shared_ptr<Decoder>> ImageItem_VVC::get_decoder() const\n{\n  return {m_decoder};\n}", "target": 0}
{"idx": 78, "func": "heif_compression_format get_compression_format() const override { return heif_compression_VVC; }\n\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override;\n\n  Error on_load_file() override;\n\nprotected:\n  std::shared_ptr<Decoder> get_decoder() const override;\n\n  Result<std::vector<uint8_t>> read_bitstream_configuration_data() const override;\n\nprivate:\n  std::shared_ptr<class Decoder_VVC> m_decoder;\n};\n\n#endif // LIBHEIF_VVC_H", "target": 1}
{"idx": 79, "func": "heif_compression_format get_compression_format() const override { return heif_compression_VVC; }\n\n  Result<CodedImageData> encode(const std::shared_ptr<HeifPixelImage>& image,\n                                struct heif_encoder* encoder,\n                                const struct heif_encoding_options& options,\n                                enum heif_image_input_class input_class) override;\n\n  Error on_load_file() override;\n\nprotected:\n  Result<std::shared_ptr<Decoder>> get_decoder() const override;\n\n  Result<std::vector<uint8_t>> read_bitstream_configuration_data() const override;\n\nprivate:\n  std::shared_ptr<class Decoder_VVC> m_decoder;\n};\n\n#endif // LIBHEIF_VVC_H", "target": 0}
{"idx": 80, "func": "void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)\n{\n    int r, rv;\n    ogs_nas_5gmm_cause_t gmm_cause;\n\n    amf_ue_t *amf_ue = NULL;\n    ran_ue_t *ran_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_nas_5gs_message_t *nas_message = NULL;\n    ogs_nas_security_header_type_t h;\n\n    ogs_nas_5gs_authentication_failure_t *authentication_failure = NULL;\n    ogs_nas_authentication_failure_parameter_t\n        *authentication_failure_parameter = NULL;\n\n    ogs_sbi_message_t *sbi_message = NULL;\n\n    ogs_assert(s);\n    ogs_assert(e);\n\n    amf_sm_debug(e);\n\n    sess = amf_sess_find_by_id(e->sess_id);\n    if (sess) {\n        amf_ue = amf_ue_find_by_id(sess->amf_ue_id);\n        ogs_assert(amf_ue);\n    } else {\n        amf_ue = amf_ue_find_by_id(e->amf_ue_id);\n        ogs_assert(amf_ue);\n    }\n\n    switch (e->h.id) {\n    case OGS_FSM_ENTRY_SIG:\n        break;\n    case OGS_FSM_EXIT_SIG:\n        break;\n    case AMF_EVENT_5GMM_MESSAGE:\n        nas_message = e->nas.message;\n        ogs_assert(nas_message);\n\n        ran_ue = ran_ue_find_by_id(amf_ue->ran_ue_id);\n        ogs_assert(ran_ue);\n\n        h.type = e->nas.type;\n\n        switch (nas_message->gmm.h.message_type) {\n        case OGS_NAS_5GS_AUTHENTICATION_RESPONSE:\n            rv = gmm_handle_authentication_response(\n                    amf_ue, &nas_message->gmm.authentication_response);\n\n            if (rv != OGS_OK) {\n                r = nas_5gs_send_authentication_reject(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n            }\n            break;\n\n        case OGS_NAS_5GS_AUTHENTICATION_FAILURE:\n            authentication_failure = &nas_message->gmm.authentication_failure;\n            ogs_assert(authentication_failure);\n            authentication_failure_parameter = &authentication_failure->\n                authentication_failure_parameter;\n            ogs_assert(authentication_failure_parameter);\n\n            ogs_debug(\"[%s] Authentication failure [%d]\", amf_ue->suci,\n                    authentication_failure->gmm_cause);\n\n            amf_metrics_inst_by_cause_add(authentication_failure->gmm_cause,\n                    AMF_METR_CTR_AMF_AUTH_FAIL, 1);\n\n            CLEAR_AMF_UE_TIMER(amf_ue->t3560);\n\n            switch (authentication_failure->gmm_cause) {\n            case OGS_5GMM_CAUSE_MAC_FAILURE:\n                ogs_warn(\"Authentication failure(MAC failure)\");\n                break;\n\n            case OGS_5GMM_CAUSE_NON_5G_AUTHENTICATION_UNACCEPTABLE:\n                ogs_error(\"Authentication failure\"\n                        \"(Non-5GS authentication unacceptable)\");\n                break;\n\n            case OGS_5GMM_CAUSE_NGKSI_ALREADY_IN_USE:\n                ogs_warn(\"Authentication failure(ngKSI already in use)\");\n                r = amf_ue_sbi_discover_and_send(\n                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                        amf_nausf_auth_build_authenticate,\n                        amf_ue, 0, NULL);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                return;\n\n            case OGS_5GMM_CAUSE_SYNCH_FAILURE:\n                ogs_warn(\"Authentication failure(Synch failure)\");\n                if (authentication_failure_parameter->length != OGS_AUTS_LEN) {\n                    ogs_error(\"Invalid AUTS Length [%d]\",\n                            authentication_failure_parameter->length);\n                    break;\n                }\n                r = amf_ue_sbi_discover_and_send(\n                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                        amf_nausf_auth_build_authenticate,\n                        amf_ue, 0, authentication_failure_parameter->auts);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                return;\n\n            default:\n                ogs_error(\"Unknown GMM_CAUSE{%d] in Authentication\"\n                        \" failure\",\n                        authentication_failure->gmm_cause);\n                break;\n            }\n\n            r = nas_5gs_send_authentication_reject(amf_ue);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n            OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n\n            break;\n        case OGS_NAS_5GS_REGISTRATION_REQUEST:\n            ogs_warn(\"Registration request\");\n            gmm_cause = gmm_handle_registration_request(\n                    amf_ue, h, e->ngap.code,\n                    &nas_message->gmm.registration_request);\n            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {\n                ogs_error(\"[%s] gmm_handle_registration_request() failed [%d]\",\n                            amf_ue->suci, gmm_cause);\n                r = nas_5gs_send_registration_reject(ran_ue, amf_ue, gmm_cause);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(s, gmm_state_exception);\n                break;\n            }\n\n            r = amf_ue_sbi_discover_and_send(\n                    OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                    amf_nausf_auth_build_authenticate, amf_ue, 0, NULL);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n            break;\n\n        case OGS_NAS_5GS_5GMM_STATUS:\n            ogs_warn(\"[%s] 5GMM STATUS : Cause[%d]\",\n                    amf_ue->suci, nas_message->gmm.gmm_status.gmm_cause);\n            break;\n\n        case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:\n            ogs_warn(\"[%s] Deregistration request\", amf_ue->supi);\n\n            gmm_handle_deregistration_request(\n                    amf_ue, &nas_message->gmm.deregistration_request_from_ue);\n            OGS_FSM_TRAN(s, &gmm_state_de_registered);\n            break;\n\n        default:\n            ogs_error(\"Unknown message[%d]\", nas_message->gmm.h.message_type);\n            break;\n        }\n        break;\n    case AMF_EVENT_5GMM_TIMER:\n        switch (e->h.timer_id) {\n        case AMF_TIMER_T3560:\n            if (amf_ue->t3560.retry_count >=\n                    amf_timer_cfg(AMF_TIMER_T3560)->max_count) {\n                ogs_warn(\"[%s] Retransmission failed. Stop retransmission\",\n                        amf_ue->suci);\n                r = nas_5gs_send_authentication_reject(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n            } else {\n                amf_ue->t3560.retry_count++;\n                r = nas_5gs_send_authentication_request(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n            }\n            break;\n        default:\n            ogs_error(\"[%s] Unknown timer[%s:%d]\", amf_ue->suci,\n                    amf_timer_get_name(e->h.timer_id), e->h.timer_id);\n            break;\n        }\n        break;\n    case OGS_EVENT_SBI_CLIENT:\n        sbi_message = e->h.sbi.message;\n        ogs_assert(sbi_message);\n\n        SWITCH(sbi_message->h.service.name)\n        CASE(OGS_SBI_SERVICE_NAME_NAUSF_AUTH)\n            SWITCH(sbi_message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_AUTHENTICATIONS)\n\n                if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n                    sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                    if (sbi_message->res_status ==\n                            OGS_SBI_HTTP_STATUS_NOT_FOUND) {\n                        ogs_warn(\"[%s] Cannot find SUCI [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    } else {\n                        ogs_error(\"[%s] HTTP response error [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    }\n                    r = nas_5gs_send_gmm_reject_from_sbi(\n                            amf_ue, sbi_message->res_status);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n                    OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    break;\n                }\n\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    rv = amf_nausf_auth_handle_authenticate(\n                            amf_ue, sbi_message);\n                    if (rv != OGS_OK) {\n                        ogs_error(\"[%s] Cannot handle SBI message\",\n                                amf_ue->suci);\n                        r = nas_5gs_send_authentication_reject(amf_ue);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    }\n                    break;\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    rv = amf_nausf_auth_handle_authenticate_confirmation(\n                            amf_ue, sbi_message);\n                    if (rv != OGS_OK) {\n                        ogs_error(\"[%s] Cannot handle SBI message\",\n                                amf_ue->suci);\n                        r = nas_5gs_send_authentication_reject(amf_ue);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    } else {\n                        amf_ue->selected_int_algorithm =\n                            amf_selected_int_algorithm(amf_ue);\n                        amf_ue->selected_enc_algorithm =\n                            amf_selected_enc_algorithm(amf_ue);\n\n                        if (amf_ue->selected_int_algorithm ==\n                                OGS_NAS_SECURITY_ALGORITHMS_EIA0) {\n                            ogs_error(\"Encrypt[0x%x] can be skipped \"\n                                \"with NEA0, but Integrity[0x%x] cannot be \"\n                                \"bypassed with NIA0\",\n                                amf_ue->selected_enc_algorithm,\n                                amf_ue->selected_int_algorithm);\n                            OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                            break;\n                        }\n\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_security_mode);\n                    }\n                    break;\n                DEFAULT\n                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n                            amf_ue->suci, sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[0]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_UECM)\n            if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n                sbi_message->res_status != OGS_SBI_HTTP_STATUS_NO_CONTENT &&\n                sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                ogs_error(\"[%s] HTTP response error [%d]\",\n                        amf_ue->supi, sbi_message->res_status);\n            }\n\n            SWITCH(sbi_message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_REGISTRATIONS)\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    /*\n                     * Issue #2733\n                     *\n                     * We need to ignore this message in this state.\n                     */\n                    ogs_error(\"[%s] Ignore SBI message\", amf_ue->supi);\n                    break;\n                DEFAULT\n                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n                            amf_ue->suci, sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[1]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NPCF_AM_POLICY_CONTROL)\n            SWITCH(sbi_message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_POLICIES)\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED) {\n                        ogs_error(\"[%s] HTTP response error [%d]\",\n                                amf_ue->supi, sbi_message->res_status);\n                    }\n                    ogs_error(\"[%s] Ignore SBI message\", amf_ue->supi);\n                    break;\n\n                DEFAULT\n                    ogs_error(\"Unknown method [%s]\", sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[0]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        DEFAULT\n            ogs_error(\"Invalid service name [%s]\", sbi_message->h.service.name);\n            ogs_assert_if_reached();\n        END\n        break;\n\n    default:\n        ogs_error(\"Unknown event[%s]\", amf_event_get_name(e));\n        break;\n    }\n}", "target": 1}
{"idx": 81, "func": "void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)\n{\n    int r, rv;\n    ogs_nas_5gmm_cause_t gmm_cause;\n\n    amf_ue_t *amf_ue = NULL;\n    ran_ue_t *ran_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_nas_5gs_message_t *nas_message = NULL;\n    ogs_nas_security_header_type_t h;\n\n    ogs_nas_5gs_authentication_failure_t *authentication_failure = NULL;\n    ogs_nas_authentication_failure_parameter_t\n        *authentication_failure_parameter = NULL;\n\n    ogs_sbi_message_t *sbi_message = NULL;\n\n    ogs_assert(s);\n    ogs_assert(e);\n\n    amf_sm_debug(e);\n\n    sess = amf_sess_find_by_id(e->sess_id);\n    if (sess) {\n        amf_ue = amf_ue_find_by_id(sess->amf_ue_id);\n        ogs_assert(amf_ue);\n    } else {\n        amf_ue = amf_ue_find_by_id(e->amf_ue_id);\n        ogs_assert(amf_ue);\n    }\n\n    switch (e->h.id) {\n    case OGS_FSM_ENTRY_SIG:\n        break;\n    case OGS_FSM_EXIT_SIG:\n        break;\n    case AMF_EVENT_5GMM_MESSAGE:\n        nas_message = e->nas.message;\n        ogs_assert(nas_message);\n\n        ran_ue = ran_ue_find_by_id(amf_ue->ran_ue_id);\n        ogs_assert(ran_ue);\n\n        h.type = e->nas.type;\n\n        switch (nas_message->gmm.h.message_type) {\n        case OGS_NAS_5GS_AUTHENTICATION_RESPONSE:\n            rv = gmm_handle_authentication_response(\n                    amf_ue, &nas_message->gmm.authentication_response);\n\n            if (rv != OGS_OK) {\n                r = nas_5gs_send_authentication_reject(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n            }\n            break;\n\n        case OGS_NAS_5GS_AUTHENTICATION_FAILURE:\n            authentication_failure = &nas_message->gmm.authentication_failure;\n            ogs_assert(authentication_failure);\n            authentication_failure_parameter = &authentication_failure->\n                authentication_failure_parameter;\n            ogs_assert(authentication_failure_parameter);\n\n            ogs_debug(\"[%s] Authentication failure [%d]\", amf_ue->suci,\n                    authentication_failure->gmm_cause);\n\n            amf_metrics_inst_by_cause_add(authentication_failure->gmm_cause,\n                    AMF_METR_CTR_AMF_AUTH_FAIL, 1);\n\n            CLEAR_AMF_UE_TIMER(amf_ue->t3560);\n\n            switch (authentication_failure->gmm_cause) {\n            case OGS_5GMM_CAUSE_MAC_FAILURE:\n                ogs_warn(\"Authentication failure(MAC failure)\");\n                break;\n\n            case OGS_5GMM_CAUSE_NON_5G_AUTHENTICATION_UNACCEPTABLE:\n                ogs_error(\"Authentication failure\"\n                        \"(Non-5GS authentication unacceptable)\");\n                break;\n\n            case OGS_5GMM_CAUSE_NGKSI_ALREADY_IN_USE:\n                ogs_warn(\"Authentication failure(ngKSI already in use)\");\n                r = amf_ue_sbi_discover_and_send(\n                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                        amf_nausf_auth_build_authenticate,\n                        amf_ue, 0, NULL);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                return;\n\n            case OGS_5GMM_CAUSE_SYNCH_FAILURE:\n                ogs_warn(\"Authentication failure(Synch failure)\");\n                if (authentication_failure_parameter->length != OGS_AUTS_LEN) {\n                    ogs_error(\"Invalid AUTS Length [%d]\",\n                            authentication_failure_parameter->length);\n                    break;\n                }\n                r = amf_ue_sbi_discover_and_send(\n                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                        amf_nausf_auth_build_authenticate,\n                        amf_ue, 0, authentication_failure_parameter->auts);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                return;\n\n            default:\n                ogs_error(\"Unknown GMM_CAUSE{%d] in Authentication\"\n                        \" failure\",\n                        authentication_failure->gmm_cause);\n                break;\n            }\n\n            r = nas_5gs_send_authentication_reject(amf_ue);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n            OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n\n            break;\n        case OGS_NAS_5GS_REGISTRATION_REQUEST:\n            ogs_warn(\"Registration request\");\n            gmm_cause = gmm_handle_registration_request(\n                    amf_ue, h, e->ngap.code,\n                    &nas_message->gmm.registration_request);\n            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {\n                ogs_error(\"[%s] gmm_handle_registration_request() failed [%d]\",\n                            amf_ue->suci, gmm_cause);\n                r = nas_5gs_send_registration_reject(ran_ue, amf_ue, gmm_cause);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(s, gmm_state_exception);\n                break;\n            }\n\n            r = amf_ue_sbi_discover_and_send(\n                    OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                    amf_nausf_auth_build_authenticate, amf_ue, 0, NULL);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n            break;\n\n        case OGS_NAS_5GS_5GMM_STATUS:\n            ogs_warn(\"[%s] 5GMM STATUS : Cause[%d]\",\n                    amf_ue->suci, nas_message->gmm.gmm_status.gmm_cause);\n            break;\n\n        case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:\n            ogs_warn(\"[%s] Deregistration request\", amf_ue->supi);\n\n            gmm_handle_deregistration_request(\n                    amf_ue, &nas_message->gmm.deregistration_request_from_ue);\n            OGS_FSM_TRAN(s, &gmm_state_de_registered);\n            break;\n\n        default:\n            ogs_error(\"Unknown message[%d]\", nas_message->gmm.h.message_type);\n            break;\n        }\n        break;\n    case AMF_EVENT_5GMM_TIMER:\n        switch (e->h.timer_id) {\n        case AMF_TIMER_T3560:\n            if (amf_ue->t3560.retry_count >=\n                    amf_timer_cfg(AMF_TIMER_T3560)->max_count) {\n                ogs_warn(\"[%s] Retransmission failed. Stop retransmission\",\n                        amf_ue->suci);\n                r = nas_5gs_send_authentication_reject(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n            } else {\n                amf_ue->t3560.retry_count++;\n                r = nas_5gs_send_authentication_request(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n            }\n            break;\n        default:\n            ogs_error(\"[%s] Unknown timer[%s:%d]\", amf_ue->suci,\n                    amf_timer_get_name(e->h.timer_id), e->h.timer_id);\n            break;\n        }\n        break;\n    case OGS_EVENT_SBI_CLIENT:\n        sbi_message = e->h.sbi.message;\n        ogs_assert(sbi_message);\n\n        SWITCH(sbi_message->h.service.name)\n        CASE(OGS_SBI_SERVICE_NAME_NAUSF_AUTH)\n            SWITCH(sbi_message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_AUTHENTICATIONS)\n\n                if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n                    sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                    if (sbi_message->res_status ==\n                            OGS_SBI_HTTP_STATUS_NOT_FOUND) {\n                        ogs_warn(\"[%s] Cannot find SUCI [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    } else {\n                        ogs_error(\"[%s] HTTP response error [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    }\n                    r = nas_5gs_send_gmm_reject_from_sbi(\n                            amf_ue, sbi_message->res_status);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n                    OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    break;\n                }\n\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    rv = amf_nausf_auth_handle_authenticate(\n                            amf_ue, sbi_message);\n                    if (rv != OGS_OK) {\n                        ogs_error(\"[%s] Cannot handle SBI message\",\n                                amf_ue->suci);\n                        r = nas_5gs_send_authentication_reject(amf_ue);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    }\n                    break;\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    rv = amf_nausf_auth_handle_authenticate_confirmation(\n                            amf_ue, sbi_message);\n                    if (rv != OGS_OK) {\n                        ogs_error(\"[%s] Cannot handle SBI message\",\n                                amf_ue->suci);\n                        r = nas_5gs_send_authentication_reject(amf_ue);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    } else {\n                        amf_ue->selected_int_algorithm =\n                            amf_selected_int_algorithm(amf_ue);\n                        amf_ue->selected_enc_algorithm =\n                            amf_selected_enc_algorithm(amf_ue);\n\n                        if (amf_ue->selected_int_algorithm ==\n                                OGS_NAS_SECURITY_ALGORITHMS_EIA0) {\n                            ogs_error(\"Encrypt[0x%x] can be skipped \"\n                                \"with NEA0, but Integrity[0x%x] cannot be \"\n                                \"bypassed with NIA0\",\n                                amf_ue->selected_enc_algorithm,\n                                amf_ue->selected_int_algorithm);\n                            OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                            break;\n                        }\n\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_security_mode);\n                    }\n                    break;\n                DEFAULT\n                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n                            amf_ue->suci, sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[0]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_UECM)\n            if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n                sbi_message->res_status != OGS_SBI_HTTP_STATUS_NO_CONTENT &&\n                sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                ogs_error(\"[%s] HTTP response error [%d]\",\n                        amf_ue->supi, sbi_message->res_status);\n            }\n\n            SWITCH(sbi_message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_REGISTRATIONS)\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    /*\n                     * Issue #2733\n                     *\n                     * We need to ignore this message in this state.\n                     */\n                    ogs_error(\"[%s] Ignore SBI message\", amf_ue->supi);\n                    break;\n                DEFAULT\n                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n                            amf_ue->suci, sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[1]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_SDM)\n            if ((sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) &&\n                (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED) &&\n                (sbi_message->res_status != OGS_SBI_HTTP_STATUS_NO_CONTENT)) {\n                ogs_error(\"[%s] HTTP response error [%d]\",\n                          amf_ue->supi, sbi_message->res_status);\n            }\n\n            SWITCH(sbi_message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_AM_DATA)\n            CASE(OGS_SBI_RESOURCE_NAME_SMF_SELECT_DATA)\n            CASE(OGS_SBI_RESOURCE_NAME_UE_CONTEXT_IN_SMF_DATA)\n            CASE(OGS_SBI_RESOURCE_NAME_SDM_SUBSCRIPTIONS)\n                ogs_warn(\"[%s] Ignore SBI message\", amf_ue->supi);\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[1]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NPCF_AM_POLICY_CONTROL)\n            SWITCH(sbi_message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_POLICIES)\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED) {\n                        ogs_error(\"[%s] HTTP response error [%d]\",\n                                amf_ue->supi, sbi_message->res_status);\n                    }\n                    ogs_error(\"[%s] Ignore SBI message\", amf_ue->supi);\n                    break;\n\n                DEFAULT\n                    ogs_error(\"Unknown method [%s]\", sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[0]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        DEFAULT\n            ogs_error(\"Invalid service name [%s]\", sbi_message->h.service.name);\n            ogs_assert_if_reached();\n        END\n        break;\n\n    default:\n        ogs_error(\"Unknown event[%s]\", amf_event_get_name(e));\n        break;\n    }\n}", "target": 0}
{"idx": 82, "func": "static int x25519_derive_secret(ptls_iovec_t *secret, const uint8_t *clientpriv, const uint8_t *clientpub,\n                                const uint8_t *serverpriv, const uint8_t *serverpub)\n{\n    if ((secret->base = malloc(X25519_KEY_SIZE)) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n\n    cf_curve25519_mul(secret->base, clientpriv != NULL ? clientpriv : serverpriv, clientpriv != NULL ? serverpub : clientpub);\n\n    static const uint8_t zeros[X25519_KEY_SIZE] = {0};\n    if (ptls_mem_equal(secret->base, zeros, sizeof(zeros))) {\n        free(secret->base);\n        return PTLS_ERROR_INCOMPATIBLE_KEY;\n    }\n\n    secret->len = X25519_KEY_SIZE;\n    return 0;\n}", "target": 1}
{"idx": 83, "func": "static int x25519_derive_secret(ptls_iovec_t *secret, const uint8_t *clientpriv, const uint8_t *clientpub,\n                                const uint8_t *serverpriv, const uint8_t *serverpub)\n{\n    if ((secret->base = malloc(X25519_KEY_SIZE)) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n\n    cf_curve25519_mul(secret->base, clientpriv != NULL ? clientpriv : serverpriv, clientpriv != NULL ? serverpub : clientpub);\n\n    static const uint8_t zeros[X25519_KEY_SIZE] = {0};\n    if (ptls_mem_equal(secret->base, zeros, sizeof(zeros))) {\n        free(secret->base);\n        secret->base = NULL;\n        return PTLS_ERROR_INCOMPATIBLE_KEY;\n    }\n\n    secret->len = X25519_KEY_SIZE;\n    return 0;\n}", "target": 0}
{"idx": 84, "func": "const ProcessorState& decodingState() { return decoding_state_; }\n  void onComplete(envoy::service::ext_proc::v3::ProcessingResponse& response) override;\n  void onError() override;\n\n  void onProcessHeadersResponse(const envoy::service::ext_proc::v3::HeadersResponse& response,\n                                absl::Status status,\n                                envoy::config::core::v3::TrafficDirection traffic_direction);\n  void onProcessTrailersResponse(const envoy::service::ext_proc::v3::TrailersResponse& response,\n                                 absl::Status status,\n                                 envoy::config::core::v3::TrafficDirection traffic_direction);\n  void onProcessBodyResponse(const envoy::service::ext_proc::v3::BodyResponse& response,\n                             absl::Status status,\n                             envoy::config::core::v3::TrafficDirection traffic_direction);\n\nprivate:\n  void mergePerRouteConfig();\n  StreamOpenState openStream();\n  void closeStream();\n\n  void onFinishProcessorCalls(Grpc::Status::GrpcStatus call_status);\n  void clearAsyncState();\n  void sendImmediateResponse(const envoy::service::ext_proc::v3::ImmediateResponse& response);\n\n  Http::FilterHeadersStatus onHeaders(ProcessorState& state,\n                                      Http::RequestOrResponseHeaderMap& headers, bool end_stream);\n\n  // Return a pair of whether to terminate returning the current result.\n  std::pair<bool, Http::FilterDataStatus> sendStreamChunk(ProcessorState& state);\n\n  Http::FilterDataStatus handleDataBufferedMode(ProcessorState& state, Buffer::Instance& data,\n                                                bool end_stream);\n  Http::FilterDataStatus handleDataStreamedModeBase(ProcessorState& state, Buffer::Instance& data,\n                                                    bool end_stream);\n  Http::FilterDataStatus handleDataStreamedMode(ProcessorState& state, Buffer::Instance& data,\n                                                bool end_stream);\n  Http::FilterDataStatus handleDataFullDuplexStreamedMode(ProcessorState& state,\n                                                          Buffer::Instance& data, bool end_stream);\n  Http::FilterDataStatus handleDataBufferedPartialMode(ProcessorState& state,\n                                                       Buffer::Instance& data, bool end_stream);\n  Http::FilterDataStatus onData(ProcessorState& state, Buffer::Instance& data, bool end_stream);\n\n  Http::FilterTrailersStatus onTrailers(ProcessorState& state, Http::HeaderMap& trailers);\n  void setDynamicMetadata(Http::StreamFilterCallbacks* cb, const ProcessorState& state,\n                          const envoy::service::ext_proc::v3::ProcessingResponse& response);\n  void setEncoderDynamicMetadata(const envoy::service::ext_proc::v3::ProcessingResponse& response);\n  void setDecoderDynamicMetadata(const envoy::service::ext_proc::v3::ProcessingResponse& response);\n  void addDynamicMetadata(const ProcessorState& state,\n                          envoy::service::ext_proc::v3::ProcessingRequest& req);\n  void addAttributes(ProcessorState& state, envoy::service::ext_proc::v3::ProcessingRequest& req);\n\n  Http::FilterHeadersStatus\n  sendHeadersInObservabilityMode(Http::RequestOrResponseHeaderMap& headers, ProcessorState& state,\n                                 bool end_stream);\n  Http::FilterDataStatus sendDataInObservabilityMode(Buffer::Instance& data, ProcessorState& state,\n                                                     bool end_stream);\n  void deferredCloseStream();\n\n  envoy::service::ext_proc::v3::ProcessingRequest\n  buildHeaderRequest(ProcessorState& state, Http::RequestOrResponseHeaderMap& headers,\n                     bool end_stream, bool observability_mode);\n\n  void sendRequest(envoy::service::ext_proc::v3::ProcessingRequest&& req, bool end_stream);\n\n  void encodeProtocolConfig(envoy::service::ext_proc::v3::ProcessingRequest& req);\n\n  const FilterConfigSharedPtr config_;\n  const ClientBasePtr client_;\n  ExtProcFilterStats stats_;\n  ExtProcLoggingInfo* logging_info_;\n  envoy::config::core::v3::GrpcService grpc_service_;\n  Grpc::GrpcServiceConfigWithHashKey config_with_hash_key_;\n\n  // The state of the filter on both the encoding and decoding side.\n  DecodingProcessorState decoding_state_;\n  EncodingProcessorState encoding_state_;\n\n  std::vector<std::string> untyped_forwarding_namespaces_{};\n  std::vector<std::string> typed_forwarding_namespaces_{};\n  std::vector<std::string> untyped_receiving_namespaces_{};\n  Http::StreamFilterCallbacks* filter_callbacks_;\n  Http::StreamFilterSidestreamWatermarkCallbacks watermark_callbacks_;\n\n  // The gRPC stream to the external processor, which will be opened\n  // when it's time to send the first message.\n  ExternalProcessorStream* stream_ = nullptr;\n\n  std::unique_ptr<OnProcessingResponse> on_processing_response_;\n\n  // Set to true when no more messages need to be sent to the processor.\n  // This happens when the processor has closed the stream, or when it has\n  // failed.\n  bool processing_complete_ = false;\n\n  // Set to true when an \"immediate response\" has been delivered. This helps us\n  // know what response to return from certain failures.\n  bool sent_immediate_response_ = false;\n\n  // Set to true when the mergePerRouteConfig() method has been called.\n  bool route_config_merged_ = false;\n\n  // If true, the protocol configurations are already sent to the server.\n  bool protocol_config_encoded_ = false;\n};\n\nextern std::string responseCaseToString(\n    const envoy::service::ext_proc::v3::ProcessingResponse::ResponseCase response_case);\n\n} // namespace ExternalProcessing\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy", "target": 1}
{"idx": 85, "func": "onLocalReply(const Envoy::Http::StreamFilterBase::LocalReplyData&) override {\n    if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.skip_ext_proc_on_local_reply\")) {\n      ENVOY_STREAM_LOG(debug,\n                       \"When onLocalReply() is called, set processing_complete_ to true to skip \"\n                       \"external processing\",\n                       *decoder_callbacks_);\n      processing_complete_ = true;\n    }\n    return ::Envoy::Http::LocalErrorStatus::Continue;\n  }\n\nprivate:\n  void mergePerRouteConfig();\n  StreamOpenState openStream();\n  void closeStream();\n\n  void onFinishProcessorCalls(Grpc::Status::GrpcStatus call_status);\n  void clearAsyncState();\n  void sendImmediateResponse(const envoy::service::ext_proc::v3::ImmediateResponse& response);\n\n  Http::FilterHeadersStatus onHeaders(ProcessorState& state,\n                                      Http::RequestOrResponseHeaderMap& headers, bool end_stream);\n\n  // Return a pair of whether to terminate returning the current result.\n  std::pair<bool, Http::FilterDataStatus> sendStreamChunk(ProcessorState& state);\n\n  Http::FilterDataStatus handleDataBufferedMode(ProcessorState& state, Buffer::Instance& data,\n                                                bool end_stream);\n  Http::FilterDataStatus handleDataStreamedModeBase(ProcessorState& state, Buffer::Instance& data,\n                                                    bool end_stream);\n  Http::FilterDataStatus handleDataStreamedMode(ProcessorState& state, Buffer::Instance& data,\n                                                bool end_stream);\n  Http::FilterDataStatus handleDataFullDuplexStreamedMode(ProcessorState& state,\n                                                          Buffer::Instance& data, bool end_stream);\n  Http::FilterDataStatus handleDataBufferedPartialMode(ProcessorState& state,\n                                                       Buffer::Instance& data, bool end_stream);\n  Http::FilterDataStatus onData(ProcessorState& state, Buffer::Instance& data, bool end_stream);\n\n  Http::FilterTrailersStatus onTrailers(ProcessorState& state, Http::HeaderMap& trailers);\n  void setDynamicMetadata(Http::StreamFilterCallbacks* cb, const ProcessorState& state,\n                          const envoy::service::ext_proc::v3::ProcessingResponse& response);\n  void setEncoderDynamicMetadata(const envoy::service::ext_proc::v3::ProcessingResponse& response);\n  void setDecoderDynamicMetadata(const envoy::service::ext_proc::v3::ProcessingResponse& response);\n  void addDynamicMetadata(const ProcessorState& state,\n                          envoy::service::ext_proc::v3::ProcessingRequest& req);\n  void addAttributes(ProcessorState& state, envoy::service::ext_proc::v3::ProcessingRequest& req);\n\n  Http::FilterHeadersStatus\n  sendHeadersInObservabilityMode(Http::RequestOrResponseHeaderMap& headers, ProcessorState& state,\n                                 bool end_stream);\n  Http::FilterDataStatus sendDataInObservabilityMode(Buffer::Instance& data, ProcessorState& state,\n                                                     bool end_stream);\n  void deferredCloseStream();\n\n  envoy::service::ext_proc::v3::ProcessingRequest\n  buildHeaderRequest(ProcessorState& state, Http::RequestOrResponseHeaderMap& headers,\n                     bool end_stream, bool observability_mode);\n\n  void sendRequest(envoy::service::ext_proc::v3::ProcessingRequest&& req, bool end_stream);\n\n  void encodeProtocolConfig(envoy::service::ext_proc::v3::ProcessingRequest& req);\n\n  const FilterConfigSharedPtr config_;\n  const ClientBasePtr client_;\n  ExtProcFilterStats stats_;\n  ExtProcLoggingInfo* logging_info_;\n  envoy::config::core::v3::GrpcService grpc_service_;\n  Grpc::GrpcServiceConfigWithHashKey config_with_hash_key_;\n\n  // The state of the filter on both the encoding and decoding side.\n  DecodingProcessorState decoding_state_;\n  EncodingProcessorState encoding_state_;\n\n  std::vector<std::string> untyped_forwarding_namespaces_{};\n  std::vector<std::string> typed_forwarding_namespaces_{};\n  std::vector<std::string> untyped_receiving_namespaces_{};\n  Http::StreamFilterCallbacks* filter_callbacks_;\n  Http::StreamFilterSidestreamWatermarkCallbacks watermark_callbacks_;\n\n  // The gRPC stream to the external processor, which will be opened\n  // when it's time to send the first message.\n  ExternalProcessorStream* stream_ = nullptr;\n\n  std::unique_ptr<OnProcessingResponse> on_processing_response_;\n\n  // Set to true when no more messages need to be sent to the processor.\n  // This happens when the processor has closed the stream, or when it has\n  // failed.\n  bool processing_complete_ = false;\n\n  // Set to true when an \"immediate response\" has been delivered. This helps us\n  // know what response to return from certain failures.\n  bool sent_immediate_response_ = false;\n\n  // Set to true when the mergePerRouteConfig() method has been called.\n  bool route_config_merged_ = false;\n\n  // If true, the protocol configurations are already sent to the server.\n  bool protocol_config_encoded_ = false;\n};\n\nextern std::string responseCaseToString(\n    const envoy::service::ext_proc::v3::ProcessingResponse::ResponseCase response_case);\n\n} // namespace ExternalProcessing\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy", "target": 0}
{"idx": 86, "func": "static int adapter_loop(enum neu_event_io_type type, int fd, void *usr_data)\n{\n    neu_adapter_t *adapter = (neu_adapter_t *) usr_data;\n\n    if (type != NEU_EVENT_IO_READ) {\n        nlog_warn(\"adapter: %s recv close, exit loop, fd: %d\", adapter->name,\n                  fd);\n        return 0;\n    }\n\n    neu_msg_t *msg = NULL;\n    int        rv  = neu_recv_msg(adapter->control_fd, &msg);\n    if (0 != rv) {\n        nlog_warn(\"adapter: %s recv failed, ret: %d, errno: %s(%d)\",\n                  adapter->name, rv, strerror(errno), errno);\n        return 0;\n    }\n\n    neu_reqresp_head_t *header = neu_msg_get_header(msg);\n\n    nlog_info(\"adapter(%s) recv msg from: %s %p, type: %s\", adapter->name,\n              header->sender, header->ctx,\n              neu_reqresp_type_string(header->type));\n\n    switch (header->type) {\n    case NEU_REQ_SUBSCRIBE_GROUP: {\n        neu_req_subscribe_t *cmd = (neu_req_subscribe_t *) &header[1];\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            neu_adapter_driver_subscribe((neu_adapter_driver_t *) adapter, cmd);\n        } else {\n            adapter->module->intf_funs->request(\n                adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        }\n        neu_msg_free(msg);\n        break;\n    }\n    case NEU_REQ_UNSUBSCRIBE_GROUP: {\n        neu_req_unsubscribe_t *cmd = (neu_req_unsubscribe_t *) &header[1];\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            neu_adapter_driver_unsubscribe((neu_adapter_driver_t *) adapter,\n                                           cmd);\n        } else {\n            adapter->module->intf_funs->request(\n                adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        }\n        neu_msg_free(msg);\n        break;\n    }\n    case NEU_REQ_UPDATE_SUBSCRIBE_GROUP:\n    case NEU_RESP_GET_DRIVER_GROUP:\n    case NEU_REQRESP_NODE_DELETED:\n    case NEU_RESP_GET_SUB_DRIVER_TAGS:\n    case NEU_REQ_UPDATE_NODE:\n    case NEU_RESP_GET_NODE_STATE:\n    case NEU_RESP_GET_NODES_STATE:\n    case NEU_RESP_GET_NODE_SETTING:\n    case NEU_REQ_UPDATE_GROUP:\n    case NEU_RESP_GET_SUBSCRIBE_GROUP:\n    case NEU_RESP_ADD_TAG:\n    case NEU_RESP_ADD_GTAG:\n    case NEU_RESP_UPDATE_TAG:\n    case NEU_RESP_GET_TAG:\n    case NEU_RESP_GET_NODE:\n    case NEU_RESP_GET_PLUGIN:\n    case NEU_RESP_GET_GROUP:\n    case NEU_RESP_ERROR:\n    case NEU_REQRESP_NODES_STATE:\n    case NEU_REQ_PRGFILE_PROCESS:\n    case NEU_RESP_PRGFILE_PROCESS:\n        adapter->module->intf_funs->request(\n            adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        neu_msg_free(msg);\n        break;\n    case NEU_RESP_READ_GROUP:\n        adapter->module->intf_funs->request(\n            adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        neu_resp_read_free((neu_resp_read_group_t *) &header[1]);\n        neu_msg_free(msg);\n        break;\n    case NEU_REQ_READ_GROUP: {\n        neu_resp_error_t error = { 0 };\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            neu_adapter_driver_read_group((neu_adapter_driver_t *) adapter,\n                                          header);\n        } else {\n            neu_req_read_group_fini((neu_req_read_group_t *) &header[1]);\n            error.error  = NEU_ERR_GROUP_NOT_ALLOW;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(adapter, header, &error);\n        }\n\n        break;\n    }\n    case NEU_RESP_READ_GROUP_PAGINATE:\n        adapter->module->intf_funs->request(\n            adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        neu_resp_read_paginate_free(\n            (neu_resp_read_group_paginate_t *) &header[1]);\n        neu_msg_free(msg);\n        break;\n    case NEU_REQ_READ_GROUP_PAGINATE: {\n        neu_resp_error_t error = { 0 };\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            neu_adapter_driver_read_group_paginate(\n                (neu_adapter_driver_t *) adapter, header);\n        } else {\n            neu_req_read_group_paginate_fini(\n                (neu_req_read_group_paginate_t *) &header[1]);\n            error.error  = NEU_ERR_GROUP_NOT_ALLOW;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(adapter, header, &error);\n        }\n\n        break;\n    }\n    case NEU_REQ_WRITE_TAG: {\n        neu_resp_error_t error = { 0 };\n\n        neu_otel_trace_ctx trace = NULL;\n        neu_otel_scope_ctx scope = NULL;\n        if (neu_otel_control_is_started()) {\n            trace = neu_otel_find_trace(header->ctx);\n            if (trace) {\n                scope = neu_otel_add_span(trace);\n                neu_otel_scope_set_span_name(scope, \"adapter write tag\");\n                char new_span_id[36] = { 0 };\n                neu_otel_new_span_id(new_span_id);\n                neu_otel_scope_set_span_id(scope, new_span_id);\n                uint8_t *p_sp_id = neu_otel_scope_get_pre_span_id(scope);\n                if (p_sp_id) {\n                    neu_otel_scope_set_parent_span_id2(scope, p_sp_id, 8);\n                }\n                neu_otel_scope_add_span_attr_int(scope, \"thread id\",\n                                                 (int64_t) pthread_self());\n                neu_otel_scope_set_span_start_time(scope, neu_time_ns());\n            }\n        }\n\n        bool re_flag = false;\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            int w_error = neu_adapter_driver_write_tag(\n                (neu_adapter_driver_t *) adapter, header);\n            if (NEU_ERR_SUCCESS == w_error) {\n                re_flag = true;\n            } else {\n                if (neu_otel_control_is_started() && trace) {\n                    if (w_error != NEU_ERR_SUCCESS) {\n                        neu_otel_scope_set_status_code2(\n                            scope, NEU_OTEL_STATUS_ERROR, w_error);\n                    } else {\n                        neu_otel_scope_set_status_code2(\n                            scope, NEU_OTEL_STATUS_OK, w_error);\n                    }\n                }\n            }\n        } else {\n            neu_req_write_tag_fini((neu_req_write_tag_t *) &header[1]);\n            error.error  = NEU_ERR_GROUP_NOT_ALLOW;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(adapter, header, &error);\n            if (neu_otel_control_is_started() && trace) {\n                neu_otel_scope_set_status_code2(scope, NEU_OTEL_STATUS_ERROR,\n                                                NEU_ERR_GROUP_NOT_ALLOW);\n            }\n        }\n\n        if (neu_otel_control_is_started() && trace) {\n            neu_otel_scope_set_span_end_time(scope, neu_time_ns());\n            if (!re_flag) {\n                neu_otel_trace_set_final(trace);\n            }\n        }\n\n        break;\n    }\n    case NEU_REQ_WRITE_TAGS: {\n        neu_resp_error_t error = { 0 };\n\n        neu_otel_trace_ctx trace = NULL;\n        neu_otel_scope_ctx scope = NULL;\n        if (neu_otel_control_is_started()) {\n            trace = neu_otel_find_trace(header->ctx);\n            if (trace) {\n                scope = neu_otel_add_span(trace);\n                neu_otel_scope_set_span_name(scope, \"adapter write tags\");\n                char new_span_id[36] = { 0 };\n                neu_otel_new_span_id(new_span_id);\n                neu_otel_scope_set_span_id(scope, new_span_id);\n                uint8_t *p_sp_id = neu_otel_scope_get_pre_span_id(scope);\n                if (p_sp_id) {\n                    neu_otel_scope_set_parent_span_id2(scope, p_sp_id, 8);\n                }\n                neu_otel_scope_add_span_attr_int(scope, \"thread id\",\n                                                 (int64_t) pthread_self());\n                neu_otel_scope_set_span_start_time(scope, neu_time_ns());\n            }\n        }\n\n        bool re_flag = false;\n\n        if (adapter->module->type != NEU_NA_TYPE_DRIVER) {\n            neu_req_write_tags_fini((neu_req_write_tags_t *) &header[1]);\n            error.error  = NEU_ERR_GROUP_NOT_ALLOW;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(adapter, header, &error);\n            if (neu_otel_control_is_started() && trace) {\n                neu_otel_scope_set_status_code2(scope, NEU_OTEL_STATUS_ERROR,\n                                                NEU_ERR_GROUP_NOT_ALLOW);\n            }\n        } else {\n            int w_error = neu_adapter_driver_write_tags(\n                (neu_adapter_driver_t *) adapter, header);\n\n            if (NEU_ERR_SUCCESS == w_error) {\n                re_flag = true;\n            } else {\n                if (neu_otel_control_is_started() && trace) {\n                    if (neu_otel_control_is_started() && trace) {\n                        if (w_error != NEU_ERR_SUCCESS) {\n                            neu_otel_scope_set_status_code2(\n                                scope, NEU_OTEL_STATUS_ERROR, w_error);\n                        } else {\n                            neu_otel_scope_set_status_code2(\n                                scope, NEU_OTEL_STATUS_OK, w_error);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (neu_otel_control_is_started() && trace) {\n            neu_otel_scope_set_span_end_time(scope, neu_time_ns());\n            if (!re_flag) {\n                neu_otel_trace_set_final(trace);\n            }\n        }\n\n        break;\n    }\n    case NEU_REQ_WRITE_GTAGS: {\n        neu_resp_error_t error = { 0 };\n\n        neu_otel_trace_ctx trace = NULL;\n        neu_otel_scope_ctx scope = NULL;\n        if (neu_otel_control_is_started()) {\n            trace = neu_otel_find_trace(header->ctx);\n            if (trace) {\n                scope = neu_otel_add_span(trace);\n                neu_otel_scope_set_span_name(scope, \"adapter write tags\");\n                char new_span_id[36] = { 0 };\n                neu_otel_new_span_id(new_span_id);\n                neu_otel_scope_set_span_id(scope, new_span_id);\n                uint8_t *p_sp_id = neu_otel_scope_get_pre_span_id(scope);\n                if (p_sp_id) {\n                    neu_otel_scope_set_parent_span_id2(scope, p_sp_id, 8);\n                }\n                neu_otel_scope_add_span_attr_int(scope, \"thread id\",\n                                                 (int64_t) pthread_self());\n                neu_otel_scope_set_span_start_time(scope, neu_time_ns());\n            }\n        }\n\n        bool re_flag = false;\n\n        if (adapter->module->type != NEU_NA_TYPE_DRIVER) {\n            neu_req_write_gtags_fini((neu_req_write_gtags_t *) &header[1]);\n            error.error  = NEU_ERR_GROUP_NOT_ALLOW;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(adapter, header, &error);\n\n            if (neu_otel_control_is_started() && trace) {\n                neu_otel_scope_set_status_code2(scope, NEU_OTEL_STATUS_ERROR,\n                                                NEU_ERR_GROUP_NOT_ALLOW);\n            }\n        } else {\n            int w_error = neu_adapter_driver_write_gtags(\n                (neu_adapter_driver_t *) adapter, header);\n\n            if (NEU_ERR_SUCCESS == w_error) {\n                re_flag = true;\n            } else {\n                if (neu_otel_control_is_started() && trace) {\n                    if (neu_otel_control_is_started() && trace) {\n                        if (w_error != NEU_ERR_SUCCESS) {\n                            neu_otel_scope_set_status_code2(\n                                scope, NEU_OTEL_STATUS_ERROR, w_error);\n                        } else {\n                            neu_otel_scope_set_status_code2(\n                                scope, NEU_OTEL_STATUS_OK, w_error);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (neu_otel_control_is_started() && trace) {\n            neu_otel_scope_set_span_end_time(scope, neu_time_ns());\n            if (!re_flag) {\n                neu_otel_trace_set_final(trace);\n            }\n        }\n        break;\n    }\n    case NEU_REQ_NODE_SETTING: {\n        neu_req_node_setting_t *cmd   = (neu_req_node_setting_t *) &header[1];\n        neu_resp_error_t        error = { 0 };\n        nlog_notice(\"setting node:%s params:%s\", cmd->node, cmd->setting);\n        error.error = neu_adapter_set_setting(adapter, cmd->setting);\n        if (error.error == NEU_ERR_SUCCESS) {\n            adapter_storage_setting(adapter->name, cmd->setting);\n            free(cmd->setting);\n        } else {\n            free(cmd->setting);\n        }\n\n        header->type = NEU_RESP_ERROR;\n        neu_msg_exchange(header);\n        reply(adapter, header, &error);\n        break;\n    }\n    case NEU_REQ_GET_NODE_SETTING: {\n        neu_resp_get_node_setting_t resp  = { 0 };\n        neu_resp_error_t            error = { 0 };\n\n        neu_msg_exchange(header);\n        error.error = neu_adapter_get_setting(adapter, &resp.setting);\n        if (error.error != NEU_ERR_SUCCESS) {\n            header->type = NEU_RESP_ERROR;\n            reply(adapter, header, &error);\n        } else {\n            header->type = NEU_RESP_GET_NODE_SETTING;\n            strcpy(resp.node, adapter->name);\n            reply(adapter, header, &resp);\n        }\n        break;\n    }\n    case NEU_REQ_GET_NODE_STATE: {\n        neu_resp_get_node_state_t *resp =\n            (neu_resp_get_node_state_t *) &header[1];\n\n        if (NULL != adapter->metrics) {\n            pthread_mutex_lock(&adapter->metrics->lock);\n            neu_metric_entry_t *e = NULL;\n            HASH_FIND_STR(adapter->metrics->entries, NEU_METRIC_LAST_RTT_MS, e);\n            resp->rtt = NULL != e ? e->value : 0;\n            pthread_mutex_unlock(&adapter->metrics->lock);\n        }\n        resp->state  = neu_adapter_get_state(adapter);\n        header->type = NEU_RESP_GET_NODE_STATE;\n        neu_msg_exchange(header);\n        reply(adapter, header, resp);\n        break;\n    }\n    case NEU_REQ_GET_GROUP: {\n        neu_msg_exchange(header);\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            neu_resp_get_group_t resp = {\n                .groups = neu_adapter_driver_get_group(\n                    (neu_adapter_driver_t *) adapter)\n            };\n            header->type = NEU_RESP_GET_GROUP;\n            reply(adapter, header, &resp);\n        } else {\n            neu_resp_error_t error = { .error = NEU_ERR_GROUP_NOT_ALLOW };\n\n            header->type = NEU_RESP_ERROR;\n            reply(adapter, header, &error);\n        }\n        break;\n    }\n    case NEU_REQ_GET_TAG: {\n        neu_req_get_tag_t *cmd   = (neu_req_get_tag_t *) &header[1];\n        neu_resp_error_t   error = { .error = 0 };\n        UT_array *         tags  = NULL;\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            error.error = neu_adapter_driver_query_tag(\n                (neu_adapter_driver_t *) adapter, cmd->group, cmd->name, &tags);\n        } else {\n            error.error = NEU_ERR_GROUP_NOT_ALLOW;\n        }\n\n        neu_msg_exchange(header);\n        if (error.error != NEU_ERR_SUCCESS) {\n            header->type = NEU_RESP_ERROR;\n            reply(adapter, header, &error);\n        } else {\n            neu_resp_get_tag_t resp = { .tags = tags };\n\n            header->type = NEU_RESP_GET_TAG;\n            reply(adapter, header, &resp);\n        }\n\n        break;\n    }\n    case NEU_REQ_ADD_GROUP: {\n        neu_req_add_group_t *cmd   = (neu_req_add_group_t *) &header[1];\n        neu_resp_error_t     error = { 0 };\n        nlog_notice(\"add group node:%s group:%s interval:%d\", cmd->driver,\n                    cmd->group, cmd->interval);\n        if (cmd->interval < NEU_GROUP_INTERVAL_LIMIT) {\n            error.error = NEU_ERR_GROUP_PARAMETER_INVALID;\n        } else {\n            if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n                error.error = neu_adapter_driver_add_group(\n                    (neu_adapter_driver_t *) adapter, cmd->group, cmd->interval,\n                    NULL);\n            } else {\n                error.error = NEU_ERR_GROUP_NOT_ALLOW;\n            }\n        }\n\n        if (error.error == NEU_ERR_SUCCESS) {\n            adapter_storage_add_group(adapter->name, cmd->group, cmd->interval,\n                                      NULL);\n        }\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ERROR;\n        reply(adapter, header, &error);\n        break;\n    }\n    case NEU_REQ_UPDATE_DRIVER_GROUP: {\n        neu_req_update_group_t *cmd  = (neu_req_update_group_t *) &header[1];\n        neu_resp_update_group_t resp = { 0 };\n        nlog_notice(\"update group node:%s old_name:%s new_name:%s interval:%d\",\n                    header->receiver, cmd->group, cmd->new_name, cmd->interval);\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            resp.error = neu_adapter_driver_update_group(\n                (neu_adapter_driver_t *) adapter, cmd->group, cmd->new_name,\n                cmd->interval);\n        } else {\n            resp.error = NEU_ERR_GROUP_NOT_ALLOW;\n        }\n\n        if (resp.error == NEU_ERR_SUCCESS) {\n            adapter_storage_update_group(adapter->name, cmd->group,\n                                         cmd->new_name, cmd->interval);\n        }\n\n        strcpy(resp.driver, cmd->driver);\n        strcpy(resp.group, cmd->group);\n        strcpy(resp.new_name, cmd->new_name);\n        header->type = NEU_RESP_UPDATE_DRIVER_GROUP;\n        neu_msg_exchange(header);\n        reply(adapter, header, &resp);\n        break;\n    }\n    case NEU_REQ_DEL_GROUP: {\n        neu_req_del_group_t *cmd   = (neu_req_del_group_t *) &header[1];\n        neu_resp_error_t     error = { 0 };\n        nlog_notice(\"del group node:%s group:%s\", cmd->driver, cmd->group);\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            error.error = neu_adapter_driver_del_group(\n                (neu_adapter_driver_t *) adapter, cmd->group);\n        } else {\n            adapter->module->intf_funs->request(\n                adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n            neu_msg_free(msg);\n            break;\n        }\n\n        if (error.error == NEU_ERR_SUCCESS) {\n            adapter_storage_del_group(cmd->driver, cmd->group);\n        }\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ERROR;\n        reply(adapter, header, &error);\n        break;\n    }\n    case NEU_REQ_NODE_CTL: {\n        neu_req_node_ctl_t *cmd   = (neu_req_node_ctl_t *) &header[1];\n        neu_resp_error_t    error = { 0 };\n\n        switch (cmd->ctl) {\n        case NEU_ADAPTER_CTL_START:\n            error.error = neu_adapter_start(adapter);\n            break;\n        case NEU_ADAPTER_CTL_STOP:\n            error.error = neu_adapter_stop(adapter);\n            break;\n        }\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ERROR;\n        reply(adapter, header, &error);\n        break;\n    }\n    case NEU_REQ_NODE_RENAME: {\n        neu_req_node_rename_t *cmd  = (neu_req_node_rename_t *) &header[1];\n        neu_resp_node_rename_t resp = { 0 };\n        resp.error = neu_adapter_rename(adapter, cmd->new_name);\n        strcpy(header->receiver, header->sender);\n        strcpy(header->sender, cmd->new_name);\n        strcpy(resp.node, cmd->node);\n        strcpy(resp.new_name, cmd->new_name);\n        header->type = NEU_RESP_NODE_RENAME;\n        reply(adapter, header, &resp);\n        break;\n    }\n    case NEU_REQ_DEL_TAG: {\n        neu_req_del_tag_t *cmd   = (neu_req_del_tag_t *) &header[1];\n        neu_resp_error_t   error = { 0 };\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            for (int i = 0; i < cmd->n_tag; i++) {\n                nlog_notice(\"del tag node:%s group:%s tag:%s\", cmd->driver,\n                            cmd->group, cmd->tags[i]);\n                int ret = neu_adapter_driver_del_tag(\n                    (neu_adapter_driver_t *) adapter, cmd->group, cmd->tags[i]);\n                if (0 == ret) {\n                    adapter_storage_del_tag(cmd->driver, cmd->group,\n                                            cmd->tags[i]);\n                } else {\n                    error.error = ret;\n                    break;\n                }\n            }\n        } else {\n            error.error = NEU_ERR_GROUP_NOT_ALLOW;\n        }\n\n        for (uint16_t i = 0; i < cmd->n_tag; i++) {\n            free(cmd->tags[i]);\n        }\n        free(cmd->tags);\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ERROR;\n        reply(adapter, header, &error);\n        break;\n    }\n    case NEU_REQ_ADD_TAG: {\n        neu_req_add_tag_t *cmd  = (neu_req_add_tag_t *) &header[1];\n        neu_resp_add_tag_t resp = { 0 };\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            for (int i = 0; i < cmd->n_tag; i++) {\n                int ret = neu_adapter_driver_validate_tag(\n                    (neu_adapter_driver_t *) adapter, cmd->group,\n                    &cmd->tags[i]);\n                if (ret == 0) {\n                    resp.index += 1;\n                } else {\n                    resp.error = ret;\n                    break;\n                }\n            }\n        } else {\n            resp.error = NEU_ERR_GROUP_NOT_ALLOW;\n        }\n\n        if (resp.index > 0) {\n            int ret = neu_adapter_driver_try_add_tag(\n                (neu_adapter_driver_t *) adapter, cmd->group, cmd->tags,\n                resp.index);\n            if (ret != 0) {\n                resp.index = 0;\n                resp.error = ret;\n            }\n        }\n\n        for (int i = 0; i < resp.index; i++) {\n            int ret = neu_adapter_driver_add_tag(\n                (neu_adapter_driver_t *) adapter, cmd->group, &cmd->tags[i],\n                NEU_DEFAULT_GROUP_INTERVAL);\n            if (ret != 0) {\n                neu_adapter_driver_try_del_tag((neu_adapter_driver_t *) adapter,\n                                               resp.index - i);\n                resp.index = i;\n                resp.error = ret;\n                break;\n            }\n        }\n\n        if (resp.index) {\n            // we have added some tags, try to persist\n            adapter_storage_add_tags(cmd->driver, cmd->group, cmd->tags,\n                                     resp.index);\n        }\n\n        for (uint16_t i = 0; i < cmd->n_tag; i++) {\n            neu_tag_fini(&cmd->tags[i]);\n        }\n        free(cmd->tags);\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ADD_TAG;\n        reply(adapter, header, &resp);\n        break;\n    }\n    case NEU_REQ_ADD_GTAG: {\n        neu_req_add_gtag_t *cmd  = (neu_req_add_gtag_t *) &header[1];\n        neu_resp_add_tag_t  resp = { 0 };\n\n        if (adapter->module->type != NEU_NA_TYPE_DRIVER) {\n            resp.error = NEU_ERR_GROUP_NOT_ALLOW;\n        } else {\n            if (neu_adapter_validate_gtags(adapter, cmd, &resp) == 0 &&\n                neu_adapter_try_add_gtags(adapter, cmd, &resp) == 0 &&\n                neu_adapter_add_gtags(adapter, cmd, &resp) == 0) {\n                for (int i = 0; i < cmd->n_group; i++) {\n                    adapter_storage_add_tags(cmd->driver, cmd->groups[i].group,\n                                             cmd->groups[i].tags,\n                                             cmd->groups[i].n_tag);\n                }\n            }\n        }\n\n        for (int i = 0; i < cmd->n_group; i++) {\n            for (int j = 0; j < cmd->groups[i].n_tag; j++) {\n                neu_tag_fini(&cmd->groups[i].tags[j]);\n            }\n            free(cmd->groups[i].tags);\n        }\n        free(cmd->groups);\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ADD_GTAG;\n        reply(adapter, header, &resp);\n        break;\n    }\n    case NEU_REQ_UPDATE_TAG: {\n        neu_req_update_tag_t *cmd  = (neu_req_update_tag_t *) &header[1];\n        neu_resp_update_tag_t resp = { 0 };\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n\n            for (int i = 0; i < cmd->n_tag; i++) {\n                int ret = neu_adapter_driver_validate_tag(\n                    (neu_adapter_driver_t *) adapter, cmd->group,\n                    &cmd->tags[i]);\n                if (ret == 0) {\n                    ret = neu_adapter_driver_update_tag(\n                        (neu_adapter_driver_t *) adapter, cmd->group,\n                        &cmd->tags[i]);\n                    if (ret == 0) {\n                        adapter_storage_update_tag(cmd->driver, cmd->group,\n                                                   &cmd->tags[i]);\n\n                        resp.index += 1;\n                    } else {\n                        resp.error = ret;\n                        break;\n                    }\n                } else {\n                    resp.error = ret;\n                    break;\n                }\n            }\n        } else {\n            resp.error = NEU_ERR_GROUP_NOT_ALLOW;\n        }\n\n        for (uint16_t i = 0; i < cmd->n_tag; i++) {\n            neu_tag_fini(&cmd->tags[i]);\n        }\n        free(cmd->tags);\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_UPDATE_TAG;\n        reply(adapter, header, &resp);\n        break;\n    }\n    case NEU_REQ_NODE_UNINIT: {\n        neu_req_node_uninit_t *cmd = (neu_req_node_uninit_t *) &header[1];\n        char                   name[NEU_NODE_NAME_LEN]     = { 0 };\n        char                   receiver[NEU_NODE_NAME_LEN] = { 0 };\n\n        neu_adapter_uninit(adapter);\n\n        header->type = NEU_RESP_NODE_UNINIT;\n        neu_msg_exchange(header);\n        strcpy(header->sender, adapter->name);\n        strcpy(cmd->node, adapter->name);\n\n        neu_msg_gen(header, cmd);\n\n        strcpy(name, adapter->name);\n        strcpy(receiver, header->receiver);\n\n        int ret = neu_send_msg(adapter->control_fd, msg);\n        if (0 != ret) {\n            nlog_error(\"%s %d send uninit msg to %s error: %s(%d)\", name,\n                       adapter->control_fd, receiver, strerror(errno), errno);\n            neu_msg_free(msg);\n        } else {\n            nlog_notice(\"%s send uninit msg to %s succeeded\", name, receiver);\n        }\n        break;\n    }\n    case NEU_REQ_UPDATE_LOG_LEVEL: {\n        neu_req_update_log_level_t *cmd =\n            (neu_req_update_log_level_t *) &header[1];\n        neu_resp_error_t error = { 0 };\n        adapter->log_level     = cmd->log_level;\n        zlog_level_switch(neu_plugin_to_plugin_common(adapter->plugin)->log,\n                          cmd->log_level);\n\n        struct timeval tv = { 0 };\n        gettimeofday(&tv, NULL);\n        adapter->timestamp_lev = tv.tv_sec;\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ERROR;\n        reply(adapter, header, &error);\n\n        break;\n    }\n    case NEU_REQ_PRGFILE_UPLOAD: {\n        adapter->module->intf_funs->request(\n            adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        break;\n    }\n    case NEU_REQ_SCAN_TAGS: {\n        neu_adapter_driver_scan_tags((neu_adapter_driver_t *) adapter, header);\n        break;\n    }\n    case NEU_RESP_SCAN_TAGS: {\n        adapter->module->intf_funs->request(\n            adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        neu_msg_free(msg);\n        break;\n    }\n    case NEU_REQ_TEST_READ_TAG: {\n        neu_adapter_driver_test_read_tag((neu_adapter_driver_t *) adapter,\n                                         header);\n        break;\n    }\n    case NEU_RESP_TEST_READ_TAG: {\n        adapter->module->intf_funs->request(\n            adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        neu_msg_free(msg);\n        break;\n    }\n    default:\n        nlog_warn(\"adapter: %s recv msg type error, type: %s\", adapter->name,\n                  neu_reqresp_type_string(header->type));\n        assert(false);\n        break;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 87, "func": "static int adapter_loop(enum neu_event_io_type type, int fd, void *usr_data)\n{\n    neu_adapter_t *adapter = (neu_adapter_t *) usr_data;\n\n    if (type != NEU_EVENT_IO_READ) {\n        nlog_warn(\"adapter: %s recv close, exit loop, fd: %d\", adapter->name,\n                  fd);\n        return 0;\n    }\n\n    neu_msg_t *msg = NULL;\n    int        rv  = neu_recv_msg(adapter->control_fd, &msg);\n    if (0 != rv) {\n        nlog_warn(\"adapter: %s recv failed, ret: %d, errno: %s(%d)\",\n                  adapter->name, rv, strerror(errno), errno);\n        return 0;\n    }\n\n    neu_reqresp_head_t *header = neu_msg_get_header(msg);\n\n    nlog_info(\"adapter(%s) recv msg from: %s %p, type: %s\", adapter->name,\n              header->sender, header->ctx,\n              neu_reqresp_type_string(header->type));\n\n    switch (header->type) {\n    case NEU_REQ_SUBSCRIBE_GROUP: {\n        neu_req_subscribe_t *cmd = (neu_req_subscribe_t *) &header[1];\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            neu_adapter_driver_subscribe((neu_adapter_driver_t *) adapter, cmd);\n        } else {\n            adapter->module->intf_funs->request(\n                adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        }\n        neu_msg_free(msg);\n        break;\n    }\n    case NEU_REQ_UNSUBSCRIBE_GROUP: {\n        neu_req_unsubscribe_t *cmd = (neu_req_unsubscribe_t *) &header[1];\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            neu_adapter_driver_unsubscribe((neu_adapter_driver_t *) adapter,\n                                           cmd);\n        } else {\n            adapter->module->intf_funs->request(\n                adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        }\n        neu_msg_free(msg);\n        break;\n    }\n    case NEU_REQ_UPDATE_SUBSCRIBE_GROUP:\n    case NEU_RESP_GET_DRIVER_GROUP:\n    case NEU_REQRESP_NODE_DELETED:\n    case NEU_RESP_GET_SUB_DRIVER_TAGS:\n    case NEU_REQ_UPDATE_NODE:\n    case NEU_RESP_GET_NODE_STATE:\n    case NEU_RESP_GET_NODES_STATE:\n    case NEU_RESP_GET_NODE_SETTING:\n    case NEU_REQ_UPDATE_GROUP:\n    case NEU_RESP_GET_SUBSCRIBE_GROUP:\n    case NEU_RESP_ADD_TAG:\n    case NEU_RESP_ADD_GTAG:\n    case NEU_RESP_UPDATE_TAG:\n    case NEU_RESP_GET_TAG:\n    case NEU_RESP_GET_NODE:\n    case NEU_RESP_GET_PLUGIN:\n    case NEU_RESP_GET_GROUP:\n    case NEU_RESP_ERROR:\n    case NEU_REQRESP_NODES_STATE:\n    case NEU_REQ_PRGFILE_PROCESS:\n    case NEU_RESP_PRGFILE_PROCESS:\n    case NEU_RESP_CHECK_SCHEMA:\n        adapter->module->intf_funs->request(\n            adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        neu_msg_free(msg);\n        break;\n    case NEU_RESP_READ_GROUP:\n        adapter->module->intf_funs->request(\n            adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        neu_resp_read_free((neu_resp_read_group_t *) &header[1]);\n        neu_msg_free(msg);\n        break;\n    case NEU_REQ_READ_GROUP: {\n        neu_resp_error_t error = { 0 };\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            neu_adapter_driver_read_group((neu_adapter_driver_t *) adapter,\n                                          header);\n        } else {\n            neu_req_read_group_fini((neu_req_read_group_t *) &header[1]);\n            error.error  = NEU_ERR_GROUP_NOT_ALLOW;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(adapter, header, &error);\n        }\n\n        break;\n    }\n    case NEU_RESP_READ_GROUP_PAGINATE:\n        adapter->module->intf_funs->request(\n            adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        neu_resp_read_paginate_free(\n            (neu_resp_read_group_paginate_t *) &header[1]);\n        neu_msg_free(msg);\n        break;\n    case NEU_REQ_READ_GROUP_PAGINATE: {\n        neu_resp_error_t error = { 0 };\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            neu_adapter_driver_read_group_paginate(\n                (neu_adapter_driver_t *) adapter, header);\n        } else {\n            neu_req_read_group_paginate_fini(\n                (neu_req_read_group_paginate_t *) &header[1]);\n            error.error  = NEU_ERR_GROUP_NOT_ALLOW;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(adapter, header, &error);\n        }\n\n        break;\n    }\n    case NEU_REQ_WRITE_TAG: {\n        neu_resp_error_t error = { 0 };\n\n        neu_otel_trace_ctx trace = NULL;\n        neu_otel_scope_ctx scope = NULL;\n        if (neu_otel_control_is_started()) {\n            trace = neu_otel_find_trace(header->ctx);\n            if (trace) {\n                scope = neu_otel_add_span(trace);\n                neu_otel_scope_set_span_name(scope, \"adapter write tag\");\n                char new_span_id[36] = { 0 };\n                neu_otel_new_span_id(new_span_id);\n                neu_otel_scope_set_span_id(scope, new_span_id);\n                uint8_t *p_sp_id = neu_otel_scope_get_pre_span_id(scope);\n                if (p_sp_id) {\n                    neu_otel_scope_set_parent_span_id2(scope, p_sp_id, 8);\n                }\n                neu_otel_scope_add_span_attr_int(scope, \"thread id\",\n                                                 (int64_t) pthread_self());\n                neu_otel_scope_set_span_start_time(scope, neu_time_ns());\n            }\n        }\n\n        bool re_flag = false;\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            int w_error = neu_adapter_driver_write_tag(\n                (neu_adapter_driver_t *) adapter, header);\n            if (NEU_ERR_SUCCESS == w_error) {\n                re_flag = true;\n            } else {\n                if (neu_otel_control_is_started() && trace) {\n                    if (w_error != NEU_ERR_SUCCESS) {\n                        neu_otel_scope_set_status_code2(\n                            scope, NEU_OTEL_STATUS_ERROR, w_error);\n                    } else {\n                        neu_otel_scope_set_status_code2(\n                            scope, NEU_OTEL_STATUS_OK, w_error);\n                    }\n                }\n            }\n        } else {\n            neu_req_write_tag_fini((neu_req_write_tag_t *) &header[1]);\n            error.error  = NEU_ERR_GROUP_NOT_ALLOW;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(adapter, header, &error);\n            if (neu_otel_control_is_started() && trace) {\n                neu_otel_scope_set_status_code2(scope, NEU_OTEL_STATUS_ERROR,\n                                                NEU_ERR_GROUP_NOT_ALLOW);\n            }\n        }\n\n        if (neu_otel_control_is_started() && trace) {\n            neu_otel_scope_set_span_end_time(scope, neu_time_ns());\n            if (!re_flag) {\n                neu_otel_trace_set_final(trace);\n            }\n        }\n\n        break;\n    }\n    case NEU_REQ_WRITE_TAGS: {\n        neu_resp_error_t error = { 0 };\n\n        neu_otel_trace_ctx trace = NULL;\n        neu_otel_scope_ctx scope = NULL;\n        if (neu_otel_control_is_started()) {\n            trace = neu_otel_find_trace(header->ctx);\n            if (trace) {\n                scope = neu_otel_add_span(trace);\n                neu_otel_scope_set_span_name(scope, \"adapter write tags\");\n                char new_span_id[36] = { 0 };\n                neu_otel_new_span_id(new_span_id);\n                neu_otel_scope_set_span_id(scope, new_span_id);\n                uint8_t *p_sp_id = neu_otel_scope_get_pre_span_id(scope);\n                if (p_sp_id) {\n                    neu_otel_scope_set_parent_span_id2(scope, p_sp_id, 8);\n                }\n                neu_otel_scope_add_span_attr_int(scope, \"thread id\",\n                                                 (int64_t) pthread_self());\n                neu_otel_scope_set_span_start_time(scope, neu_time_ns());\n            }\n        }\n\n        bool re_flag = false;\n\n        if (adapter->module->type != NEU_NA_TYPE_DRIVER) {\n            neu_req_write_tags_fini((neu_req_write_tags_t *) &header[1]);\n            error.error  = NEU_ERR_GROUP_NOT_ALLOW;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(adapter, header, &error);\n            if (neu_otel_control_is_started() && trace) {\n                neu_otel_scope_set_status_code2(scope, NEU_OTEL_STATUS_ERROR,\n                                                NEU_ERR_GROUP_NOT_ALLOW);\n            }\n        } else {\n            int w_error = neu_adapter_driver_write_tags(\n                (neu_adapter_driver_t *) adapter, header);\n\n            if (NEU_ERR_SUCCESS == w_error) {\n                re_flag = true;\n            } else {\n                if (neu_otel_control_is_started() && trace) {\n                    if (neu_otel_control_is_started() && trace) {\n                        if (w_error != NEU_ERR_SUCCESS) {\n                            neu_otel_scope_set_status_code2(\n                                scope, NEU_OTEL_STATUS_ERROR, w_error);\n                        } else {\n                            neu_otel_scope_set_status_code2(\n                                scope, NEU_OTEL_STATUS_OK, w_error);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (neu_otel_control_is_started() && trace) {\n            neu_otel_scope_set_span_end_time(scope, neu_time_ns());\n            if (!re_flag) {\n                neu_otel_trace_set_final(trace);\n            }\n        }\n\n        break;\n    }\n    case NEU_REQ_WRITE_GTAGS: {\n        neu_resp_error_t error = { 0 };\n\n        neu_otel_trace_ctx trace = NULL;\n        neu_otel_scope_ctx scope = NULL;\n        if (neu_otel_control_is_started()) {\n            trace = neu_otel_find_trace(header->ctx);\n            if (trace) {\n                scope = neu_otel_add_span(trace);\n                neu_otel_scope_set_span_name(scope, \"adapter write tags\");\n                char new_span_id[36] = { 0 };\n                neu_otel_new_span_id(new_span_id);\n                neu_otel_scope_set_span_id(scope, new_span_id);\n                uint8_t *p_sp_id = neu_otel_scope_get_pre_span_id(scope);\n                if (p_sp_id) {\n                    neu_otel_scope_set_parent_span_id2(scope, p_sp_id, 8);\n                }\n                neu_otel_scope_add_span_attr_int(scope, \"thread id\",\n                                                 (int64_t) pthread_self());\n                neu_otel_scope_set_span_start_time(scope, neu_time_ns());\n            }\n        }\n\n        bool re_flag = false;\n\n        if (adapter->module->type != NEU_NA_TYPE_DRIVER) {\n            neu_req_write_gtags_fini((neu_req_write_gtags_t *) &header[1]);\n            error.error  = NEU_ERR_GROUP_NOT_ALLOW;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(adapter, header, &error);\n\n            if (neu_otel_control_is_started() && trace) {\n                neu_otel_scope_set_status_code2(scope, NEU_OTEL_STATUS_ERROR,\n                                                NEU_ERR_GROUP_NOT_ALLOW);\n            }\n        } else {\n            int w_error = neu_adapter_driver_write_gtags(\n                (neu_adapter_driver_t *) adapter, header);\n\n            if (NEU_ERR_SUCCESS == w_error) {\n                re_flag = true;\n            } else {\n                if (neu_otel_control_is_started() && trace) {\n                    if (neu_otel_control_is_started() && trace) {\n                        if (w_error != NEU_ERR_SUCCESS) {\n                            neu_otel_scope_set_status_code2(\n                                scope, NEU_OTEL_STATUS_ERROR, w_error);\n                        } else {\n                            neu_otel_scope_set_status_code2(\n                                scope, NEU_OTEL_STATUS_OK, w_error);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (neu_otel_control_is_started() && trace) {\n            neu_otel_scope_set_span_end_time(scope, neu_time_ns());\n            if (!re_flag) {\n                neu_otel_trace_set_final(trace);\n            }\n        }\n        break;\n    }\n    case NEU_REQ_NODE_SETTING: {\n        neu_req_node_setting_t *cmd   = (neu_req_node_setting_t *) &header[1];\n        neu_resp_error_t        error = { 0 };\n        nlog_notice(\"setting node:%s params:%s\", cmd->node, cmd->setting);\n        error.error = neu_adapter_set_setting(adapter, cmd->setting);\n        if (error.error == NEU_ERR_SUCCESS) {\n            adapter_storage_setting(adapter->name, cmd->setting);\n            free(cmd->setting);\n        } else {\n            free(cmd->setting);\n        }\n\n        header->type = NEU_RESP_ERROR;\n        neu_msg_exchange(header);\n        reply(adapter, header, &error);\n        break;\n    }\n    case NEU_REQ_GET_NODE_SETTING: {\n        neu_resp_get_node_setting_t resp  = { 0 };\n        neu_resp_error_t            error = { 0 };\n\n        neu_msg_exchange(header);\n        error.error = neu_adapter_get_setting(adapter, &resp.setting);\n        if (error.error != NEU_ERR_SUCCESS) {\n            header->type = NEU_RESP_ERROR;\n            reply(adapter, header, &error);\n        } else {\n            header->type = NEU_RESP_GET_NODE_SETTING;\n            strcpy(resp.node, adapter->name);\n            reply(adapter, header, &resp);\n        }\n        break;\n    }\n    case NEU_REQ_GET_NODE_STATE: {\n        neu_resp_get_node_state_t *resp =\n            (neu_resp_get_node_state_t *) &header[1];\n\n        if (NULL != adapter->metrics) {\n            pthread_mutex_lock(&adapter->metrics->lock);\n            neu_metric_entry_t *e = NULL;\n            HASH_FIND_STR(adapter->metrics->entries, NEU_METRIC_LAST_RTT_MS, e);\n            resp->rtt = NULL != e ? e->value : 0;\n            pthread_mutex_unlock(&adapter->metrics->lock);\n        }\n        resp->state  = neu_adapter_get_state(adapter);\n        header->type = NEU_RESP_GET_NODE_STATE;\n        neu_msg_exchange(header);\n        reply(adapter, header, resp);\n        break;\n    }\n    case NEU_REQ_GET_GROUP: {\n        neu_msg_exchange(header);\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            neu_resp_get_group_t resp = {\n                .groups = neu_adapter_driver_get_group(\n                    (neu_adapter_driver_t *) adapter)\n            };\n            header->type = NEU_RESP_GET_GROUP;\n            reply(adapter, header, &resp);\n        } else {\n            neu_resp_error_t error = { .error = NEU_ERR_GROUP_NOT_ALLOW };\n\n            header->type = NEU_RESP_ERROR;\n            reply(adapter, header, &error);\n        }\n        break;\n    }\n    case NEU_REQ_GET_TAG: {\n        neu_req_get_tag_t *cmd   = (neu_req_get_tag_t *) &header[1];\n        neu_resp_error_t   error = { .error = 0 };\n        UT_array *         tags  = NULL;\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            error.error = neu_adapter_driver_query_tag(\n                (neu_adapter_driver_t *) adapter, cmd->group, cmd->name, &tags);\n        } else {\n            error.error = NEU_ERR_GROUP_NOT_ALLOW;\n        }\n\n        neu_msg_exchange(header);\n        if (error.error != NEU_ERR_SUCCESS) {\n            header->type = NEU_RESP_ERROR;\n            reply(adapter, header, &error);\n        } else {\n            neu_resp_get_tag_t resp = { .tags = tags };\n\n            header->type = NEU_RESP_GET_TAG;\n            reply(adapter, header, &resp);\n        }\n\n        break;\n    }\n    case NEU_REQ_ADD_GROUP: {\n        neu_req_add_group_t *cmd   = (neu_req_add_group_t *) &header[1];\n        neu_resp_error_t     error = { 0 };\n        nlog_notice(\"add group node:%s group:%s interval:%d\", cmd->driver,\n                    cmd->group, cmd->interval);\n        if (cmd->interval < NEU_GROUP_INTERVAL_LIMIT) {\n            error.error = NEU_ERR_GROUP_PARAMETER_INVALID;\n        } else {\n            if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n                error.error = neu_adapter_driver_add_group(\n                    (neu_adapter_driver_t *) adapter, cmd->group, cmd->interval,\n                    NULL);\n            } else {\n                error.error = NEU_ERR_GROUP_NOT_ALLOW;\n            }\n        }\n\n        if (error.error == NEU_ERR_SUCCESS) {\n            adapter_storage_add_group(adapter->name, cmd->group, cmd->interval,\n                                      NULL);\n        }\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ERROR;\n        reply(adapter, header, &error);\n        break;\n    }\n    case NEU_REQ_UPDATE_DRIVER_GROUP: {\n        neu_req_update_group_t *cmd  = (neu_req_update_group_t *) &header[1];\n        neu_resp_update_group_t resp = { 0 };\n        nlog_notice(\"update group node:%s old_name:%s new_name:%s interval:%d\",\n                    header->receiver, cmd->group, cmd->new_name, cmd->interval);\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            resp.error = neu_adapter_driver_update_group(\n                (neu_adapter_driver_t *) adapter, cmd->group, cmd->new_name,\n                cmd->interval);\n        } else {\n            resp.error = NEU_ERR_GROUP_NOT_ALLOW;\n        }\n\n        if (resp.error == NEU_ERR_SUCCESS) {\n            adapter_storage_update_group(adapter->name, cmd->group,\n                                         cmd->new_name, cmd->interval);\n        }\n\n        strcpy(resp.driver, cmd->driver);\n        strcpy(resp.group, cmd->group);\n        strcpy(resp.new_name, cmd->new_name);\n        header->type = NEU_RESP_UPDATE_DRIVER_GROUP;\n        neu_msg_exchange(header);\n        reply(adapter, header, &resp);\n        break;\n    }\n    case NEU_REQ_DEL_GROUP: {\n        neu_req_del_group_t *cmd   = (neu_req_del_group_t *) &header[1];\n        neu_resp_error_t     error = { 0 };\n        nlog_notice(\"del group node:%s group:%s\", cmd->driver, cmd->group);\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            error.error = neu_adapter_driver_del_group(\n                (neu_adapter_driver_t *) adapter, cmd->group);\n        } else {\n            adapter->module->intf_funs->request(\n                adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n            neu_msg_free(msg);\n            break;\n        }\n\n        if (error.error == NEU_ERR_SUCCESS) {\n            adapter_storage_del_group(cmd->driver, cmd->group);\n        }\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ERROR;\n        reply(adapter, header, &error);\n        break;\n    }\n    case NEU_REQ_NODE_CTL: {\n        neu_req_node_ctl_t *cmd   = (neu_req_node_ctl_t *) &header[1];\n        neu_resp_error_t    error = { 0 };\n\n        switch (cmd->ctl) {\n        case NEU_ADAPTER_CTL_START:\n            error.error = neu_adapter_start(adapter);\n            break;\n        case NEU_ADAPTER_CTL_STOP:\n            error.error = neu_adapter_stop(adapter);\n            break;\n        }\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ERROR;\n        reply(adapter, header, &error);\n        break;\n    }\n    case NEU_REQ_NODE_RENAME: {\n        neu_req_node_rename_t *cmd  = (neu_req_node_rename_t *) &header[1];\n        neu_resp_node_rename_t resp = { 0 };\n        resp.error = neu_adapter_rename(adapter, cmd->new_name);\n        strcpy(header->receiver, header->sender);\n        strcpy(header->sender, cmd->new_name);\n        strcpy(resp.node, cmd->node);\n        strcpy(resp.new_name, cmd->new_name);\n        header->type = NEU_RESP_NODE_RENAME;\n        reply(adapter, header, &resp);\n        break;\n    }\n    case NEU_REQ_DEL_TAG: {\n        neu_req_del_tag_t *cmd   = (neu_req_del_tag_t *) &header[1];\n        neu_resp_error_t   error = { 0 };\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            for (int i = 0; i < cmd->n_tag; i++) {\n                nlog_notice(\"del tag node:%s group:%s tag:%s\", cmd->driver,\n                            cmd->group, cmd->tags[i]);\n                int ret = neu_adapter_driver_del_tag(\n                    (neu_adapter_driver_t *) adapter, cmd->group, cmd->tags[i]);\n                if (0 == ret) {\n                    adapter_storage_del_tag(cmd->driver, cmd->group,\n                                            cmd->tags[i]);\n                } else {\n                    error.error = ret;\n                    break;\n                }\n            }\n        } else {\n            error.error = NEU_ERR_GROUP_NOT_ALLOW;\n        }\n\n        for (uint16_t i = 0; i < cmd->n_tag; i++) {\n            free(cmd->tags[i]);\n        }\n        free(cmd->tags);\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ERROR;\n        reply(adapter, header, &error);\n        break;\n    }\n    case NEU_REQ_ADD_TAG: {\n        neu_req_add_tag_t *cmd  = (neu_req_add_tag_t *) &header[1];\n        neu_resp_add_tag_t resp = { 0 };\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n            for (int i = 0; i < cmd->n_tag; i++) {\n                int ret = neu_adapter_driver_validate_tag(\n                    (neu_adapter_driver_t *) adapter, cmd->group,\n                    &cmd->tags[i]);\n                if (ret == 0) {\n                    resp.index += 1;\n                } else {\n                    resp.error = ret;\n                    break;\n                }\n            }\n        } else {\n            resp.error = NEU_ERR_GROUP_NOT_ALLOW;\n        }\n\n        if (resp.index > 0) {\n            int ret = neu_adapter_driver_try_add_tag(\n                (neu_adapter_driver_t *) adapter, cmd->group, cmd->tags,\n                resp.index);\n            if (ret != 0) {\n                resp.index = 0;\n                resp.error = ret;\n            }\n        }\n\n        for (int i = 0; i < resp.index; i++) {\n            int ret = neu_adapter_driver_add_tag(\n                (neu_adapter_driver_t *) adapter, cmd->group, &cmd->tags[i],\n                NEU_DEFAULT_GROUP_INTERVAL);\n            if (ret != 0) {\n                neu_adapter_driver_try_del_tag((neu_adapter_driver_t *) adapter,\n                                               resp.index - i);\n                resp.index = i;\n                resp.error = ret;\n                break;\n            }\n        }\n\n        if (resp.index) {\n            // we have added some tags, try to persist\n            adapter_storage_add_tags(cmd->driver, cmd->group, cmd->tags,\n                                     resp.index);\n        }\n\n        for (uint16_t i = 0; i < cmd->n_tag; i++) {\n            neu_tag_fini(&cmd->tags[i]);\n        }\n        free(cmd->tags);\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ADD_TAG;\n        reply(adapter, header, &resp);\n        break;\n    }\n    case NEU_REQ_ADD_GTAG: {\n        neu_req_add_gtag_t *cmd  = (neu_req_add_gtag_t *) &header[1];\n        neu_resp_add_tag_t  resp = { 0 };\n\n        if (adapter->module->type != NEU_NA_TYPE_DRIVER) {\n            resp.error = NEU_ERR_GROUP_NOT_ALLOW;\n        } else {\n            if (neu_adapter_validate_gtags(adapter, cmd, &resp) == 0 &&\n                neu_adapter_try_add_gtags(adapter, cmd, &resp) == 0 &&\n                neu_adapter_add_gtags(adapter, cmd, &resp) == 0) {\n                for (int i = 0; i < cmd->n_group; i++) {\n                    adapter_storage_add_tags(cmd->driver, cmd->groups[i].group,\n                                             cmd->groups[i].tags,\n                                             cmd->groups[i].n_tag);\n                }\n            }\n        }\n\n        for (int i = 0; i < cmd->n_group; i++) {\n            for (int j = 0; j < cmd->groups[i].n_tag; j++) {\n                neu_tag_fini(&cmd->groups[i].tags[j]);\n            }\n            free(cmd->groups[i].tags);\n        }\n        free(cmd->groups);\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ADD_GTAG;\n        reply(adapter, header, &resp);\n        break;\n    }\n    case NEU_REQ_UPDATE_TAG: {\n        neu_req_update_tag_t *cmd  = (neu_req_update_tag_t *) &header[1];\n        neu_resp_update_tag_t resp = { 0 };\n\n        if (adapter->module->type == NEU_NA_TYPE_DRIVER) {\n\n            for (int i = 0; i < cmd->n_tag; i++) {\n                int ret = neu_adapter_driver_validate_tag(\n                    (neu_adapter_driver_t *) adapter, cmd->group,\n                    &cmd->tags[i]);\n                if (ret == 0) {\n                    ret = neu_adapter_driver_update_tag(\n                        (neu_adapter_driver_t *) adapter, cmd->group,\n                        &cmd->tags[i]);\n                    if (ret == 0) {\n                        adapter_storage_update_tag(cmd->driver, cmd->group,\n                                                   &cmd->tags[i]);\n\n                        resp.index += 1;\n                    } else {\n                        resp.error = ret;\n                        break;\n                    }\n                } else {\n                    resp.error = ret;\n                    break;\n                }\n            }\n        } else {\n            resp.error = NEU_ERR_GROUP_NOT_ALLOW;\n        }\n\n        for (uint16_t i = 0; i < cmd->n_tag; i++) {\n            neu_tag_fini(&cmd->tags[i]);\n        }\n        free(cmd->tags);\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_UPDATE_TAG;\n        reply(adapter, header, &resp);\n        break;\n    }\n    case NEU_REQ_NODE_UNINIT: {\n        neu_req_node_uninit_t *cmd = (neu_req_node_uninit_t *) &header[1];\n        char                   name[NEU_NODE_NAME_LEN]     = { 0 };\n        char                   receiver[NEU_NODE_NAME_LEN] = { 0 };\n\n        neu_adapter_uninit(adapter);\n\n        header->type = NEU_RESP_NODE_UNINIT;\n        neu_msg_exchange(header);\n        strcpy(header->sender, adapter->name);\n        strcpy(cmd->node, adapter->name);\n\n        neu_msg_gen(header, cmd);\n\n        strcpy(name, adapter->name);\n        strcpy(receiver, header->receiver);\n\n        int ret = neu_send_msg(adapter->control_fd, msg);\n        if (0 != ret) {\n            nlog_error(\"%s %d send uninit msg to %s error: %s(%d)\", name,\n                       adapter->control_fd, receiver, strerror(errno), errno);\n            neu_msg_free(msg);\n        } else {\n            nlog_notice(\"%s send uninit msg to %s succeeded\", name, receiver);\n        }\n        break;\n    }\n    case NEU_REQ_UPDATE_LOG_LEVEL: {\n        neu_req_update_log_level_t *cmd =\n            (neu_req_update_log_level_t *) &header[1];\n        neu_resp_error_t error = { 0 };\n        adapter->log_level     = cmd->log_level;\n        zlog_level_switch(neu_plugin_to_plugin_common(adapter->plugin)->log,\n                          cmd->log_level);\n\n        struct timeval tv = { 0 };\n        gettimeofday(&tv, NULL);\n        adapter->timestamp_lev = tv.tv_sec;\n\n        neu_msg_exchange(header);\n        header->type = NEU_RESP_ERROR;\n        reply(adapter, header, &error);\n\n        break;\n    }\n    case NEU_REQ_PRGFILE_UPLOAD: {\n        adapter->module->intf_funs->request(\n            adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        break;\n    }\n    case NEU_REQ_SCAN_TAGS: {\n        neu_adapter_driver_scan_tags((neu_adapter_driver_t *) adapter, header);\n        break;\n    }\n    case NEU_RESP_SCAN_TAGS: {\n        adapter->module->intf_funs->request(\n            adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        neu_msg_free(msg);\n        break;\n    }\n    case NEU_REQ_TEST_READ_TAG: {\n        neu_adapter_driver_test_read_tag((neu_adapter_driver_t *) adapter,\n                                         header);\n        break;\n    }\n    case NEU_RESP_TEST_READ_TAG: {\n        adapter->module->intf_funs->request(\n            adapter->plugin, (neu_reqresp_head_t *) header, &header[1]);\n        neu_msg_free(msg);\n        break;\n    }\n    default:\n        nlog_warn(\"adapter: %s recv msg type error, type: %s\", adapter->name,\n                  neu_reqresp_type_string(header->type));\n        assert(false);\n        break;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 88, "func": "static int manager_loop(enum neu_event_io_type type, int fd, void *usr_data)\n{\n    int                 rv       = 0;\n    neu_manager_t *     manager  = (neu_manager_t *) usr_data;\n    struct sockaddr_un  src_addr = { 0 };\n    neu_msg_t *         msg      = NULL;\n    neu_reqresp_head_t *header   = NULL;\n\n    if (type == NEU_EVENT_IO_CLOSED || type == NEU_EVENT_IO_HUP) {\n        nlog_warn(\"manager socket(%d) recv closed or hup %d.\", fd, type);\n        return 0;\n    }\n\n    rv = neu_recv_msg_from(manager->server_fd, &src_addr, &msg);\n    if (rv == -1) {\n        nlog_warn(\"manager recv msg error: %s(%d)\", strerror(errno), errno);\n        return 0;\n    }\n\n    header = neu_msg_get_header(msg);\n\n    nlog_info(\"manager recv msg from: %s to %s, type: %s\", header->sender,\n              header->receiver, neu_reqresp_type_string(header->type));\n    switch (header->type) {\n    case NEU_REQ_NODE_INIT: {\n        neu_req_node_init_t *init = (neu_req_node_init_t *) &header[1];\n\n        if (0 !=\n            neu_node_manager_update(manager->node_manager, init->node,\n                                    src_addr)) {\n            nlog_warn(\"bind node %s to src addr(%s) fail\", init->node,\n                      &src_addr.sun_path[1]);\n            neu_msg_free(msg);\n            break;\n        }\n\n        if (init->state == NEU_NODE_RUNNING_STATE_READY ||\n            init->state == NEU_NODE_RUNNING_STATE_RUNNING ||\n            init->state == NEU_NODE_RUNNING_STATE_STOPPED) {\n            neu_adapter_t *adapter =\n                neu_node_manager_find(manager->node_manager, init->node);\n            neu_adapter_start(adapter);\n            if (init->state == NEU_NODE_RUNNING_STATE_STOPPED) {\n                neu_adapter_stop(adapter);\n            }\n        }\n\n        nlog_notice(\"bind node %s to src addr(%s)\", init->node,\n                    &src_addr.sun_path[1]);\n        neu_msg_free(msg);\n        break;\n    }\n    case NEU_REQ_ADD_PLUGIN: {\n        neu_req_add_plugin_t *cmd        = (neu_req_add_plugin_t *) &header[1];\n        neu_resp_error_t      e          = { 0 };\n        neu_plugin_kind_e     kind       = -1;\n        char                  schema[64] = { 0 };\n        char                  buffer[65] = { 0 };\n\n        if (sscanf(cmd->library, \"libplugin-%64s.so\", buffer) != 1) {\n            nlog_warn(\"library %s no conform\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_NAME_NOT_CONFORM;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (neu_persister_library_exists(cmd->library)) {\n            nlog_warn(\"library %s had exited\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_NAME_CONFLICT;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        char *so_tmp_path = file_save_tmp(cmd->so_file, \"so\");\n\n        if (so_tmp_path == NULL) {\n            nlog_warn(\"library %s so file save tmp fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_BODY_IS_WRONG;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        neu_plugin_instance_t ins   = { 0 };\n        int                   error = NEU_ERR_SUCCESS;\n\n        if (neu_plugin_manager_create_instance_by_path(\n                manager->plugin_manager, so_tmp_path, &ins, &error)) {\n            char module_name[64] = { 0 };\n            kind                 = ins.module->kind;\n            strncpy(module_name, ins.module->module_name, sizeof(module_name));\n            strncpy(schema, ins.module->schema, sizeof(schema));\n\n            nlog_debug(\"library %s, module_name %s, schema:%s\", cmd->library,\n                       module_name, schema);\n\n            uint32_t major = NEU_GET_VERSION_MAJOR(ins.module->version);\n            uint32_t minor = NEU_GET_VERSION_MINOR(ins.module->version);\n\n            neu_plugin_manager_destroy_instance(manager->plugin_manager, &ins);\n\n            if (NEU_VERSION_MAJOR != major || NEU_VERSION_MINOR != minor) {\n                nlog_warn(\"library %s plugin version error, major:%d minor:%d\",\n                          module_name, major, minor);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_MODULE_VERSION_NOT_MATCH;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n\n            if (neu_plugin_manager_exists(manager->plugin_manager,\n                                          module_name)) {\n\n                nlog_warn(\"%s module name had existed\", module_name);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_MODULE_ALREADY_EXIST;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n\n        } else {\n            nlog_warn(\"library %s so file is not a vaild file\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = error;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (kind != NEU_PLUGIN_KIND_CUSTOM && kind != NEU_PLUGIN_KIND_SYSTEM) {\n            nlog_warn(\"library %s kind no support\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_MODULE_KIND_NOT_SUPPORT;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        char *schema_tmp_path = file_save_tmp(cmd->schema_file, \"json\");\n\n        if (schema_tmp_path == NULL) {\n            nlog_warn(\"library %s schema file save tmp fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_BODY_IS_WRONG;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (!mv_tmp_library_file(kind, so_tmp_path, cmd->library)) {\n            nlog_warn(\"library %s mv library tmp file fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            free(schema_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_ADD_FAIL;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (!mv_tmp_schema_file(kind, schema_tmp_path, schema)) {\n            nlog_warn(\"library %s schema file save schema fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            free(schema_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_ADD_FAIL;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        error = neu_manager_add_plugin(manager, cmd->library);\n\n        if (error == NEU_ERR_SUCCESS) {\n            manager_strorage_plugin(manager);\n        }\n\n        free(so_tmp_path);\n        free(cmd->so_file);\n        free(cmd->schema_file);\n        free(schema_tmp_path);\n        header->type = NEU_RESP_ERROR;\n        e.error      = error;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &e);\n        break;\n    }\n    case NEU_REQ_DEL_PLUGIN: {\n        neu_req_del_plugin_t *cmd = (neu_req_del_plugin_t *) &header[1];\n        neu_resp_error_t      e   = { 0 };\n\n        UT_array *nodes = neu_manager_get_nodes(\n            manager, NEU_NA_TYPE_DRIVER | NEU_NA_TYPE_APP, cmd->plugin, \"\");\n\n        if (nodes != NULL) {\n            if (utarray_len(nodes) > 0) {\n                utarray_free(nodes);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_IN_USE;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n            utarray_free(nodes);\n        }\n\n        int error = neu_manager_del_plugin(manager, cmd->plugin);\n        e.error   = error;\n\n        if (error == NEU_ERR_SUCCESS) {\n            manager_strorage_plugin(manager);\n        }\n\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &e);\n        break;\n    }\n    case NEU_REQ_UPDATE_PLUGIN: {\n        neu_req_update_plugin_t *cmd  = (neu_req_update_plugin_t *) &header[1];\n        neu_resp_error_t         e    = { 0 };\n        neu_plugin_kind_e        kind = -1;\n        char                     module_name[64] = { 0 };\n        char                     schema[64]      = { 0 };\n        char                     buffer[65]      = { 0 };\n\n        if (sscanf(cmd->library, \"libplugin-%64s.so\", buffer) != 1) {\n            nlog_warn(\"library %s no conform\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_NAME_NOT_CONFORM;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (!neu_persister_library_exists(cmd->library)) {\n            nlog_warn(\"library %s no exited\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_NOT_FOUND;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        char *so_tmp_path = file_save_tmp(cmd->so_file, \"so\");\n\n        if (so_tmp_path == NULL) {\n            nlog_warn(\"library %s so file save tmp fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_BODY_IS_WRONG;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        neu_plugin_instance_t ins   = { 0 };\n        int                   error = NEU_ERR_SUCCESS;\n\n        if (neu_plugin_manager_create_instance_by_path(\n                manager->plugin_manager, so_tmp_path, &ins, &error)) {\n            kind = ins.module->kind;\n            strncpy(module_name, ins.module->module_name, sizeof(module_name));\n            strncpy(schema, ins.module->schema, sizeof(schema));\n\n            nlog_debug(\"library %s, module_name %s, schema:%s\", cmd->library,\n                       module_name, schema);\n\n            uint32_t major = NEU_GET_VERSION_MAJOR(ins.module->version);\n            uint32_t minor = NEU_GET_VERSION_MINOR(ins.module->version);\n\n            neu_plugin_manager_destroy_instance(manager->plugin_manager, &ins);\n\n            if (NEU_VERSION_MAJOR != major || NEU_VERSION_MINOR != minor) {\n                nlog_warn(\"library %s plugin version error, major:%d minor:%d\",\n                          module_name, major, minor);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_MODULE_VERSION_NOT_MATCH;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n\n            if (!neu_plugin_manager_create_instance_by_lib_name(\n                    manager->plugin_manager, cmd->library, &ins)) {\n                nlog_warn(\"library %s not instance\", cmd->library);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_UPDATE_FAIL;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n\n            if (strcmp(module_name, ins.module->module_name) != 0) {\n                nlog_warn(\"library %s module name mismatch!\", cmd->library);\n                neu_plugin_manager_destroy_instance(manager->plugin_manager,\n                                                    &ins);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_UPDATE_FAIL;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n\n            neu_plugin_manager_destroy_instance(manager->plugin_manager, &ins);\n\n            if (!neu_plugin_manager_exists(manager->plugin_manager,\n                                           module_name)) {\n\n                nlog_warn(\"library %s plugin name no existed\", module_name);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_MODULE_NOT_EXISTS;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n\n        } else {\n            nlog_warn(\"library %s so file is not a vaild file\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = error;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (kind != NEU_PLUGIN_KIND_CUSTOM && kind != NEU_PLUGIN_KIND_SYSTEM) {\n            nlog_warn(\"library %s kind no support\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_MODULE_KIND_NOT_SUPPORT;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        char *schema_tmp_path = file_save_tmp(cmd->schema_file, \"json\");\n\n        if (schema_tmp_path == NULL) {\n            nlog_warn(\"library %s schema file save tmp fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_BODY_IS_WRONG;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        UT_array *nodes = neu_manager_get_nodes(\n            manager, NEU_NA_TYPE_DRIVER | NEU_NA_TYPE_APP, module_name, \"\");\n\n        if (nodes != NULL) {\n            if (utarray_len(nodes) > 0) {\n                utarray_free(nodes);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                free(schema_tmp_path);\n                nlog_warn(\"library %s is using\", cmd->library);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_IN_USE;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n            utarray_free(nodes);\n        }\n\n        if (!neu_plugin_manager_remove_library(manager->plugin_manager,\n                                               cmd->library)) {\n            nlog_warn(\"library %s src file remove fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            free(schema_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_UPDATE_FAIL;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (!mv_tmp_library_file(kind, so_tmp_path, cmd->library)) {\n            nlog_warn(\"library %s mv library tmp file fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            free(schema_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_UPDATE_FAIL;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (!mv_tmp_schema_file(kind, schema_tmp_path, schema)) {\n            nlog_warn(\"library %s schema file save schema fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            free(schema_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_UPDATE_FAIL;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (neu_plugin_manager_update(manager->plugin_manager, cmd->library) !=\n            NEU_ERR_SUCCESS) {\n            nlog_warn(\"update library %s fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            free(schema_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_UPDATE_FAIL;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        free(cmd->so_file);\n        free(cmd->schema_file);\n        free(so_tmp_path);\n        free(schema_tmp_path);\n        header->type = NEU_RESP_ERROR;\n        e.error      = NEU_ERR_SUCCESS;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &e);\n\n        break;\n    }\n    case NEU_REQ_GET_PLUGIN: {\n        UT_array *            plugins = neu_manager_get_plugins(manager);\n        neu_resp_get_plugin_t resp    = { .plugins = plugins };\n\n        header->type = NEU_RESP_GET_PLUGIN;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &resp);\n        break;\n    }\n    case NEU_REQ_ADD_NODE: {\n        neu_req_add_node_t *cmd = (neu_req_add_node_t *) &header[1];\n        nlog_notice(\"add node name:%s plugin:%s\", cmd->node, cmd->plugin);\n        int error =\n            neu_manager_add_node(manager, cmd->node, cmd->plugin, cmd->setting,\n                                 NEU_NODE_RUNNING_STATE_INIT, false);\n\n        neu_resp_error_t e = { .error = error };\n\n        if (error == NEU_ERR_SUCCESS) {\n            manager_storage_add_node(manager, cmd->node);\n            if (cmd->setting) {\n                adapter_storage_setting(cmd->node, cmd->setting);\n            }\n        }\n\n        neu_req_add_node_fini(cmd);\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &e);\n        break;\n    }\n    case NEU_REQ_UPDATE_NODE: {\n        neu_req_update_node_t *cmd = (neu_req_update_node_t *) &header[1];\n        neu_resp_error_t       e   = { 0 };\n        nlog_notice(\"update node name:%s new_name:%s\", cmd->node,\n                    cmd->new_name);\n        if (NULL == neu_node_manager_find(manager->node_manager, cmd->node)) {\n            e.error = NEU_ERR_NODE_NOT_EXIST;\n        } else if (NULL !=\n                   neu_node_manager_find(manager->node_manager,\n                                         cmd->new_name)) {\n            // this also makes renaming to the original name an error\n            e.error = NEU_ERR_NODE_EXIST;\n        }\n\n        if (0 == e.error) {\n            header->type = NEU_REQ_NODE_RENAME;\n            forward_msg(manager, header, header->receiver);\n        } else {\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        }\n\n        break;\n    }\n    case NEU_REQ_DEL_NODE: {\n        neu_req_del_node_t *cmd   = (neu_req_del_node_t *) &header[1];\n        neu_resp_error_t    error = { 0 };\n        nlog_notice(\"del node name:%s\", cmd->node);\n        neu_adapter_t *adapter =\n            neu_node_manager_find(manager->node_manager, cmd->node);\n        bool single =\n            neu_node_manager_is_single(manager->node_manager, cmd->node);\n\n        strcpy(header->receiver, cmd->node);\n        if (adapter == NULL) {\n            error.error  = NEU_ERR_NODE_NOT_EXIST;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &error);\n            break;\n        }\n\n        if (single) {\n            error.error  = NEU_ERR_NODE_NOT_ALLOW_DELETE;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &error);\n            break;\n        }\n\n        manager_storage_del_node(manager, cmd->node);\n        if (neu_adapter_get_type(adapter) == NEU_NA_TYPE_APP) {\n            UT_array *subscriptions = neu_subscribe_manager_get(\n                manager->subscribe_manager, cmd->node, NULL, NULL);\n            neu_subscribe_manager_unsub_all(manager->subscribe_manager,\n                                            cmd->node);\n\n            utarray_foreach(subscriptions, neu_resp_subscribe_info_t *, sub)\n            {\n                // NOTE: neu_req_unsubscribe_t and neu_resp_subscribe_info_t\n                //       have compatible memory layout\n                msg = neu_msg_new(NEU_REQ_UNSUBSCRIBE_GROUP, NULL, sub);\n                if (NULL == msg) {\n                    break;\n                }\n                neu_reqresp_head_t *hd = neu_msg_get_header(msg);\n                strcpy(hd->receiver, sub->driver);\n                strcpy(hd->sender, \"manager\");\n                forward_msg(manager, hd, hd->receiver);\n            }\n            utarray_free(subscriptions);\n        }\n\n        neu_reqresp_node_deleted_t resp = { 0 };\n        strcpy(resp.node, header->receiver);\n        // notify MQTT about node removal\n        if (0 == strcmp(adapter->module->module_name, \"MQTT\")) {\n            msg = neu_msg_new(NEU_REQRESP_NODE_DELETED, NULL, &resp);\n            if (NULL != msg) {\n                neu_reqresp_head_t *hd = neu_msg_get_header(msg);\n                strcpy(hd->receiver, cmd->node);\n                strcpy(hd->sender, \"manager\");\n                reply(manager, hd, &resp);\n            }\n        }\n        header->type = NEU_REQ_NODE_UNINIT;\n        forward_msg(manager, header, header->receiver);\n\n        if (neu_adapter_get_type(adapter) == NEU_NA_TYPE_DRIVER) {\n            UT_array *apps = neu_subscribe_manager_find_by_driver(\n                manager->subscribe_manager, resp.node);\n\n            utarray_foreach(apps, neu_app_subscribe_t *, app)\n            {\n                msg = neu_msg_new(NEU_REQRESP_NODE_DELETED, NULL, &resp);\n                if (NULL == msg) {\n                    break;\n                }\n                header = neu_msg_get_header(msg);\n                strcpy(header->receiver, app->app_name);\n                strcpy(header->sender, \"manager\");\n                reply(manager, header, &resp);\n            }\n            utarray_free(apps);\n        }\n\n        break;\n    }\n    case NEU_RESP_NODE_UNINIT: {\n        neu_resp_node_uninit_t *cmd = (neu_resp_node_uninit_t *) &header[1];\n\n        neu_manager_del_node(manager, cmd->node);\n        if (strlen(header->receiver) > 0 &&\n            strcmp(header->receiver, \"manager\") != 0) {\n            neu_resp_error_t error = { 0 };\n            header->type           = NEU_RESP_ERROR;\n            reply(manager, header, &error);\n        } else {\n            neu_msg_free(msg);\n        }\n        break;\n    }\n    case NEU_REQ_GET_NODE: {\n        neu_req_get_node_t *cmd = (neu_req_get_node_t *) &header[1];\n        UT_array *          nodes =\n            neu_manager_get_nodes(manager, cmd->type, cmd->plugin, cmd->node);\n        neu_resp_get_node_t resp = { .nodes = nodes };\n\n        header->type = NEU_RESP_GET_NODE;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &resp);\n        break;\n    }\n    case NEU_REQ_SUBSCRIBE_GROUP: {\n        neu_req_subscribe_t *cmd      = (neu_req_subscribe_t *) &header[1];\n        neu_resp_error_t     error    = { 0 };\n        uint16_t             app_port = 0;\n\n        nlog_notice(\"add sub app_name:%s driver_node:%s group:%s params:%s\",\n                    cmd->app, cmd->driver, cmd->group,\n                    cmd->params != NULL ? cmd->params : \"\");\n\n        error.error = neu_manager_subscribe(manager, cmd->app, cmd->driver,\n                                            cmd->group, cmd->params, &app_port);\n\n        if (error.error == NEU_ERR_SUCCESS) {\n            cmd->port = app_port;\n            forward_msg_copy(manager, header, cmd->app);\n            forward_msg_copy(manager, header, cmd->driver);\n            manager_storage_subscribe(manager, cmd->app, cmd->driver,\n                                      cmd->group, cmd->params);\n        } else {\n            free(cmd->params);\n        }\n\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &error);\n        break;\n    }\n    case NEU_REQ_SUBSCRIBE_GROUPS: {\n        neu_req_subscribe_groups_t *cmd =\n            (neu_req_subscribe_groups_t *) &header[1];\n        neu_resp_error_t error = { 0 };\n\n        for (uint16_t i = 0; i < cmd->n_group; ++i) {\n            neu_req_subscribe_group_info_t *info = &cmd->groups[i];\n            nlog_notice(\"add sub app_name:%s driver_node:%s group:%s params:%s\",\n                        cmd->app, info->driver, info->group,\n                        info->params != NULL ? info->params : \"\");\n            error.error =\n                neu_manager_subscribe(manager, cmd->app, info->driver,\n                                      info->group, info->params, &info->port);\n            if (0 != error.error) {\n                break;\n            }\n\n            error.error = neu_manager_send_subscribe(manager, cmd->app,\n                                                     info->driver, info->group,\n                                                     info->port, info->params);\n            if (0 != error.error) {\n                break;\n            }\n\n            manager_storage_subscribe(manager, cmd->app, info->driver,\n                                      info->group, info->params);\n        }\n\n        neu_req_subscribe_groups_fini(cmd);\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &error);\n        break;\n    }\n    case NEU_REQ_UPDATE_SUBSCRIBE_GROUP: {\n        neu_req_subscribe_t *cmd   = (neu_req_subscribe_t *) &header[1];\n        neu_resp_error_t     error = { 0 };\n        nlog_notice(\"update sub app_name:%s driver_node:%s group:%s params:%s\",\n                    cmd->app, cmd->driver, cmd->group,\n                    cmd->params != NULL ? cmd->params : \"\");\n        error.error = neu_manager_update_subscribe(\n            manager, cmd->app, cmd->driver, cmd->group, cmd->params);\n\n        if (error.error == NEU_ERR_SUCCESS) {\n            forward_msg_copy(manager, header, cmd->app);\n            manager_storage_update_subscribe(manager, cmd->app, cmd->driver,\n                                             cmd->group, cmd->params);\n        } else {\n            free(cmd->params);\n        }\n\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &error);\n        break;\n    }\n    case NEU_REQ_UNSUBSCRIBE_GROUP: {\n        neu_req_unsubscribe_t *cmd   = (neu_req_unsubscribe_t *) &header[1];\n        neu_resp_error_t       error = { 0 };\n        nlog_notice(\"del sub app_name:%s driver_node:%s group:%s\", cmd->app,\n                    cmd->driver, cmd->group);\n        error.error =\n            neu_manager_unsubscribe(manager, cmd->app, cmd->driver, cmd->group);\n\n        if (error.error == NEU_ERR_SUCCESS) {\n            forward_msg_copy(manager, header, cmd->app);\n            forward_msg_copy(manager, header, cmd->driver);\n            manager_storage_unsubscribe(manager, cmd->app, cmd->driver,\n                                        cmd->group);\n        }\n\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &error);\n        break;\n    }\n    case NEU_REQ_GET_SUBSCRIBE_GROUP: {\n        neu_req_get_subscribe_group_t *cmd =\n            (neu_req_get_subscribe_group_t *) &header[1];\n        UT_array *groups = neu_manager_get_sub_group_deep_copy(\n            manager, cmd->app, cmd->driver, cmd->group);\n        neu_resp_get_subscribe_group_t resp = { .groups = groups };\n\n        strcpy(header->receiver, header->sender);\n        header->type = NEU_RESP_GET_SUBSCRIBE_GROUP;\n        reply(manager, header, &resp);\n        break;\n    }\n    case NEU_REQ_GET_SUB_DRIVER_TAGS: {\n        neu_req_get_sub_driver_tags_t *cmd =\n            (neu_req_get_sub_driver_tags_t *) &header[1];\n        neu_resp_get_sub_driver_tags_t resp = { 0 };\n        UT_array *groups = neu_manager_get_sub_group(manager, cmd->app);\n\n        utarray_new(resp.infos, neu_resp_get_sub_driver_tags_info_icd());\n        utarray_foreach(groups, neu_resp_subscribe_info_t *, info)\n        {\n            neu_resp_get_sub_driver_tags_info_t in = { 0 };\n            neu_adapter_t *                     driver =\n                neu_node_manager_find(manager->node_manager, info->driver);\n            assert(driver != NULL);\n\n            strcpy(in.driver, info->driver);\n            strcpy(in.group, info->group);\n            neu_adapter_driver_get_value_tag((neu_adapter_driver_t *) driver,\n                                             info->group, &in.tags);\n\n            utarray_push_back(resp.infos, &in);\n        }\n        utarray_free(groups);\n\n        strcpy(header->receiver, header->sender);\n        header->type = NEU_RESP_GET_SUB_DRIVER_TAGS;\n        reply(manager, header, &resp);\n\n        break;\n    }\n    case NEU_REQ_GET_NODES_STATE: {\n        neu_resp_get_nodes_state_t resp = { 0 };\n        UT_array *states = neu_node_manager_get_state(manager->node_manager);\n        neu_nodes_state_t *p_state = NULL;\n        while (\n            (p_state = (neu_nodes_state_t *) utarray_next(states, p_state))) {\n            p_state->sub_group_count = neu_subscribe_manager_group_count(\n                manager->subscribe_manager, p_state->node);\n        }\n        resp.states     = utarray_clone(states);\n        resp.core_level = manager->log_level;\n\n        strcpy(header->receiver, header->sender);\n        strcpy(header->sender, \"manager\");\n        header->type = NEU_RESP_GET_NODES_STATE;\n        reply(manager, header, &resp);\n\n        utarray_free(states);\n        break;\n    }\n    case NEU_REQ_GET_DRIVER_GROUP: {\n        neu_resp_get_driver_group_t resp = { 0 };\n\n        resp.groups = neu_manager_get_driver_group(manager);\n\n        strcpy(header->receiver, header->sender);\n        strcpy(header->sender, \"manager\");\n        header->type = NEU_RESP_GET_DRIVER_GROUP;\n        reply(manager, header, &resp);\n\n        break;\n    }\n\n    case NEU_REQ_GET_GROUP:\n    case NEU_REQ_GET_NODE_SETTING:\n    case NEU_REQ_READ_GROUP:\n    case NEU_REQ_READ_GROUP_PAGINATE:\n    case NEU_REQ_WRITE_TAG:\n    case NEU_REQ_WRITE_TAGS:\n    case NEU_REQ_WRITE_GTAGS:\n    case NEU_REQ_GET_TAG:\n    case NEU_REQ_NODE_CTL:\n    case NEU_REQ_ADD_GROUP: {\n        neu_otel_trace_ctx trace = NULL;\n        neu_otel_scope_ctx scope = NULL;\n        if (neu_otel_control_is_started() &&\n            (NEU_REQ_WRITE_TAG == header->type ||\n             NEU_REQ_WRITE_TAGS == header->type ||\n             NEU_REQ_WRITE_GTAGS == header->type)) {\n            trace = neu_otel_find_trace(header->ctx);\n            if (trace) {\n                scope = neu_otel_add_span(trace);\n                if (NEU_REQ_WRITE_TAG == header->type) {\n                    neu_otel_scope_set_span_name(scope, \"manager write tag\");\n                } else if (NEU_REQ_WRITE_TAGS == header->type) {\n                    neu_otel_scope_set_span_name(scope, \"manager write tags\");\n                } else if (NEU_REQ_WRITE_GTAGS == header->type) {\n                    neu_otel_scope_set_span_name(scope, \"manager write gtags\");\n                }\n                char new_span_id[36] = { 0 };\n                neu_otel_new_span_id(new_span_id);\n                neu_otel_scope_set_span_id(scope, new_span_id);\n                uint8_t *p_sp_id = neu_otel_scope_get_pre_span_id(scope);\n                if (p_sp_id) {\n                    neu_otel_scope_set_parent_span_id2(scope, p_sp_id, 8);\n                }\n                neu_otel_scope_add_span_attr_int(scope, \"thread id\",\n                                                 (int64_t) pthread_self());\n                neu_otel_scope_set_span_start_time(scope, neu_time_ns());\n            }\n        }\n\n        bool re_flag = false;\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            if (NEU_REQ_READ_GROUP == header->type) {\n                neu_req_read_group_fini((neu_req_read_group_t *) &header[1]);\n            } else if (NEU_REQ_READ_GROUP_PAGINATE == header->type) {\n                neu_req_read_group_paginate_fini(\n                    (neu_req_read_group_paginate_t *) &header[1]);\n            } else if (NEU_REQ_WRITE_TAG == header->type) {\n                neu_req_write_tag_fini((neu_req_write_tag_t *) &header[1]);\n            } else if (NEU_REQ_WRITE_TAGS == header->type) {\n                neu_req_write_tags_fini((neu_req_write_tags_t *) &header[1]);\n            } else if (NEU_REQ_WRITE_GTAGS == header->type) {\n                neu_req_write_gtags_fini((neu_req_write_gtags_t *) &header[1]);\n            }\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n            if (neu_otel_control_is_started() && trace) {\n                neu_otel_scope_set_status_code2(scope, NEU_OTEL_STATUS_ERROR,\n                                                NEU_ERR_NODE_NOT_EXIST);\n            }\n        } else {\n            forward_msg(manager, header, header->receiver);\n            re_flag = true;\n        }\n\n        if (neu_otel_control_is_started() && trace) {\n            neu_otel_scope_set_span_end_time(scope, neu_time_ns());\n            if (!re_flag) {\n                neu_otel_trace_set_final(trace);\n            }\n        }\n\n        break;\n    }\n    case NEU_REQ_PRGFILE_PROCESS:\n    case NEU_REQ_PRGFILE_UPLOAD:\n    case NEU_REQ_SCAN_TAGS:\n    case NEU_REQ_TEST_READ_TAG:\n    case NEU_REQ_GET_NODE_STATE: {\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        } else {\n            forward_msg(manager, header, header->receiver);\n        }\n\n        break;\n    }\n\n    case NEU_RESP_NODE_RENAME: {\n        neu_resp_node_rename_t *resp = (neu_resp_node_rename_t *) &header[1];\n        if (0 == resp->error) {\n            neu_manager_update_node_name(manager, resp->node, resp->new_name);\n            manager_storage_update_node(manager, resp->node, resp->new_name);\n\n            if (neu_node_manager_is_driver(manager->node_manager,\n                                           resp->new_name)) {\n                UT_array *apps = neu_subscribe_manager_find_by_driver(\n                    manager->subscribe_manager, resp->new_name);\n\n                // notify app node about driver renaming\n                utarray_foreach(apps, neu_app_subscribe_t *, app)\n                {\n                    header->type = NEU_REQ_UPDATE_NODE;\n                    forward_msg_copy(manager, header, app->app_name);\n                }\n\n                utarray_free(apps);\n            }\n        }\n\n        neu_resp_error_t e = { .error = resp->error };\n        header->type       = NEU_RESP_ERROR;\n        reply(manager, header, &e);\n        break;\n    }\n\n    case NEU_RESP_UPDATE_DRIVER_GROUP: {\n        neu_resp_update_group_t *resp = (neu_resp_update_group_t *) &header[1];\n        if (0 == resp->error) {\n            neu_manager_update_group_name(manager, resp->driver, resp->group,\n                                          resp->new_name);\n\n            UT_array *apps = neu_subscribe_manager_find(\n                manager->subscribe_manager, resp->driver, resp->new_name);\n\n            if (NULL != apps) {\n                // notify app node about group renaming\n                utarray_foreach(apps, neu_app_subscribe_t *, app)\n                {\n                    header->type = NEU_REQ_UPDATE_GROUP;\n                    forward_msg_copy(manager, header, app->app_name);\n                }\n\n                utarray_free(apps);\n            }\n        }\n\n        neu_resp_error_t e = { .error = resp->error };\n        header->type       = NEU_RESP_ERROR;\n        reply(manager, header, &e);\n        break;\n    }\n\n    case NEU_REQ_UPDATE_GROUP: {\n        neu_resp_error_t e = { 0 };\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            e.error = NEU_ERR_NODE_NOT_EXIST;\n        } else if (!neu_node_manager_is_driver(manager->node_manager,\n                                               header->receiver)) {\n            e.error = NEU_ERR_GROUP_NOT_ALLOW;\n        } else {\n            header->type = NEU_REQ_UPDATE_DRIVER_GROUP;\n            forward_msg(manager, header, header->receiver);\n        }\n\n        if (e.error) {\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        }\n\n        break;\n    }\n\n    case NEU_REQ_DEL_GROUP: {\n        neu_req_del_group_t *cmd = (neu_req_del_group_t *) &header[1];\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        } else {\n            UT_array *apps = neu_subscribe_manager_find(\n                manager->subscribe_manager, cmd->driver, cmd->group);\n\n            forward_msg(manager, header, header->receiver);\n            neu_subscribe_manager_remove(manager->subscribe_manager,\n                                         cmd->driver, cmd->group);\n\n            if (NULL == apps) {\n                break;\n            }\n\n            // notify app node about group deletion\n            utarray_foreach(apps, neu_app_subscribe_t *, app)\n            {\n                forward_msg_copy(manager, header, app->app_name);\n            }\n\n            utarray_free(apps);\n        }\n        break;\n    }\n    case NEU_REQ_DEL_TAG: {\n        neu_req_del_tag_t *cmd = (neu_req_del_tag_t *) &header[1];\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            for (int i = 0; i < cmd->n_tag; i++) {\n                free(cmd->tags[i]);\n            }\n            free(cmd->tags);\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        } else {\n            forward_msg(manager, header, header->receiver);\n        }\n\n        break;\n    }\n    case NEU_REQ_UPDATE_TAG:\n    case NEU_REQ_ADD_TAG: {\n        neu_req_add_tag_t *cmd = (neu_req_add_tag_t *) &header[1];\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            for (int i = 0; i < cmd->n_tag; i++) {\n                neu_tag_fini(&cmd->tags[i]);\n            }\n            free(cmd->tags);\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        } else {\n            forward_msg(manager, header, header->receiver);\n        }\n\n        break;\n    }\n    case NEU_REQ_ADD_GTAG: {\n        neu_req_add_gtag_t *cmd = (neu_req_add_gtag_t *) &header[1];\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            for (int i = 0; i < cmd->n_group; i++) {\n                for (int j = 0; j < cmd->groups[i].n_tag; j++) {\n                    neu_tag_fini(&cmd->groups[i].tags[j]);\n                }\n                free(cmd->groups[i].tags);\n            }\n            free(cmd->groups);\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        } else {\n            forward_msg(manager, header, header->receiver);\n        }\n\n        break;\n    }\n    case NEU_REQ_NODE_SETTING: {\n        neu_req_node_setting_t *cmd = (neu_req_node_setting_t *) &header[1];\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            free(cmd->setting);\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        } else {\n            forward_msg(manager, header, header->receiver);\n        }\n        break;\n    }\n\n    case NEU_RESP_ADD_TAG:\n    case NEU_RESP_ADD_GTAG:\n    case NEU_RESP_UPDATE_TAG:\n    case NEU_RESP_GET_TAG:\n    case NEU_RESP_GET_GROUP:\n    case NEU_RESP_GET_NODE_SETTING:\n    case NEU_RESP_ERROR:\n    case NEU_RESP_READ_GROUP:\n    case NEU_RESP_READ_GROUP_PAGINATE:\n    case NEU_RESP_TEST_READ_TAG:\n    case NEU_RESP_PRGFILE_PROCESS:\n    case NEU_RESP_SCAN_TAGS:\n        forward_msg(manager, header, header->receiver);\n        break;\n\n    case NEU_RESP_GET_NODE_STATE: {\n        neu_resp_get_node_state_t *resp =\n            (neu_resp_get_node_state_t *) &header[1];\n\n        neu_adapter_t *adapter_node =\n            neu_node_manager_find(manager->node_manager, header->sender);\n        resp->sub_group_count = neu_subscribe_manager_group_count(\n            manager->subscribe_manager, header->sender);\n        resp->is_driver =\n            (adapter_node->module->type == NEU_NA_TYPE_DRIVER) ? true : false;\n        resp->core_level = manager->log_level;\n\n        forward_msg(manager, header, header->receiver);\n        break;\n    }\n\n    case NEU_REQ_ADD_DRIVERS: {\n        neu_req_driver_array_t *cmd = (neu_req_driver_array_t *) &header[1];\n        neu_resp_error_t        e   = { 0 };\n\n        e.error = neu_manager_add_drivers(manager, cmd);\n        if (NEU_ERR_SUCCESS == e.error) {\n            for (uint16_t i = 0; i < cmd->n_driver; ++i) {\n                neu_req_driver_t *driver = &cmd->drivers[i];\n                manager_storage_add_node(manager, driver->node);\n                adapter_storage_setting(driver->node, driver->setting);\n                for (uint16_t j = 0; j < driver->n_group; j++) {\n                    adapter_storage_add_group(driver->node,\n                                              driver->groups[j].group,\n                                              driver->groups[j].interval, NULL);\n                    adapter_storage_add_tags(\n                        driver->node, driver->groups[j].group,\n                        driver->groups[j].tags, driver->groups[j].n_tag);\n                }\n            }\n        }\n\n        neu_req_driver_array_fini(cmd);\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &e);\n        break;\n    }\n\n    case NEU_REQ_UPDATE_LOG_LEVEL: {\n        neu_req_update_log_level_t *cmd =\n            (neu_req_update_log_level_t *) &header[1];\n\n        if (cmd->core) {\n            manager->log_level = cmd->log_level;\n            nlog_level_change(manager->log_level);\n        }\n\n        if (strlen(cmd->node) > 0) {\n            if (neu_node_manager_find(manager->node_manager,\n                                      header->receiver) == NULL) {\n                neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n                header->type       = NEU_RESP_ERROR;\n                neu_msg_exchange(header);\n                reply(manager, header, &e);\n            } else {\n                forward_msg(manager, header, header->receiver);\n            }\n        } else {\n            if (cmd->core) {\n                neu_resp_error_t e = { .error = NEU_ERR_SUCCESS };\n                header->type       = NEU_RESP_ERROR;\n                neu_msg_exchange(header);\n                reply(manager, header, &e);\n            } else {\n                neu_resp_error_t e = { .error = NEU_ERR_PARAM_IS_WRONG };\n                header->type       = NEU_RESP_ERROR;\n                neu_msg_exchange(header);\n                reply(manager, header, &e);\n            }\n        }\n\n        break;\n    }\n    default:\n        assert(false);\n        break;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 89, "func": "static int manager_loop(enum neu_event_io_type type, int fd, void *usr_data)\n{\n    int                 rv       = 0;\n    neu_manager_t *     manager  = (neu_manager_t *) usr_data;\n    struct sockaddr_un  src_addr = { 0 };\n    neu_msg_t *         msg      = NULL;\n    neu_reqresp_head_t *header   = NULL;\n\n    if (type == NEU_EVENT_IO_CLOSED || type == NEU_EVENT_IO_HUP) {\n        nlog_warn(\"manager socket(%d) recv closed or hup %d.\", fd, type);\n        return 0;\n    }\n\n    rv = neu_recv_msg_from(manager->server_fd, &src_addr, &msg);\n    if (rv == -1) {\n        nlog_warn(\"manager recv msg error: %s(%d)\", strerror(errno), errno);\n        return 0;\n    }\n\n    header = neu_msg_get_header(msg);\n\n    nlog_info(\"manager recv msg from: %s to %s, type: %s\", header->sender,\n              header->receiver, neu_reqresp_type_string(header->type));\n    switch (header->type) {\n    case NEU_REQ_NODE_INIT: {\n        neu_req_node_init_t *init = (neu_req_node_init_t *) &header[1];\n\n        if (0 !=\n            neu_node_manager_update(manager->node_manager, init->node,\n                                    src_addr)) {\n            nlog_warn(\"bind node %s to src addr(%s) fail\", init->node,\n                      &src_addr.sun_path[1]);\n            neu_msg_free(msg);\n            break;\n        }\n\n        if (init->state == NEU_NODE_RUNNING_STATE_READY ||\n            init->state == NEU_NODE_RUNNING_STATE_RUNNING ||\n            init->state == NEU_NODE_RUNNING_STATE_STOPPED) {\n            neu_adapter_t *adapter =\n                neu_node_manager_find(manager->node_manager, init->node);\n            neu_adapter_start(adapter);\n            if (init->state == NEU_NODE_RUNNING_STATE_STOPPED) {\n                neu_adapter_stop(adapter);\n            }\n        }\n\n        nlog_notice(\"bind node %s to src addr(%s)\", init->node,\n                    &src_addr.sun_path[1]);\n        neu_msg_free(msg);\n        break;\n    }\n    case NEU_REQ_ADD_PLUGIN: {\n        neu_req_add_plugin_t *cmd        = (neu_req_add_plugin_t *) &header[1];\n        neu_resp_error_t      e          = { 0 };\n        neu_plugin_kind_e     kind       = -1;\n        char                  schema[64] = { 0 };\n        char                  buffer[65] = { 0 };\n\n        if (sscanf(cmd->library, \"libplugin-%64s.so\", buffer) != 1) {\n            nlog_warn(\"library %s no conform\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_NAME_NOT_CONFORM;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (neu_persister_library_exists(cmd->library)) {\n            nlog_warn(\"library %s had exited\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_NAME_CONFLICT;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        char *so_tmp_path = file_save_tmp(cmd->so_file, \"so\");\n\n        if (so_tmp_path == NULL) {\n            nlog_warn(\"library %s so file save tmp fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_BODY_IS_WRONG;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        neu_plugin_instance_t ins   = { 0 };\n        int                   error = NEU_ERR_SUCCESS;\n\n        if (neu_plugin_manager_create_instance_by_path(\n                manager->plugin_manager, so_tmp_path, &ins, &error)) {\n            char module_name[64] = { 0 };\n            kind                 = ins.module->kind;\n            strncpy(module_name, ins.module->module_name, sizeof(module_name));\n            strncpy(schema, ins.module->schema, sizeof(schema));\n\n            nlog_debug(\"library %s, module_name %s, schema:%s\", cmd->library,\n                       module_name, schema);\n\n            uint32_t major = NEU_GET_VERSION_MAJOR(ins.module->version);\n            uint32_t minor = NEU_GET_VERSION_MINOR(ins.module->version);\n\n            neu_plugin_manager_destroy_instance(manager->plugin_manager, &ins);\n\n            if (NEU_VERSION_MAJOR != major || NEU_VERSION_MINOR != minor) {\n                nlog_warn(\"library %s plugin version error, major:%d minor:%d\",\n                          module_name, major, minor);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_MODULE_VERSION_NOT_MATCH;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n\n            if (neu_plugin_manager_exists(manager->plugin_manager,\n                                          module_name)) {\n\n                nlog_warn(\"%s module name had existed\", module_name);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_MODULE_ALREADY_EXIST;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n\n        } else {\n            nlog_warn(\"library %s so file is not a vaild file\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = error;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (kind != NEU_PLUGIN_KIND_CUSTOM && kind != NEU_PLUGIN_KIND_SYSTEM) {\n            nlog_warn(\"library %s kind no support\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_MODULE_KIND_NOT_SUPPORT;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        char *schema_tmp_path = file_save_tmp(cmd->schema_file, \"json\");\n\n        if (schema_tmp_path == NULL) {\n            nlog_warn(\"library %s schema file save tmp fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_BODY_IS_WRONG;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (!mv_tmp_library_file(kind, so_tmp_path, cmd->library)) {\n            nlog_warn(\"library %s mv library tmp file fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            free(schema_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_ADD_FAIL;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (!mv_tmp_schema_file(kind, schema_tmp_path, schema)) {\n            nlog_warn(\"library %s schema file save schema fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            free(schema_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_ADD_FAIL;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        error = neu_manager_add_plugin(manager, cmd->library);\n\n        if (error == NEU_ERR_SUCCESS) {\n            manager_strorage_plugin(manager);\n        }\n\n        free(so_tmp_path);\n        free(cmd->so_file);\n        free(cmd->schema_file);\n        free(schema_tmp_path);\n        header->type = NEU_RESP_ERROR;\n        e.error      = error;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &e);\n        break;\n    }\n    case NEU_REQ_DEL_PLUGIN: {\n        neu_req_del_plugin_t *cmd = (neu_req_del_plugin_t *) &header[1];\n        neu_resp_error_t      e   = { 0 };\n\n        UT_array *nodes = neu_manager_get_nodes(\n            manager, NEU_NA_TYPE_DRIVER | NEU_NA_TYPE_APP, cmd->plugin, \"\");\n\n        if (nodes != NULL) {\n            if (utarray_len(nodes) > 0) {\n                utarray_free(nodes);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_IN_USE;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n            utarray_free(nodes);\n        }\n\n        int error = neu_manager_del_plugin(manager, cmd->plugin);\n        e.error   = error;\n\n        if (error == NEU_ERR_SUCCESS) {\n            manager_strorage_plugin(manager);\n        }\n\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &e);\n        break;\n    }\n    case NEU_REQ_UPDATE_PLUGIN: {\n        neu_req_update_plugin_t *cmd  = (neu_req_update_plugin_t *) &header[1];\n        neu_resp_error_t         e    = { 0 };\n        neu_plugin_kind_e        kind = -1;\n        char                     module_name[64] = { 0 };\n        char                     schema[64]      = { 0 };\n        char                     buffer[65]      = { 0 };\n\n        if (sscanf(cmd->library, \"libplugin-%64s.so\", buffer) != 1) {\n            nlog_warn(\"library %s no conform\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_NAME_NOT_CONFORM;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (!neu_persister_library_exists(cmd->library)) {\n            nlog_warn(\"library %s no exited\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_NOT_FOUND;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        char *so_tmp_path = file_save_tmp(cmd->so_file, \"so\");\n\n        if (so_tmp_path == NULL) {\n            nlog_warn(\"library %s so file save tmp fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_BODY_IS_WRONG;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        neu_plugin_instance_t ins   = { 0 };\n        int                   error = NEU_ERR_SUCCESS;\n\n        if (neu_plugin_manager_create_instance_by_path(\n                manager->plugin_manager, so_tmp_path, &ins, &error)) {\n            kind = ins.module->kind;\n            strncpy(module_name, ins.module->module_name, sizeof(module_name));\n            strncpy(schema, ins.module->schema, sizeof(schema));\n\n            nlog_debug(\"library %s, module_name %s, schema:%s\", cmd->library,\n                       module_name, schema);\n\n            uint32_t major = NEU_GET_VERSION_MAJOR(ins.module->version);\n            uint32_t minor = NEU_GET_VERSION_MINOR(ins.module->version);\n\n            neu_plugin_manager_destroy_instance(manager->plugin_manager, &ins);\n\n            if (NEU_VERSION_MAJOR != major || NEU_VERSION_MINOR != minor) {\n                nlog_warn(\"library %s plugin version error, major:%d minor:%d\",\n                          module_name, major, minor);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_MODULE_VERSION_NOT_MATCH;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n\n            if (!neu_plugin_manager_create_instance_by_lib_name(\n                    manager->plugin_manager, cmd->library, &ins)) {\n                nlog_warn(\"library %s not instance\", cmd->library);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_UPDATE_FAIL;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n\n            if (strcmp(module_name, ins.module->module_name) != 0) {\n                nlog_warn(\"library %s module name mismatch!\", cmd->library);\n                neu_plugin_manager_destroy_instance(manager->plugin_manager,\n                                                    &ins);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_UPDATE_FAIL;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n\n            neu_plugin_manager_destroy_instance(manager->plugin_manager, &ins);\n\n            if (!neu_plugin_manager_exists(manager->plugin_manager,\n                                           module_name)) {\n\n                nlog_warn(\"library %s plugin name no existed\", module_name);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_MODULE_NOT_EXISTS;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n\n        } else {\n            nlog_warn(\"library %s so file is not a vaild file\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = error;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (kind != NEU_PLUGIN_KIND_CUSTOM && kind != NEU_PLUGIN_KIND_SYSTEM) {\n            nlog_warn(\"library %s kind no support\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_MODULE_KIND_NOT_SUPPORT;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        char *schema_tmp_path = file_save_tmp(cmd->schema_file, \"json\");\n\n        if (schema_tmp_path == NULL) {\n            nlog_warn(\"library %s schema file save tmp fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_BODY_IS_WRONG;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        UT_array *nodes = neu_manager_get_nodes(\n            manager, NEU_NA_TYPE_DRIVER | NEU_NA_TYPE_APP, module_name, \"\");\n\n        if (nodes != NULL) {\n            if (utarray_len(nodes) > 0) {\n                utarray_free(nodes);\n                free(cmd->so_file);\n                free(cmd->schema_file);\n                free(so_tmp_path);\n                free(schema_tmp_path);\n                nlog_warn(\"library %s is using\", cmd->library);\n                header->type = NEU_RESP_ERROR;\n                e.error      = NEU_ERR_LIBRARY_IN_USE;\n                strcpy(header->receiver, header->sender);\n                reply(manager, header, &e);\n                break;\n            }\n            utarray_free(nodes);\n        }\n\n        if (!neu_plugin_manager_remove_library(manager->plugin_manager,\n                                               cmd->library)) {\n            nlog_warn(\"library %s src file remove fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            free(schema_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_UPDATE_FAIL;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (!mv_tmp_library_file(kind, so_tmp_path, cmd->library)) {\n            nlog_warn(\"library %s mv library tmp file fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            free(schema_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_UPDATE_FAIL;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (!mv_tmp_schema_file(kind, schema_tmp_path, schema)) {\n            nlog_warn(\"library %s schema file save schema fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            free(schema_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_UPDATE_FAIL;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        if (neu_plugin_manager_update(manager->plugin_manager, cmd->library) !=\n            NEU_ERR_SUCCESS) {\n            nlog_warn(\"update library %s fail\", cmd->library);\n            free(cmd->so_file);\n            free(cmd->schema_file);\n            free(so_tmp_path);\n            free(schema_tmp_path);\n            header->type = NEU_RESP_ERROR;\n            e.error      = NEU_ERR_LIBRARY_UPDATE_FAIL;\n            strcpy(header->receiver, header->sender);\n            reply(manager, header, &e);\n            break;\n        }\n\n        free(cmd->so_file);\n        free(cmd->schema_file);\n        free(so_tmp_path);\n        free(schema_tmp_path);\n        header->type = NEU_RESP_ERROR;\n        e.error      = NEU_ERR_SUCCESS;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &e);\n\n        break;\n    }\n    case NEU_REQ_GET_PLUGIN: {\n        UT_array *            plugins = neu_manager_get_plugins(manager);\n        neu_resp_get_plugin_t resp    = { .plugins = plugins };\n\n        header->type = NEU_RESP_GET_PLUGIN;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &resp);\n        break;\n    }\n    case NEU_REQ_CHECK_SCHEMA: {\n        neu_req_check_schema_t *cmd  = (neu_req_check_schema_t *) &header[1];\n        neu_resp_check_schema_t resp = { 0 };\n        strcpy(resp.schema, cmd->schema);\n        resp.exist   = neu_plugin_manager_schema_exist(manager->plugin_manager,\n                                                     cmd->schema);\n        header->type = NEU_RESP_CHECK_SCHEMA;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &resp);\n        break;\n    }\n    case NEU_REQ_ADD_NODE: {\n        neu_req_add_node_t *cmd = (neu_req_add_node_t *) &header[1];\n        nlog_notice(\"add node name:%s plugin:%s\", cmd->node, cmd->plugin);\n        int error =\n            neu_manager_add_node(manager, cmd->node, cmd->plugin, cmd->setting,\n                                 NEU_NODE_RUNNING_STATE_INIT, false);\n\n        neu_resp_error_t e = { .error = error };\n\n        if (error == NEU_ERR_SUCCESS) {\n            manager_storage_add_node(manager, cmd->node);\n            if (cmd->setting) {\n                adapter_storage_setting(cmd->node, cmd->setting);\n            }\n        }\n\n        neu_req_add_node_fini(cmd);\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &e);\n        break;\n    }\n    case NEU_REQ_UPDATE_NODE: {\n        neu_req_update_node_t *cmd = (neu_req_update_node_t *) &header[1];\n        neu_resp_error_t       e   = { 0 };\n        nlog_notice(\"update node name:%s new_name:%s\", cmd->node,\n                    cmd->new_name);\n        if (NULL == neu_node_manager_find(manager->node_manager, cmd->node)) {\n            e.error = NEU_ERR_NODE_NOT_EXIST;\n        } else if (NULL !=\n                   neu_node_manager_find(manager->node_manager,\n                                         cmd->new_name)) {\n            // this also makes renaming to the original name an error\n            e.error = NEU_ERR_NODE_EXIST;\n        }\n\n        if (0 == e.error) {\n            header->type = NEU_REQ_NODE_RENAME;\n            forward_msg(manager, header, header->receiver);\n        } else {\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        }\n\n        break;\n    }\n    case NEU_REQ_DEL_NODE: {\n        neu_req_del_node_t *cmd   = (neu_req_del_node_t *) &header[1];\n        neu_resp_error_t    error = { 0 };\n        nlog_notice(\"del node name:%s\", cmd->node);\n        neu_adapter_t *adapter =\n            neu_node_manager_find(manager->node_manager, cmd->node);\n        bool single =\n            neu_node_manager_is_single(manager->node_manager, cmd->node);\n\n        strcpy(header->receiver, cmd->node);\n        if (adapter == NULL) {\n            error.error  = NEU_ERR_NODE_NOT_EXIST;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &error);\n            break;\n        }\n\n        if (single) {\n            error.error  = NEU_ERR_NODE_NOT_ALLOW_DELETE;\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &error);\n            break;\n        }\n\n        manager_storage_del_node(manager, cmd->node);\n        if (neu_adapter_get_type(adapter) == NEU_NA_TYPE_APP) {\n            UT_array *subscriptions = neu_subscribe_manager_get(\n                manager->subscribe_manager, cmd->node, NULL, NULL);\n            neu_subscribe_manager_unsub_all(manager->subscribe_manager,\n                                            cmd->node);\n\n            utarray_foreach(subscriptions, neu_resp_subscribe_info_t *, sub)\n            {\n                // NOTE: neu_req_unsubscribe_t and neu_resp_subscribe_info_t\n                //       have compatible memory layout\n                msg = neu_msg_new(NEU_REQ_UNSUBSCRIBE_GROUP, NULL, sub);\n                if (NULL == msg) {\n                    break;\n                }\n                neu_reqresp_head_t *hd = neu_msg_get_header(msg);\n                strcpy(hd->receiver, sub->driver);\n                strcpy(hd->sender, \"manager\");\n                forward_msg(manager, hd, hd->receiver);\n            }\n            utarray_free(subscriptions);\n        }\n\n        neu_reqresp_node_deleted_t resp = { 0 };\n        strcpy(resp.node, header->receiver);\n        // notify MQTT about node removal\n        if (0 == strcmp(adapter->module->module_name, \"MQTT\")) {\n            msg = neu_msg_new(NEU_REQRESP_NODE_DELETED, NULL, &resp);\n            if (NULL != msg) {\n                neu_reqresp_head_t *hd = neu_msg_get_header(msg);\n                strcpy(hd->receiver, cmd->node);\n                strcpy(hd->sender, \"manager\");\n                reply(manager, hd, &resp);\n            }\n        }\n        header->type = NEU_REQ_NODE_UNINIT;\n        forward_msg(manager, header, header->receiver);\n\n        if (neu_adapter_get_type(adapter) == NEU_NA_TYPE_DRIVER) {\n            UT_array *apps = neu_subscribe_manager_find_by_driver(\n                manager->subscribe_manager, resp.node);\n\n            utarray_foreach(apps, neu_app_subscribe_t *, app)\n            {\n                msg = neu_msg_new(NEU_REQRESP_NODE_DELETED, NULL, &resp);\n                if (NULL == msg) {\n                    break;\n                }\n                header = neu_msg_get_header(msg);\n                strcpy(header->receiver, app->app_name);\n                strcpy(header->sender, \"manager\");\n                reply(manager, header, &resp);\n            }\n            utarray_free(apps);\n        }\n\n        break;\n    }\n    case NEU_RESP_NODE_UNINIT: {\n        neu_resp_node_uninit_t *cmd = (neu_resp_node_uninit_t *) &header[1];\n\n        neu_manager_del_node(manager, cmd->node);\n        if (strlen(header->receiver) > 0 &&\n            strcmp(header->receiver, \"manager\") != 0) {\n            neu_resp_error_t error = { 0 };\n            header->type           = NEU_RESP_ERROR;\n            reply(manager, header, &error);\n        } else {\n            neu_msg_free(msg);\n        }\n        break;\n    }\n    case NEU_REQ_GET_NODE: {\n        neu_req_get_node_t *cmd = (neu_req_get_node_t *) &header[1];\n        UT_array *          nodes =\n            neu_manager_get_nodes(manager, cmd->type, cmd->plugin, cmd->node);\n        neu_resp_get_node_t resp = { .nodes = nodes };\n\n        header->type = NEU_RESP_GET_NODE;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &resp);\n        break;\n    }\n    case NEU_REQ_SUBSCRIBE_GROUP: {\n        neu_req_subscribe_t *cmd      = (neu_req_subscribe_t *) &header[1];\n        neu_resp_error_t     error    = { 0 };\n        uint16_t             app_port = 0;\n\n        nlog_notice(\"add sub app_name:%s driver_node:%s group:%s params:%s\",\n                    cmd->app, cmd->driver, cmd->group,\n                    cmd->params != NULL ? cmd->params : \"\");\n\n        error.error = neu_manager_subscribe(manager, cmd->app, cmd->driver,\n                                            cmd->group, cmd->params, &app_port);\n\n        if (error.error == NEU_ERR_SUCCESS) {\n            cmd->port = app_port;\n            forward_msg_copy(manager, header, cmd->app);\n            forward_msg_copy(manager, header, cmd->driver);\n            manager_storage_subscribe(manager, cmd->app, cmd->driver,\n                                      cmd->group, cmd->params);\n        } else {\n            free(cmd->params);\n        }\n\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &error);\n        break;\n    }\n    case NEU_REQ_SUBSCRIBE_GROUPS: {\n        neu_req_subscribe_groups_t *cmd =\n            (neu_req_subscribe_groups_t *) &header[1];\n        neu_resp_error_t error = { 0 };\n\n        for (uint16_t i = 0; i < cmd->n_group; ++i) {\n            neu_req_subscribe_group_info_t *info = &cmd->groups[i];\n            nlog_notice(\"add sub app_name:%s driver_node:%s group:%s params:%s\",\n                        cmd->app, info->driver, info->group,\n                        info->params != NULL ? info->params : \"\");\n            error.error =\n                neu_manager_subscribe(manager, cmd->app, info->driver,\n                                      info->group, info->params, &info->port);\n            if (0 != error.error) {\n                break;\n            }\n\n            error.error = neu_manager_send_subscribe(manager, cmd->app,\n                                                     info->driver, info->group,\n                                                     info->port, info->params);\n            if (0 != error.error) {\n                break;\n            }\n\n            manager_storage_subscribe(manager, cmd->app, info->driver,\n                                      info->group, info->params);\n        }\n\n        neu_req_subscribe_groups_fini(cmd);\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &error);\n        break;\n    }\n    case NEU_REQ_UPDATE_SUBSCRIBE_GROUP: {\n        neu_req_subscribe_t *cmd   = (neu_req_subscribe_t *) &header[1];\n        neu_resp_error_t     error = { 0 };\n        nlog_notice(\"update sub app_name:%s driver_node:%s group:%s params:%s\",\n                    cmd->app, cmd->driver, cmd->group,\n                    cmd->params != NULL ? cmd->params : \"\");\n        error.error = neu_manager_update_subscribe(\n            manager, cmd->app, cmd->driver, cmd->group, cmd->params);\n\n        if (error.error == NEU_ERR_SUCCESS) {\n            forward_msg_copy(manager, header, cmd->app);\n            manager_storage_update_subscribe(manager, cmd->app, cmd->driver,\n                                             cmd->group, cmd->params);\n        } else {\n            free(cmd->params);\n        }\n\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &error);\n        break;\n    }\n    case NEU_REQ_UNSUBSCRIBE_GROUP: {\n        neu_req_unsubscribe_t *cmd   = (neu_req_unsubscribe_t *) &header[1];\n        neu_resp_error_t       error = { 0 };\n        nlog_notice(\"del sub app_name:%s driver_node:%s group:%s\", cmd->app,\n                    cmd->driver, cmd->group);\n        error.error =\n            neu_manager_unsubscribe(manager, cmd->app, cmd->driver, cmd->group);\n\n        if (error.error == NEU_ERR_SUCCESS) {\n            forward_msg_copy(manager, header, cmd->app);\n            forward_msg_copy(manager, header, cmd->driver);\n            manager_storage_unsubscribe(manager, cmd->app, cmd->driver,\n                                        cmd->group);\n        }\n\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &error);\n        break;\n    }\n    case NEU_REQ_GET_SUBSCRIBE_GROUP: {\n        neu_req_get_subscribe_group_t *cmd =\n            (neu_req_get_subscribe_group_t *) &header[1];\n        UT_array *groups = neu_manager_get_sub_group_deep_copy(\n            manager, cmd->app, cmd->driver, cmd->group);\n        neu_resp_get_subscribe_group_t resp = { .groups = groups };\n\n        strcpy(header->receiver, header->sender);\n        header->type = NEU_RESP_GET_SUBSCRIBE_GROUP;\n        reply(manager, header, &resp);\n        break;\n    }\n    case NEU_REQ_GET_SUB_DRIVER_TAGS: {\n        neu_req_get_sub_driver_tags_t *cmd =\n            (neu_req_get_sub_driver_tags_t *) &header[1];\n        neu_resp_get_sub_driver_tags_t resp = { 0 };\n        UT_array *groups = neu_manager_get_sub_group(manager, cmd->app);\n\n        utarray_new(resp.infos, neu_resp_get_sub_driver_tags_info_icd());\n        utarray_foreach(groups, neu_resp_subscribe_info_t *, info)\n        {\n            neu_resp_get_sub_driver_tags_info_t in = { 0 };\n            neu_adapter_t *                     driver =\n                neu_node_manager_find(manager->node_manager, info->driver);\n            assert(driver != NULL);\n\n            strcpy(in.driver, info->driver);\n            strcpy(in.group, info->group);\n            neu_adapter_driver_get_value_tag((neu_adapter_driver_t *) driver,\n                                             info->group, &in.tags);\n\n            utarray_push_back(resp.infos, &in);\n        }\n        utarray_free(groups);\n\n        strcpy(header->receiver, header->sender);\n        header->type = NEU_RESP_GET_SUB_DRIVER_TAGS;\n        reply(manager, header, &resp);\n\n        break;\n    }\n    case NEU_REQ_GET_NODES_STATE: {\n        neu_resp_get_nodes_state_t resp = { 0 };\n        UT_array *states = neu_node_manager_get_state(manager->node_manager);\n        neu_nodes_state_t *p_state = NULL;\n        while (\n            (p_state = (neu_nodes_state_t *) utarray_next(states, p_state))) {\n            p_state->sub_group_count = neu_subscribe_manager_group_count(\n                manager->subscribe_manager, p_state->node);\n        }\n        resp.states     = utarray_clone(states);\n        resp.core_level = manager->log_level;\n\n        strcpy(header->receiver, header->sender);\n        strcpy(header->sender, \"manager\");\n        header->type = NEU_RESP_GET_NODES_STATE;\n        reply(manager, header, &resp);\n\n        utarray_free(states);\n        break;\n    }\n    case NEU_REQ_GET_DRIVER_GROUP: {\n        neu_resp_get_driver_group_t resp = { 0 };\n\n        resp.groups = neu_manager_get_driver_group(manager);\n\n        strcpy(header->receiver, header->sender);\n        strcpy(header->sender, \"manager\");\n        header->type = NEU_RESP_GET_DRIVER_GROUP;\n        reply(manager, header, &resp);\n\n        break;\n    }\n\n    case NEU_REQ_GET_GROUP:\n    case NEU_REQ_GET_NODE_SETTING:\n    case NEU_REQ_READ_GROUP:\n    case NEU_REQ_READ_GROUP_PAGINATE:\n    case NEU_REQ_WRITE_TAG:\n    case NEU_REQ_WRITE_TAGS:\n    case NEU_REQ_WRITE_GTAGS:\n    case NEU_REQ_GET_TAG:\n    case NEU_REQ_NODE_CTL:\n    case NEU_REQ_ADD_GROUP: {\n        neu_otel_trace_ctx trace = NULL;\n        neu_otel_scope_ctx scope = NULL;\n        if (neu_otel_control_is_started() &&\n            (NEU_REQ_WRITE_TAG == header->type ||\n             NEU_REQ_WRITE_TAGS == header->type ||\n             NEU_REQ_WRITE_GTAGS == header->type)) {\n            trace = neu_otel_find_trace(header->ctx);\n            if (trace) {\n                scope = neu_otel_add_span(trace);\n                if (NEU_REQ_WRITE_TAG == header->type) {\n                    neu_otel_scope_set_span_name(scope, \"manager write tag\");\n                } else if (NEU_REQ_WRITE_TAGS == header->type) {\n                    neu_otel_scope_set_span_name(scope, \"manager write tags\");\n                } else if (NEU_REQ_WRITE_GTAGS == header->type) {\n                    neu_otel_scope_set_span_name(scope, \"manager write gtags\");\n                }\n                char new_span_id[36] = { 0 };\n                neu_otel_new_span_id(new_span_id);\n                neu_otel_scope_set_span_id(scope, new_span_id);\n                uint8_t *p_sp_id = neu_otel_scope_get_pre_span_id(scope);\n                if (p_sp_id) {\n                    neu_otel_scope_set_parent_span_id2(scope, p_sp_id, 8);\n                }\n                neu_otel_scope_add_span_attr_int(scope, \"thread id\",\n                                                 (int64_t) pthread_self());\n                neu_otel_scope_set_span_start_time(scope, neu_time_ns());\n            }\n        }\n\n        bool re_flag = false;\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            if (NEU_REQ_READ_GROUP == header->type) {\n                neu_req_read_group_fini((neu_req_read_group_t *) &header[1]);\n            } else if (NEU_REQ_READ_GROUP_PAGINATE == header->type) {\n                neu_req_read_group_paginate_fini(\n                    (neu_req_read_group_paginate_t *) &header[1]);\n            } else if (NEU_REQ_WRITE_TAG == header->type) {\n                neu_req_write_tag_fini((neu_req_write_tag_t *) &header[1]);\n            } else if (NEU_REQ_WRITE_TAGS == header->type) {\n                neu_req_write_tags_fini((neu_req_write_tags_t *) &header[1]);\n            } else if (NEU_REQ_WRITE_GTAGS == header->type) {\n                neu_req_write_gtags_fini((neu_req_write_gtags_t *) &header[1]);\n            }\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n            if (neu_otel_control_is_started() && trace) {\n                neu_otel_scope_set_status_code2(scope, NEU_OTEL_STATUS_ERROR,\n                                                NEU_ERR_NODE_NOT_EXIST);\n            }\n        } else {\n            forward_msg(manager, header, header->receiver);\n            re_flag = true;\n        }\n\n        if (neu_otel_control_is_started() && trace) {\n            neu_otel_scope_set_span_end_time(scope, neu_time_ns());\n            if (!re_flag) {\n                neu_otel_trace_set_final(trace);\n            }\n        }\n\n        break;\n    }\n    case NEU_REQ_PRGFILE_PROCESS:\n    case NEU_REQ_PRGFILE_UPLOAD:\n    case NEU_REQ_SCAN_TAGS:\n    case NEU_REQ_TEST_READ_TAG:\n    case NEU_REQ_GET_NODE_STATE: {\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        } else {\n            forward_msg(manager, header, header->receiver);\n        }\n\n        break;\n    }\n\n    case NEU_RESP_NODE_RENAME: {\n        neu_resp_node_rename_t *resp = (neu_resp_node_rename_t *) &header[1];\n        if (0 == resp->error) {\n            neu_manager_update_node_name(manager, resp->node, resp->new_name);\n            manager_storage_update_node(manager, resp->node, resp->new_name);\n\n            if (neu_node_manager_is_driver(manager->node_manager,\n                                           resp->new_name)) {\n                UT_array *apps = neu_subscribe_manager_find_by_driver(\n                    manager->subscribe_manager, resp->new_name);\n\n                // notify app node about driver renaming\n                utarray_foreach(apps, neu_app_subscribe_t *, app)\n                {\n                    header->type = NEU_REQ_UPDATE_NODE;\n                    forward_msg_copy(manager, header, app->app_name);\n                }\n\n                utarray_free(apps);\n            }\n        }\n\n        neu_resp_error_t e = { .error = resp->error };\n        header->type       = NEU_RESP_ERROR;\n        reply(manager, header, &e);\n        break;\n    }\n\n    case NEU_RESP_UPDATE_DRIVER_GROUP: {\n        neu_resp_update_group_t *resp = (neu_resp_update_group_t *) &header[1];\n        if (0 == resp->error) {\n            neu_manager_update_group_name(manager, resp->driver, resp->group,\n                                          resp->new_name);\n\n            UT_array *apps = neu_subscribe_manager_find(\n                manager->subscribe_manager, resp->driver, resp->new_name);\n\n            if (NULL != apps) {\n                // notify app node about group renaming\n                utarray_foreach(apps, neu_app_subscribe_t *, app)\n                {\n                    header->type = NEU_REQ_UPDATE_GROUP;\n                    forward_msg_copy(manager, header, app->app_name);\n                }\n\n                utarray_free(apps);\n            }\n        }\n\n        neu_resp_error_t e = { .error = resp->error };\n        header->type       = NEU_RESP_ERROR;\n        reply(manager, header, &e);\n        break;\n    }\n\n    case NEU_REQ_UPDATE_GROUP: {\n        neu_resp_error_t e = { 0 };\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            e.error = NEU_ERR_NODE_NOT_EXIST;\n        } else if (!neu_node_manager_is_driver(manager->node_manager,\n                                               header->receiver)) {\n            e.error = NEU_ERR_GROUP_NOT_ALLOW;\n        } else {\n            header->type = NEU_REQ_UPDATE_DRIVER_GROUP;\n            forward_msg(manager, header, header->receiver);\n        }\n\n        if (e.error) {\n            header->type = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        }\n\n        break;\n    }\n\n    case NEU_REQ_DEL_GROUP: {\n        neu_req_del_group_t *cmd = (neu_req_del_group_t *) &header[1];\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        } else {\n            UT_array *apps = neu_subscribe_manager_find(\n                manager->subscribe_manager, cmd->driver, cmd->group);\n\n            forward_msg(manager, header, header->receiver);\n            neu_subscribe_manager_remove(manager->subscribe_manager,\n                                         cmd->driver, cmd->group);\n\n            if (NULL == apps) {\n                break;\n            }\n\n            // notify app node about group deletion\n            utarray_foreach(apps, neu_app_subscribe_t *, app)\n            {\n                forward_msg_copy(manager, header, app->app_name);\n            }\n\n            utarray_free(apps);\n        }\n        break;\n    }\n    case NEU_REQ_DEL_TAG: {\n        neu_req_del_tag_t *cmd = (neu_req_del_tag_t *) &header[1];\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            for (int i = 0; i < cmd->n_tag; i++) {\n                free(cmd->tags[i]);\n            }\n            free(cmd->tags);\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        } else {\n            forward_msg(manager, header, header->receiver);\n        }\n\n        break;\n    }\n    case NEU_REQ_UPDATE_TAG:\n    case NEU_REQ_ADD_TAG: {\n        neu_req_add_tag_t *cmd = (neu_req_add_tag_t *) &header[1];\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            for (int i = 0; i < cmd->n_tag; i++) {\n                neu_tag_fini(&cmd->tags[i]);\n            }\n            free(cmd->tags);\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        } else {\n            forward_msg(manager, header, header->receiver);\n        }\n\n        break;\n    }\n    case NEU_REQ_ADD_GTAG: {\n        neu_req_add_gtag_t *cmd = (neu_req_add_gtag_t *) &header[1];\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            for (int i = 0; i < cmd->n_group; i++) {\n                for (int j = 0; j < cmd->groups[i].n_tag; j++) {\n                    neu_tag_fini(&cmd->groups[i].tags[j]);\n                }\n                free(cmd->groups[i].tags);\n            }\n            free(cmd->groups);\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        } else {\n            forward_msg(manager, header, header->receiver);\n        }\n\n        break;\n    }\n    case NEU_REQ_NODE_SETTING: {\n        neu_req_node_setting_t *cmd = (neu_req_node_setting_t *) &header[1];\n\n        if (neu_node_manager_find(manager->node_manager, header->receiver) ==\n            NULL) {\n            free(cmd->setting);\n            neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n            header->type       = NEU_RESP_ERROR;\n            neu_msg_exchange(header);\n            reply(manager, header, &e);\n        } else {\n            forward_msg(manager, header, header->receiver);\n        }\n        break;\n    }\n\n    case NEU_RESP_ADD_TAG:\n    case NEU_RESP_ADD_GTAG:\n    case NEU_RESP_UPDATE_TAG:\n    case NEU_RESP_GET_TAG:\n    case NEU_RESP_GET_GROUP:\n    case NEU_RESP_GET_NODE_SETTING:\n    case NEU_RESP_ERROR:\n    case NEU_RESP_READ_GROUP:\n    case NEU_RESP_READ_GROUP_PAGINATE:\n    case NEU_RESP_TEST_READ_TAG:\n    case NEU_RESP_PRGFILE_PROCESS:\n    case NEU_RESP_SCAN_TAGS:\n        forward_msg(manager, header, header->receiver);\n        break;\n\n    case NEU_RESP_GET_NODE_STATE: {\n        neu_resp_get_node_state_t *resp =\n            (neu_resp_get_node_state_t *) &header[1];\n\n        neu_adapter_t *adapter_node =\n            neu_node_manager_find(manager->node_manager, header->sender);\n        resp->sub_group_count = neu_subscribe_manager_group_count(\n            manager->subscribe_manager, header->sender);\n        resp->is_driver =\n            (adapter_node->module->type == NEU_NA_TYPE_DRIVER) ? true : false;\n        resp->core_level = manager->log_level;\n\n        forward_msg(manager, header, header->receiver);\n        break;\n    }\n\n    case NEU_REQ_ADD_DRIVERS: {\n        neu_req_driver_array_t *cmd = (neu_req_driver_array_t *) &header[1];\n        neu_resp_error_t        e   = { 0 };\n\n        e.error = neu_manager_add_drivers(manager, cmd);\n        if (NEU_ERR_SUCCESS == e.error) {\n            for (uint16_t i = 0; i < cmd->n_driver; ++i) {\n                neu_req_driver_t *driver = &cmd->drivers[i];\n                manager_storage_add_node(manager, driver->node);\n                adapter_storage_setting(driver->node, driver->setting);\n                for (uint16_t j = 0; j < driver->n_group; j++) {\n                    adapter_storage_add_group(driver->node,\n                                              driver->groups[j].group,\n                                              driver->groups[j].interval, NULL);\n                    adapter_storage_add_tags(\n                        driver->node, driver->groups[j].group,\n                        driver->groups[j].tags, driver->groups[j].n_tag);\n                }\n            }\n        }\n\n        neu_req_driver_array_fini(cmd);\n        header->type = NEU_RESP_ERROR;\n        strcpy(header->receiver, header->sender);\n        reply(manager, header, &e);\n        break;\n    }\n\n    case NEU_REQ_UPDATE_LOG_LEVEL: {\n        neu_req_update_log_level_t *cmd =\n            (neu_req_update_log_level_t *) &header[1];\n\n        if (cmd->core) {\n            manager->log_level = cmd->log_level;\n            nlog_level_change(manager->log_level);\n        }\n\n        if (strlen(cmd->node) > 0) {\n            if (neu_node_manager_find(manager->node_manager,\n                                      header->receiver) == NULL) {\n                neu_resp_error_t e = { .error = NEU_ERR_NODE_NOT_EXIST };\n                header->type       = NEU_RESP_ERROR;\n                neu_msg_exchange(header);\n                reply(manager, header, &e);\n            } else {\n                forward_msg(manager, header, header->receiver);\n            }\n        } else {\n            if (cmd->core) {\n                neu_resp_error_t e = { .error = NEU_ERR_SUCCESS };\n                header->type       = NEU_RESP_ERROR;\n                neu_msg_exchange(header);\n                reply(manager, header, &e);\n            } else {\n                neu_resp_error_t e = { .error = NEU_ERR_PARAM_IS_WRONG };\n                header->type       = NEU_RESP_ERROR;\n                neu_msg_exchange(header);\n                reply(manager, header, &e);\n            }\n        }\n\n        break;\n    }\n    default:\n        assert(false);\n        break;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 90, "func": "std::tuple<Tensor, Tensor> ctc_loss_cpu_template(const Tensor& log_probs, const Tensor& targets, IntArrayRef input_lengths, IntArrayRef target_lengths, int64_t BLANK) {\n  // log_probs: input_len x batch_size x num_labels\n  // targets [int64]: batch_size x target_length OR sum(target_lengths)\n  constexpr scalar_t neginf = -std::numeric_limits<scalar_t>::infinity();\n  using target_t = typename std::conditional_t<target_scalar_type == kInt, int, int64_t>;\n\n  Tensor neg_log_likelihood, log_alpha;\n  size_t tg_target_stride;\n  std::vector<int64_t> tg_batch_offsets;\n\n  if (targets.scalar_type() == kLong) {\n    std::tie(neg_log_likelihood, log_alpha,tg_target_stride, tg_batch_offsets) =\n        ctc_loss_allocate_outputs<scalar_t, kLong>(\n            log_probs, targets, input_lengths, target_lengths, BLANK);\n  } else {\n    std::tie(neg_log_likelihood, log_alpha, tg_target_stride, tg_batch_offsets) =\n        ctc_loss_allocate_outputs<scalar_t, kInt>(\n            log_probs, targets, input_lengths, target_lengths, BLANK);\n  }\n\n  int64_t batch_size = log_probs.size(1);\n  auto lpp  = log_probs.permute({1,0,2});\n  auto log_probs_a_global = lpp.accessor<const scalar_t, 3>();\n  auto log_alpha_a_global = log_alpha.accessor<scalar_t, 3>();\n  auto targets_data = targets.const_data_ptr<target_t>();\n  auto neg_log_likelihood_a = neg_log_likelihood.accessor<scalar_t, 1>();\n\n  // alpha calculation for the first row, the three equations for alpha_1 above eq (6)\n  // first the default\n  log_alpha.narrow(1, 0, 1).fill_(neginf);", "target": 1}
{"idx": 91, "func": "std::tuple<Tensor, Tensor> ctc_loss_cpu_template(const Tensor& log_probs, const Tensor& targets, IntArrayRef input_lengths, IntArrayRef target_lengths, int64_t BLANK) {\n  TORCH_CHECK(log_probs.numel() > 0, \"log_probs tensor must not be empty\");\n  // log_probs: input_len x batch_size x num_labels\n  // targets [int64]: batch_size x target_length OR sum(target_lengths)\n  constexpr scalar_t neginf = -std::numeric_limits<scalar_t>::infinity();\n  using target_t = typename std::conditional_t<target_scalar_type == kInt, int, int64_t>;\n\n  Tensor neg_log_likelihood, log_alpha;\n  size_t tg_target_stride;\n  std::vector<int64_t> tg_batch_offsets;\n\n  if (targets.scalar_type() == kLong) {\n    std::tie(neg_log_likelihood, log_alpha,tg_target_stride, tg_batch_offsets) =\n        ctc_loss_allocate_outputs<scalar_t, kLong>(\n            log_probs, targets, input_lengths, target_lengths, BLANK);\n  } else {\n    std::tie(neg_log_likelihood, log_alpha, tg_target_stride, tg_batch_offsets) =\n        ctc_loss_allocate_outputs<scalar_t, kInt>(\n            log_probs, targets, input_lengths, target_lengths, BLANK);\n  }\n\n  int64_t batch_size = log_probs.size(1);\n  auto lpp  = log_probs.permute({1,0,2});\n  auto log_probs_a_global = lpp.accessor<const scalar_t, 3>();\n  auto log_alpha_a_global = log_alpha.accessor<scalar_t, 3>();\n  auto targets_data = targets.const_data_ptr<target_t>();\n  auto neg_log_likelihood_a = neg_log_likelihood.accessor<scalar_t, 1>();\n\n  // alpha calculation for the first row, the three equations for alpha_1 above eq (6)\n  // first the default\n  log_alpha.narrow(1, 0, 1).fill_(neginf);", "target": 0}
{"idx": 92, "func": "std::tuple<Tensor, Tensor> ctc_loss_gpu_template(const Tensor& log_probs, const Tensor& targets, IntArrayRef input_lengths, IntArrayRef target_lengths, int64_t BLANK) {\n  // log_probs: input_len x batch_size x num_labels\n  // targets [int64]: batch_size x target_length OR sum(target_lengths)\n  CheckedFrom c = \"ctc_loss_gpu\";\n  using target_t = typename std::conditional_t<target_scalar_type == kInt, int, int64_t>;\n  auto log_probs_arg = TensorArg(log_probs, \"log_probs\", 1);\n  auto targets_arg = TensorArg(targets, \"targets\", 2);\n  checkAllSameGPU(c, {log_probs_arg, targets_arg});\n\n  checkScalarType(c, targets_arg, target_scalar_type);\n  checkDim(c, log_probs_arg, 3);\n  checkDimRange(c, targets_arg, 1, 3);\n\n  int64_t batch_size = log_probs.size(1);\n  int64_t num_labels = log_probs.size(2);\n  TORCH_CHECK((0 <= BLANK) && (BLANK < num_labels), \"blank must be in label range\");\n  TORCH_CHECK(input_lengths.size() == static_cast<size_t>(batch_size), \"input_lengths must be of size batch_size\");\n  TORCH_CHECK(target_lengths.size() == static_cast<size_t>(batch_size), \"target_lengths must be of size batch_size\");\n\n  int64_t tg_target_stride;\n\n  int64_t max_target_length = 0;\n  auto tg_batch_offsets = at::empty({batch_size}, at::device(at::kCPU).dtype(at::kLong));\n  auto tg_batch_offsets_data = tg_batch_offsets.mutable_data_ptr<int64_t>();\n  if (targets.dim() == 1) { // concatenated targets\n    int64_t pos = 0;\n    for (int64_t i = 0; i < batch_size; i++) {\n      TORCH_CHECK(target_lengths[i] >= 0,\n                  \"Expected target_lengths to have value at least \", 0, \", but got value \", target_lengths[i],\n                  \" (while checking arguments for \", c, \")\");\n      tg_batch_offsets_data[i] = pos;\n      pos += target_lengths[i];\n      if (max_target_length < target_lengths[i])\n        max_target_length = target_lengths[i];\n    }\n    tg_target_stride = targets.stride(0);\n    checkSize(c, targets_arg, 0, pos);\n  }\n  else { // batch x max_target_length\n    // dim is 2\n    int64_t tg_batch_stride = targets.stride(0);\n    for (int64_t i = 0; i < batch_size; i++) {\n      TORCH_CHECK(target_lengths[i] >= 0,\n                  \"Expected target_lengths to have value at least \", 0, \", but got value \", target_lengths[i],\n                  \" (while checking arguments for \", c, \")\");\n      tg_batch_offsets_data[i] = i * tg_batch_stride;\n      if (max_target_length < target_lengths[i])\n        max_target_length = target_lengths[i];\n    }\n    tg_target_stride = targets.stride(1);\n    checkSize(c, targets_arg, 0, batch_size);\n    TORCH_CHECK(targets.size(1) >= max_target_length,\n             \"Expected tensor to have size at least \", max_target_length, \" at dimension 1, but got size \", targets.size(1), \" for \", targets_arg,\n             \" (while checking arguments for \", c, \")\");\n  }\n  int64_t max_input_length = log_probs.size(0);\n  for (int64_t b = 0; b < batch_size; b++) {\n    TORCH_CHECK(input_lengths[b] >= 0,\n             \"Expected input_lengths to have value at least \", 0, \", but got value \", input_lengths[b],\n             \" (while checking arguments for \", c, \")\");\n    TORCH_CHECK(input_lengths[b] <= max_input_length,\n             \"Expected input_lengths to have value at most \", max_input_length, \", but got value \", input_lengths[b],\n             \" (while checking arguments for \", c, \")\");\n  }\n\n  auto target_lengths_t = at::tensor(target_lengths, targets.options().dtype(kLong));\n  auto input_lengths_t = at::tensor(input_lengths, targets.options().dtype(kLong));\n  tg_batch_offsets = tg_batch_offsets.cuda();\n\n  Tensor log_alpha = at::empty({batch_size, log_probs.size(0), 2*max_target_length+1}, log_probs.options());\n  Tensor neg_log_likelihood = at::empty({batch_size}, log_probs.options());\n\n  // Very likely, we could be more clever here, e.g. learning (or generalizing and reusing) from SoftMax.cu...\n  constexpr int max_threads = std::is_same_v<scalar_t, float> ? 1024 : 768; // we need 72 or so 32 bit registers for double\n  int threads_target = max_threads;\n  while (threads_target / 2 >= 2*max_target_length+1) {\n    threads_target /= 2;\n  }\n  int threads_batch = std::min(max_threads / threads_target, (int) batch_size);\n  dim3 block(threads_target, threads_batch);\n  dim3 grid(1, (batch_size+threads_batch-1)/threads_batch);\n  cudaStream_t stream = at::cuda::getCurrentCUDAStream();\n\n  ctc_loss_log_alpha_gpu_kernel<scalar_t, target_t><<<grid, block, 0, stream>>>(\n                      log_alpha.mutable_data_ptr<scalar_t>(),\n                      log_probs.const_data_ptr<scalar_t>(), input_lengths_t.const_data_ptr<int64_t>(), log_probs.size(0),\n                      targets.const_data_ptr<target_t>(), target_lengths_t.const_data_ptr<int64_t>(), max_target_length,\n                      neg_log_likelihood.mutable_data_ptr<scalar_t>(),\n                      log_probs.stride(0), log_probs.stride(1), log_probs.stride(2),\n                      log_alpha.stride(0), log_alpha.stride(1), log_alpha.stride(2),\n                      tg_batch_offsets.const_data_ptr<int64_t>(), tg_target_stride,\n                      batch_size, BLANK);\n  C10_CUDA_KERNEL_LAUNCH_CHECK();\n  return std::make_tuple(neg_log_likelihood, log_alpha);\n}\n\n// The second (backward) half of the forward backward algorithm, (10) and (11). This is parallel to the\n// alpha kernel above. (As mentioned above, it might make sense do the calculation in the alpha kernel.)\ntemplate<typename scalar_t, typename target_t>\n__global__ void\nC10_LAUNCH_BOUNDS_2((std::is_same_v<scalar_t, float> ? 1024 : 896), 1)", "target": 1}
{"idx": 93, "func": "std::tuple<Tensor, Tensor> ctc_loss_gpu_template(const Tensor& log_probs, const Tensor& targets, IntArrayRef input_lengths, IntArrayRef target_lengths, int64_t BLANK) {\n  TORCH_CHECK(log_probs.numel() > 0, \"log_probs tensor must not be empty\");\n  // log_probs: input_len x batch_size x num_labels\n  // targets [int64]: batch_size x target_length OR sum(target_lengths)\n  CheckedFrom c = \"ctc_loss_gpu\";\n  using target_t = typename std::conditional_t<target_scalar_type == kInt, int, int64_t>;\n  auto log_probs_arg = TensorArg(log_probs, \"log_probs\", 1);\n  auto targets_arg = TensorArg(targets, \"targets\", 2);\n  checkAllSameGPU(c, {log_probs_arg, targets_arg});\n\n  checkScalarType(c, targets_arg, target_scalar_type);\n  checkDim(c, log_probs_arg, 3);\n  checkDimRange(c, targets_arg, 1, 3);\n\n  int64_t batch_size = log_probs.size(1);\n  int64_t num_labels = log_probs.size(2);\n  TORCH_CHECK((0 <= BLANK) && (BLANK < num_labels), \"blank must be in label range\");\n  TORCH_CHECK(input_lengths.size() == static_cast<size_t>(batch_size), \"input_lengths must be of size batch_size\");\n  TORCH_CHECK(target_lengths.size() == static_cast<size_t>(batch_size), \"target_lengths must be of size batch_size\");\n\n  int64_t tg_target_stride;\n\n  int64_t max_target_length = 0;\n  auto tg_batch_offsets = at::empty({batch_size}, at::device(at::kCPU).dtype(at::kLong));\n  auto tg_batch_offsets_data = tg_batch_offsets.mutable_data_ptr<int64_t>();\n  if (targets.dim() == 1) { // concatenated targets\n    int64_t pos = 0;\n    for (int64_t i = 0; i < batch_size; i++) {\n      TORCH_CHECK(target_lengths[i] >= 0,\n                  \"Expected target_lengths to have value at least \", 0, \", but got value \", target_lengths[i],\n                  \" (while checking arguments for \", c, \")\");\n      tg_batch_offsets_data[i] = pos;\n      pos += target_lengths[i];\n      if (max_target_length < target_lengths[i])\n        max_target_length = target_lengths[i];\n    }\n    tg_target_stride = targets.stride(0);\n    checkSize(c, targets_arg, 0, pos);\n  }\n  else { // batch x max_target_length\n    // dim is 2\n    int64_t tg_batch_stride = targets.stride(0);\n    for (int64_t i = 0; i < batch_size; i++) {\n      TORCH_CHECK(target_lengths[i] >= 0,\n                  \"Expected target_lengths to have value at least \", 0, \", but got value \", target_lengths[i],\n                  \" (while checking arguments for \", c, \")\");\n      tg_batch_offsets_data[i] = i * tg_batch_stride;\n      if (max_target_length < target_lengths[i])\n        max_target_length = target_lengths[i];\n    }\n    tg_target_stride = targets.stride(1);\n    checkSize(c, targets_arg, 0, batch_size);\n    TORCH_CHECK(targets.size(1) >= max_target_length,\n             \"Expected tensor to have size at least \", max_target_length, \" at dimension 1, but got size \", targets.size(1), \" for \", targets_arg,\n             \" (while checking arguments for \", c, \")\");\n  }\n  int64_t max_input_length = log_probs.size(0);\n  for (int64_t b = 0; b < batch_size; b++) {\n    TORCH_CHECK(input_lengths[b] >= 0,\n             \"Expected input_lengths to have value at least \", 0, \", but got value \", input_lengths[b],\n             \" (while checking arguments for \", c, \")\");\n    TORCH_CHECK(input_lengths[b] <= max_input_length,\n             \"Expected input_lengths to have value at most \", max_input_length, \", but got value \", input_lengths[b],\n             \" (while checking arguments for \", c, \")\");\n  }\n\n  auto target_lengths_t = at::tensor(target_lengths, targets.options().dtype(kLong));\n  auto input_lengths_t = at::tensor(input_lengths, targets.options().dtype(kLong));\n  tg_batch_offsets = tg_batch_offsets.cuda();\n\n  Tensor log_alpha = at::empty({batch_size, log_probs.size(0), 2*max_target_length+1}, log_probs.options());\n  Tensor neg_log_likelihood = at::empty({batch_size}, log_probs.options());\n\n  // Very likely, we could be more clever here, e.g. learning (or generalizing and reusing) from SoftMax.cu...\n  constexpr int max_threads = std::is_same_v<scalar_t, float> ? 1024 : 768; // we need 72 or so 32 bit registers for double\n  int threads_target = max_threads;\n  while (threads_target / 2 >= 2*max_target_length+1) {\n    threads_target /= 2;\n  }\n  int threads_batch = std::min(max_threads / threads_target, (int) batch_size);\n  dim3 block(threads_target, threads_batch);\n  dim3 grid(1, (batch_size+threads_batch-1)/threads_batch);\n  cudaStream_t stream = at::cuda::getCurrentCUDAStream();\n\n  ctc_loss_log_alpha_gpu_kernel<scalar_t, target_t><<<grid, block, 0, stream>>>(\n                      log_alpha.mutable_data_ptr<scalar_t>(),\n                      log_probs.const_data_ptr<scalar_t>(), input_lengths_t.const_data_ptr<int64_t>(), log_probs.size(0),\n                      targets.const_data_ptr<target_t>(), target_lengths_t.const_data_ptr<int64_t>(), max_target_length,\n                      neg_log_likelihood.mutable_data_ptr<scalar_t>(),\n                      log_probs.stride(0), log_probs.stride(1), log_probs.stride(2),\n                      log_alpha.stride(0), log_alpha.stride(1), log_alpha.stride(2),\n                      tg_batch_offsets.const_data_ptr<int64_t>(), tg_target_stride,\n                      batch_size, BLANK);\n  C10_CUDA_KERNEL_LAUNCH_CHECK();\n  return std::make_tuple(neg_log_likelihood, log_alpha);\n}\n\n// The second (backward) half of the forward backward algorithm, (10) and (11). This is parallel to the\n// alpha kernel above. (As mentioned above, it might make sense do the calculation in the alpha kernel.)\ntemplate<typename scalar_t, typename target_t>\n__global__ void\nC10_LAUNCH_BOUNDS_2((std::is_same_v<scalar_t, float> ? 1024 : 896), 1)", "target": 0}
{"idx": 94, "func": "int32_t Crypto_TC_ProcessSecurity_Cam(uint8_t *ingest, int *len_ingest, TC_t *tc_sdls_processed_frame,\n                                      char *cam_cookies)\n// Loads the ingest frame into the global tc_frame while performing decryption\n{\n    // Local Variables\n    cam_cookies                            = cam_cookies;\n    int32_t                status          = CRYPTO_LIB_SUCCESS;\n    SecurityAssociation_t *sa_ptr          = NULL;\n    uint8_t                sa_service_type = -1;\n    uint8_t               *aad             = NULL;\n    uint16_t               aad_len;\n    uint32_t               encryption_cipher;\n    uint8_t                ecs_is_aead_algorithm = -1;\n    crypto_key_t          *ekp                   = NULL;\n    crypto_key_t          *akp                   = NULL;\n\n    int byte_idx = 0;\n\n    status = Crypto_TC_Process_Sanity_Check(len_ingest);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n    // Primary Header\n    tc_sdls_processed_frame->tc_header.tfvn   = ((uint8_t)ingest[byte_idx] & 0xC0) >> 6;\n    tc_sdls_processed_frame->tc_header.bypass = ((uint8_t)ingest[byte_idx] & 0x20) >> 5;\n    tc_sdls_processed_frame->tc_header.cc     = ((uint8_t)ingest[byte_idx] & 0x10) >> 4;\n    tc_sdls_processed_frame->tc_header.spare  = ((uint8_t)ingest[byte_idx] & 0x0C) >> 2;\n    tc_sdls_processed_frame->tc_header.scid   = ((uint8_t)ingest[byte_idx] & 0x03) << 8;\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.scid = tc_sdls_processed_frame->tc_header.scid | (uint8_t)ingest[byte_idx];\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.vcid = (((uint8_t)ingest[byte_idx] & 0xFC) >> 2) & crypto_config.vcid_bitmask;\n    tc_sdls_processed_frame->tc_header.fl   = ((uint8_t)ingest[byte_idx] & 0x03) << 8;\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.fl = tc_sdls_processed_frame->tc_header.fl | (uint8_t)ingest[byte_idx];\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.fsn = (uint8_t)ingest[byte_idx];\n    byte_idx++;\n\n    if (*len_ingest < tc_sdls_processed_frame->tc_header.fl + 1) // Specified frame length larger than provided frame!\n    {\n        status = CRYPTO_LIB_ERR_INPUT_FRAME_LENGTH_SHORTER_THAN_FRAME_HEADERS_LENGTH;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Lookup-retrieve managed parameters for frame via gvcid:\n    status = Crypto_Get_Managed_Parameters_For_Gvcid(\n        tc_sdls_processed_frame->tc_header.tfvn, tc_sdls_processed_frame->tc_header.scid,\n        tc_sdls_processed_frame->tc_header.vcid, gvcid_managed_parameters_array, &current_managed_parameters_struct);\n\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    } // Unable to get necessary Managed Parameters for TC TF -- return with error.\n\n    // Segment Header\n    Crypto_TC_Set_Segment_Header(tc_sdls_processed_frame, ingest, &byte_idx);\n\n    // Security Header\n    tc_sdls_processed_frame->tc_sec_header.spi = ((uint8_t)ingest[byte_idx] << 8) | (uint8_t)ingest[byte_idx + 1];\n    byte_idx += 2;\n\n#ifdef TC_DEBUG\n    printf(\"vcid = %d \\n\", tc_sdls_processed_frame->tc_header.vcid);\n    printf(\"spi  = %d \\n\", tc_sdls_processed_frame->tc_sec_header.spi);\n#endif\n\n    status = Crypto_TC_Sanity_Validations(tc_sdls_processed_frame, &sa_ptr);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Allocate the necessary byte arrays within the security header + trailer given the SA\n    // tc_sdls_processed_frame->tc_sec_header.iv = calloc(1, sa_ptr->iv_len);\n    // tc_sdls_processed_frame->tc_sec_header.sn = calloc(1, sa_ptr->arsn_len);\n    // tc_sdls_processed_frame->tc_sec_header.pad = calloc(1, sa_ptr->shplf_len);\n    // tc_sdls_processed_frame->tc_sec_trailer.mac = calloc(1, sa_ptr->stmacf_len);\n    // Set tc_sec_header + trailer fields for actual lengths from the SA (downstream apps won't know this length\n    // otherwise since they don't access the SADB!).\n    tc_sdls_processed_frame->tc_sec_header.iv_field_len  = sa_ptr->iv_len;\n    tc_sdls_processed_frame->tc_sec_header.sn_field_len  = sa_ptr->arsn_len;\n    tc_sdls_processed_frame->tc_sec_header.pad_field_len = sa_ptr->shplf_len;\n    // sprintf(tc_sdls_processed_frame->tc_sec_header.pad, \"%x\", pkcs_padding);\n\n    tc_sdls_processed_frame->tc_sec_trailer.mac_field_len = sa_ptr->stmacf_len;\n    // Determine SA Service Type\n    Crypto_TC_Get_SA_Service_Type(&sa_service_type, sa_ptr);\n\n    // Determine Algorithm cipher & mode. // TODO - Parse authentication_cipher, and handle AEAD cases properly\n    Crypto_TC_Get_Ciper_Mode_TCP(sa_service_type, &encryption_cipher, &ecs_is_aead_algorithm, sa_ptr);\n\n#ifdef TC_DEBUG\n    switch (sa_service_type)\n    {\n        case SA_PLAINTEXT:\n            printf(KBLU \"Processing a TC - CLEAR!\\n\" RESET);\n            break;\n        case SA_AUTHENTICATION:\n            printf(KBLU \"Processing a TC - AUTHENTICATED!\\n\" RESET);\n            break;\n        case SA_ENCRYPTION:\n            printf(KBLU \"Processing a TC - ENCRYPTED!\\n\" RESET);\n            break;\n        case SA_AUTHENTICATED_ENCRYPTION:\n            printf(KBLU \"Processing a TC - AUTHENTICATED ENCRYPTION!\\n\" RESET);\n            break;\n    }\n#endif\n\n    // TODO: Calculate lengths when needed\n    uint8_t fecf_len        = FECF_SIZE;\n    uint8_t segment_hdr_len = TC_SEGMENT_HDR_SIZE;\n\n    Crypto_TC_Calc_Lengths(&fecf_len, &segment_hdr_len);\n\n    // Parse & Check FECF\n    Crypto_TC_Parse_Check_FECF(ingest, len_ingest, tc_sdls_processed_frame);\n\n    // Parse transmitted portion of IV from received frame (Will be Whole IV if iv_len==shivf_len)\n    memcpy((tc_sdls_processed_frame->tc_sec_header.iv + (sa_ptr->iv_len - sa_ptr->shivf_len)),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN]), sa_ptr->shivf_len);\n\n    // Handle non-transmitted IV increment case (transmitted-portion roll-over)\n    status = Crypto_TC_Nontransmitted_IV_Increment(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(\"Full IV Value from Frame and SADB (if applicable):\\n\");\n    Crypto_hexprint(tc_sdls_processed_frame->tc_sec_header.iv, sa_ptr->iv_len);\n#endif\n\n    // Parse transmitted portion of ARSN\n    memcpy((tc_sdls_processed_frame->tc_sec_header.sn + (sa_ptr->arsn_len - sa_ptr->shsnf_len)),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len]), sa_ptr->shsnf_len);\n\n    // Handle non-transmitted SN increment case (transmitted-portion roll-over)\n    status = Crypto_TC_Nontransmitted_SN_Increment(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(\"Full ARSN Value from Frame and SADB (if applicable):\\n\");\n    Crypto_hexprint(tc_sdls_processed_frame->tc_sec_header.sn, sa_ptr->arsn_len);\n#endif\n\n    // Parse pad length\n    // tc_sdls_processed_frame->tc_sec_header.pad = malloc((sa_ptr->shplf_len * sizeof(uint8_t)));\n    memcpy((tc_sdls_processed_frame->tc_sec_header.pad),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len + sa_ptr->shsnf_len]),\n           sa_ptr->shplf_len);\n\n    // Parse MAC, prepare AAD\n    status = Crypto_TC_Prep_AAD(tc_sdls_processed_frame, fecf_len, sa_service_type, ecs_is_aead_algorithm, &aad_len,\n                                sa_ptr, segment_hdr_len, ingest, &aad);\n\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    uint16_t tc_enc_payload_start_index =\n        TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len + sa_ptr->shsnf_len + sa_ptr->shplf_len;\n\n    // Todo -- if encrypt only, ignore stmacf_len entirely to avoid erroring on SA misconfiguration... Or just throw a\n    // warning/error indicating SA misconfiguration?\n    tc_sdls_processed_frame->tc_pdu_len =\n        tc_sdls_processed_frame->tc_header.fl + 1 - tc_enc_payload_start_index - sa_ptr->stmacf_len - fecf_len;\n\n    if (tc_sdls_processed_frame->tc_pdu_len >\n        tc_sdls_processed_frame->tc_header.fl) // invalid header parsed, sizes overflowed & make no sense!\n    {\n        status = CRYPTO_LIB_ERR_INVALID_HEADER;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(KYEL \"TC PDU Calculated Length: %d \\n\" RESET, tc_sdls_processed_frame->tc_pdu_len);\n#endif\n\n    /* Get Key */\n    status = Crypto_TC_Get_Keys(&ekp, &akp, sa_ptr);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    status = Crypto_TC_Do_Decrypt(sa_service_type, ecs_is_aead_algorithm, ekp, sa_ptr, aad, tc_sdls_processed_frame,\n                                  ingest, tc_enc_payload_start_index, aad_len, cam_cookies, akp, segment_hdr_len);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        Crypto_TC_Safe_Free_Ptr(aad);\n        mc_if->mc_log(status);\n        return status; // Cryptography IF call failed, return.\n    }\n\n    // Now that MAC has been verified, check IV & ARSN if applicable\n    status = Crypto_TC_Check_IV_ARSN(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        Crypto_TC_Safe_Free_Ptr(aad);\n        mc_if->mc_log(status);\n        return status; // Cryptography IF call failed, return.\n    }\n    // Extended PDU processing, if applicable\n\n    if (status == CRYPTO_LIB_SUCCESS && crypto_config.process_sdls_pdus == TC_PROCESS_SDLS_PDUS_TRUE)\n    {\n        status = Crypto_Process_Extended_Procedure_Pdu(tc_sdls_processed_frame, ingest);\n    }\n\n    Crypto_TC_Safe_Free_Ptr(aad);\n\n    mc_if->mc_log(status);\n    return status;\n}\n\n/**\n * @brief Function: Crypto_Get_tcPayloadLength\n * Returns the payload length of current tc_frame in BYTES!\n * @param tc_frame: TC_t*\n * @param sa_ptr: SecurityAssociation_t\n * @return int32, Length of TCPayload\n **/\n/*\nint32_t Crypto_Get_tcPayloadLength(TC_t* tc_frame, SecurityAssociation_t* sa_ptr)\n{\n    int tf_hdr = 5;\n    int seg_hdr = 0;if(current_managed_parameters_struct.has_segmentation_hdr==TC_HAS_SEGMENT_HDRS){seg_hdr=1;}\n    int fecf = 0;if(current_managed_parameters_struct.has_fecf==TC_HAS_FECF){fecf=FECF_SIZE;}\n    int spi = 2;\n    int iv_size = sa_ptr->shivf_len;\n    int mac_size = sa_ptr->stmacf_len;\n\n    #ifdef TC_DEBUG\n        printf(\"Get_tcPayloadLength Debug [byte lengths]:\\n\");\n        printf(\"\\thdr.fl\\t%d\\n\", tc_frame->tc_header.fl);\n        printf(\"\\ttf_hdr\\t%d\\n\",tf_hdr);\n        printf(\"\\tSeg hdr\\t%d\\t\\n\",seg_hdr);\n        printf(\"\\tspi \\t%d\\n\",spi);\n        printf(\"\\tiv_size\\t%d\\n\",iv_size);\n        printf(\"\\tmac\\t%d\\n\",mac_size);\n        printf(\"\\tfecf \\t%d\\n\",fecf);\n        printf(\"\\tTOTAL LENGTH: %d\\n\", (tc_frame->tc_header.fl - (tf_hdr + seg_hdr + spi + iv_size ) - (mac_size +\nfecf))); #endif\n\n    return (tc_frame->tc_header.fl + 1 - (tf_hdr + seg_hdr + spi + iv_size ) - (mac_size + fecf) );\n}\n*/\n\n/**\n * @brief Function: Crypto_Prepare_TC_AAD\n * Callocs and returns pointer to buffer where AAD is created & bitwise-anded with bitmask!\n * Note: Function caller is responsible for freeing the returned buffer!\n * @param buffer: uint8_t*\n * @param len_aad: uint16_t\n * @param abm_buffer: uint8_t*\n **/", "target": 1}
{"idx": 95, "func": "int32_t Crypto_TC_ProcessSecurity_Cam(uint8_t *ingest, int *len_ingest, TC_t *tc_sdls_processed_frame,\n                                      char *cam_cookies)\n// Loads the ingest frame into the global tc_frame while performing decryption\n{\n    // Local Variables\n    cam_cookies                            = cam_cookies;\n    int32_t                status          = CRYPTO_LIB_SUCCESS;\n    SecurityAssociation_t *sa_ptr          = NULL;\n    uint8_t                sa_service_type = -1;\n    uint8_t               *aad             = NULL;\n    uint16_t               aad_len;\n    uint32_t               encryption_cipher;\n    uint8_t                ecs_is_aead_algorithm = -1;\n    crypto_key_t          *ekp                   = NULL;\n    crypto_key_t          *akp                   = NULL;\n\n    int byte_idx = 0;\n\n    status = Crypto_TC_Process_Sanity_Check(len_ingest);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n    // Primary Header\n    tc_sdls_processed_frame->tc_header.tfvn   = ((uint8_t)ingest[byte_idx] & 0xC0) >> 6;\n    tc_sdls_processed_frame->tc_header.bypass = ((uint8_t)ingest[byte_idx] & 0x20) >> 5;\n    tc_sdls_processed_frame->tc_header.cc     = ((uint8_t)ingest[byte_idx] & 0x10) >> 4;\n    tc_sdls_processed_frame->tc_header.spare  = ((uint8_t)ingest[byte_idx] & 0x0C) >> 2;\n    tc_sdls_processed_frame->tc_header.scid   = ((uint8_t)ingest[byte_idx] & 0x03) << 8;\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.scid = tc_sdls_processed_frame->tc_header.scid | (uint8_t)ingest[byte_idx];\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.vcid = (((uint8_t)ingest[byte_idx] & 0xFC) >> 2) & crypto_config.vcid_bitmask;\n    tc_sdls_processed_frame->tc_header.fl   = ((uint8_t)ingest[byte_idx] & 0x03) << 8;\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.fl = tc_sdls_processed_frame->tc_header.fl | (uint8_t)ingest[byte_idx];\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.fsn = (uint8_t)ingest[byte_idx];\n    byte_idx++;\n\n    if (*len_ingest < tc_sdls_processed_frame->tc_header.fl + 1) // Specified frame length larger than provided frame!\n    {\n        status = CRYPTO_LIB_ERR_INPUT_FRAME_LENGTH_SHORTER_THAN_FRAME_HEADERS_LENGTH;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Lookup-retrieve managed parameters for frame via gvcid:\n    status = Crypto_Get_Managed_Parameters_For_Gvcid(\n        tc_sdls_processed_frame->tc_header.tfvn, tc_sdls_processed_frame->tc_header.scid,\n        tc_sdls_processed_frame->tc_header.vcid, gvcid_managed_parameters_array, &current_managed_parameters_struct);\n\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    } // Unable to get necessary Managed Parameters for TC TF -- return with error.\n\n    // Segment Header\n    Crypto_TC_Set_Segment_Header(tc_sdls_processed_frame, ingest, &byte_idx);\n\n    // Security Header\n    tc_sdls_processed_frame->tc_sec_header.spi = ((uint8_t)ingest[byte_idx] << 8) | (uint8_t)ingest[byte_idx + 1];\n    byte_idx += 2;\n\n#ifdef TC_DEBUG\n    printf(\"vcid = %d \\n\", tc_sdls_processed_frame->tc_header.vcid);\n    printf(\"spi  = %d \\n\", tc_sdls_processed_frame->tc_sec_header.spi);\n#endif\n\n    status = Crypto_TC_Sanity_Validations(tc_sdls_processed_frame, &sa_ptr);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Allocate the necessary byte arrays within the security header + trailer given the SA\n    // tc_sdls_processed_frame->tc_sec_header.iv = calloc(1, sa_ptr->iv_len);\n    // tc_sdls_processed_frame->tc_sec_header.sn = calloc(1, sa_ptr->arsn_len);\n    // tc_sdls_processed_frame->tc_sec_header.pad = calloc(1, sa_ptr->shplf_len);\n    // tc_sdls_processed_frame->tc_sec_trailer.mac = calloc(1, sa_ptr->stmacf_len);\n    // Set tc_sec_header + trailer fields for actual lengths from the SA (downstream apps won't know this length\n    // otherwise since they don't access the SADB!).\n    tc_sdls_processed_frame->tc_sec_header.iv_field_len  = sa_ptr->iv_len;\n    tc_sdls_processed_frame->tc_sec_header.sn_field_len  = sa_ptr->arsn_len;\n    tc_sdls_processed_frame->tc_sec_header.pad_field_len = sa_ptr->shplf_len;\n    // sprintf(tc_sdls_processed_frame->tc_sec_header.pad, \"%x\", pkcs_padding);\n\n    tc_sdls_processed_frame->tc_sec_trailer.mac_field_len = sa_ptr->stmacf_len;\n    // Determine SA Service Type\n    Crypto_TC_Get_SA_Service_Type(&sa_service_type, sa_ptr);\n\n    // Determine Algorithm cipher & mode. // TODO - Parse authentication_cipher, and handle AEAD cases properly\n    Crypto_TC_Get_Ciper_Mode_TCP(sa_service_type, &encryption_cipher, &ecs_is_aead_algorithm, sa_ptr);\n\n#ifdef TC_DEBUG\n    switch (sa_service_type)\n    {\n        case SA_PLAINTEXT:\n            printf(KBLU \"Processing a TC - CLEAR!\\n\" RESET);\n            break;\n        case SA_AUTHENTICATION:\n            printf(KBLU \"Processing a TC - AUTHENTICATED!\\n\" RESET);\n            break;\n        case SA_ENCRYPTION:\n            printf(KBLU \"Processing a TC - ENCRYPTED!\\n\" RESET);\n            break;\n        case SA_AUTHENTICATED_ENCRYPTION:\n            printf(KBLU \"Processing a TC - AUTHENTICATED ENCRYPTION!\\n\" RESET);\n            break;\n    }\n#endif\n\n    // TODO: Calculate lengths when needed\n    uint8_t fecf_len        = FECF_SIZE;\n    uint8_t segment_hdr_len = TC_SEGMENT_HDR_SIZE;\n\n    Crypto_TC_Calc_Lengths(&fecf_len, &segment_hdr_len);\n\n    if(tc_sdls_processed_frame->tc_header.fl <= TC_FRAME_HEADER_SIZE - segment_hdr_len - fecf_len + 1)\n    {\n        status = CRYPTO_LIB_ERR_TC_FRAME_LENGTH_UNDERFLOW;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Parse & Check FECF\n    Crypto_TC_Parse_Check_FECF(ingest, len_ingest, tc_sdls_processed_frame);\n\n    // Parse transmitted portion of IV from received frame (Will be Whole IV if iv_len==shivf_len)\n    memcpy((tc_sdls_processed_frame->tc_sec_header.iv + (sa_ptr->iv_len - sa_ptr->shivf_len)),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN]), sa_ptr->shivf_len);\n\n    // Handle non-transmitted IV increment case (transmitted-portion roll-over)\n    status = Crypto_TC_Nontransmitted_IV_Increment(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(\"Full IV Value from Frame and SADB (if applicable):\\n\");\n    Crypto_hexprint(tc_sdls_processed_frame->tc_sec_header.iv, sa_ptr->iv_len);\n#endif\n\n    // Parse transmitted portion of ARSN\n    memcpy((tc_sdls_processed_frame->tc_sec_header.sn + (sa_ptr->arsn_len - sa_ptr->shsnf_len)),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len]), sa_ptr->shsnf_len);\n\n    // Handle non-transmitted SN increment case (transmitted-portion roll-over)\n    status = Crypto_TC_Nontransmitted_SN_Increment(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(\"Full ARSN Value from Frame and SADB (if applicable):\\n\");\n    Crypto_hexprint(tc_sdls_processed_frame->tc_sec_header.sn, sa_ptr->arsn_len);\n#endif\n\n    // Parse pad length\n    // tc_sdls_processed_frame->tc_sec_header.pad = malloc((sa_ptr->shplf_len * sizeof(uint8_t)));\n    memcpy((tc_sdls_processed_frame->tc_sec_header.pad),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len + sa_ptr->shsnf_len]),\n           sa_ptr->shplf_len);\n\n    // Parse MAC, prepare AAD\n    status = Crypto_TC_Prep_AAD(tc_sdls_processed_frame, fecf_len, sa_service_type, ecs_is_aead_algorithm, &aad_len,\n                                sa_ptr, segment_hdr_len, ingest, &aad);\n\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    uint16_t tc_enc_payload_start_index =\n        TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len + sa_ptr->shsnf_len + sa_ptr->shplf_len;\n\n    // Todo -- if encrypt only, ignore stmacf_len entirely to avoid erroring on SA misconfiguration... Or just throw a\n    // warning/error indicating SA misconfiguration?\n    tc_sdls_processed_frame->tc_pdu_len =\n        tc_sdls_processed_frame->tc_header.fl + 1 - tc_enc_payload_start_index - sa_ptr->stmacf_len - fecf_len;\n\n    if (tc_sdls_processed_frame->tc_pdu_len >\n        tc_sdls_processed_frame->tc_header.fl) // invalid header parsed, sizes overflowed & make no sense!\n    {\n        status = CRYPTO_LIB_ERR_INVALID_HEADER;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(KYEL \"TC PDU Calculated Length: %d \\n\" RESET, tc_sdls_processed_frame->tc_pdu_len);\n#endif\n\n    /* Get Key */\n    status = Crypto_TC_Get_Keys(&ekp, &akp, sa_ptr);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    status = Crypto_TC_Do_Decrypt(sa_service_type, ecs_is_aead_algorithm, ekp, sa_ptr, aad, tc_sdls_processed_frame,\n                                  ingest, tc_enc_payload_start_index, aad_len, cam_cookies, akp, segment_hdr_len);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        Crypto_TC_Safe_Free_Ptr(aad);\n        mc_if->mc_log(status);\n        return status; // Cryptography IF call failed, return.\n    }\n\n    // Now that MAC has been verified, check IV & ARSN if applicable\n    status = Crypto_TC_Check_IV_ARSN(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        Crypto_TC_Safe_Free_Ptr(aad);\n        mc_if->mc_log(status);\n        return status; // Cryptography IF call failed, return.\n    }\n    // Extended PDU processing, if applicable\n\n    if (status == CRYPTO_LIB_SUCCESS && crypto_config.process_sdls_pdus == TC_PROCESS_SDLS_PDUS_TRUE)\n    {\n        status = Crypto_Process_Extended_Procedure_Pdu(tc_sdls_processed_frame, ingest);\n    }\n\n    Crypto_TC_Safe_Free_Ptr(aad);\n\n    mc_if->mc_log(status);\n    return status;\n}\n\n/**\n * @brief Function: Crypto_Get_tcPayloadLength\n * Returns the payload length of current tc_frame in BYTES!\n * @param tc_frame: TC_t*\n * @param sa_ptr: SecurityAssociation_t\n * @return int32, Length of TCPayload\n **/\n/*\nint32_t Crypto_Get_tcPayloadLength(TC_t* tc_frame, SecurityAssociation_t* sa_ptr)\n{\n    int tf_hdr = 5;\n    int seg_hdr = 0;if(current_managed_parameters_struct.has_segmentation_hdr==TC_HAS_SEGMENT_HDRS){seg_hdr=1;}\n    int fecf = 0;if(current_managed_parameters_struct.has_fecf==TC_HAS_FECF){fecf=FECF_SIZE;}\n    int spi = 2;\n    int iv_size = sa_ptr->shivf_len;\n    int mac_size = sa_ptr->stmacf_len;\n\n    #ifdef TC_DEBUG\n        printf(\"Get_tcPayloadLength Debug [byte lengths]:\\n\");\n        printf(\"\\thdr.fl\\t%d\\n\", tc_frame->tc_header.fl);\n        printf(\"\\ttf_hdr\\t%d\\n\",tf_hdr);\n        printf(\"\\tSeg hdr\\t%d\\t\\n\",seg_hdr);\n        printf(\"\\tspi \\t%d\\n\",spi);\n        printf(\"\\tiv_size\\t%d\\n\",iv_size);\n        printf(\"\\tmac\\t%d\\n\",mac_size);\n        printf(\"\\tfecf \\t%d\\n\",fecf);\n        printf(\"\\tTOTAL LENGTH: %d\\n\", (tc_frame->tc_header.fl - (tf_hdr + seg_hdr + spi + iv_size ) - (mac_size +\nfecf))); #endif\n\n    return (tc_frame->tc_header.fl + 1 - (tf_hdr + seg_hdr + spi + iv_size ) - (mac_size + fecf) );\n}\n*/\n\n/**\n * @brief Function: Crypto_Prepare_TC_AAD\n * Callocs and returns pointer to buffer where AAD is created & bitwise-anded with bitmask!\n * Note: Function caller is responsible for freeing the returned buffer!\n * @param buffer: uint8_t*\n * @param len_aad: uint16_t\n * @param abm_buffer: uint8_t*\n **/", "target": 0}
{"idx": 96, "func": "UTEST(TC_PROCESS, TC_KEY_STATE_TEST)\n{\n    remove(\"sa_save_file.bin\");\n    // Local Variables\n    int32_t status = CRYPTO_LIB_SUCCESS;\n\n    // Configure Parameters\n    Crypto_Config_CryptoLib(KEY_TYPE_INTERNAL, MC_TYPE_INTERNAL, SA_TYPE_INMEMORY, CRYPTOGRAPHY_TYPE_LIBGCRYPT,\n                            IV_INTERNAL, CRYPTO_TC_CREATE_FECF_TRUE, TC_PROCESS_SDLS_PDUS_TRUE, TC_HAS_PUS_HDR,\n                            TC_IGNORE_SA_STATE_FALSE, TC_IGNORE_ANTI_REPLAY_TRUE, TC_UNIQUE_SA_PER_MAP_ID_FALSE,\n                            TC_CHECK_FECF_TRUE, 0x3F, SA_INCREMENT_NONTRANSMITTED_IV_TRUE);\n    // AOS Tests\n    // Crypto_Config_Add_Gvcid_Managed_Parameter(0, 0x0003, 0, TC_HAS_FECF, TC_HAS_SEGMENT_HDRS, TC_OCF_NA, 1024,\n    // AOS_FHEC_NA, AOS_IZ_NA, 0);\n    GvcidManagedParameters_t AOS_Managed_Parameters = {\n        0, 0x0003, 0, TC_HAS_FECF, AOS_FHEC_NA, AOS_IZ_NA, 0, TC_HAS_SEGMENT_HDRS, 1024, TC_OCF_NA, 1};\n    Crypto_Config_Add_Gvcid_Managed_Parameters(AOS_Managed_Parameters);\n\n    status = Crypto_Init();\n\n    TC_t *tc_sdls_processed_frame;\n    tc_sdls_processed_frame = malloc(sizeof(uint8_t) * TC_SIZE);\n    memset(tc_sdls_processed_frame, 0, (sizeof(uint8_t) * TC_SIZE));\n\n    // Test frame setup\n    char    *test_frame_pt_h = \"2003002A0000000100000000000000000000000000000000025364F9BC3344AF359DA06CA886748F59A0AB\";\n    uint8_t *test_frame_pt_b = NULL;\n    int      test_frame_pt_len = 0;\n\n    SecurityAssociation_t *test_association;\n    sa_if->sa_get_from_spi(1, &test_association);\n    test_association->sa_state  = SA_OPERATIONAL;\n    test_association->est       = 1;\n    test_association->arsn_len  = 0;\n    test_association->shsnf_len = 0;\n\n    crypto_key_t *ekp = NULL;\n    ekp               = key_if->get_key(test_association->ekid);\n    ekp->key_state    = KEY_DEACTIVATED;\n\n    crypto_key_t *akp = NULL;\n    akp               = key_if->get_key(test_association->akid);\n    akp->key_state    = KEY_DEACTIVATED;\n\n    // Convert input test frame\n    hex_conversion(test_frame_pt_h, (char **)&test_frame_pt_b, &test_frame_pt_len);\n\n    status = Crypto_TC_ProcessSecurity(test_frame_pt_b, &test_frame_pt_len, tc_sdls_processed_frame);\n\n    ASSERT_EQ(CRYPTO_LIB_ERR_KEY_STATE_INVALID, status);\n    free(test_frame_pt_b);\n    free(tc_sdls_processed_frame);\n    Crypto_Shutdown();\n}\n\nUTEST_MAIN();", "target": 1}
{"idx": 97, "func": "UTEST(TC_PROCESS, TC_HEAP_BUFFER_OVERFLOW_TEST)\n{\n    remove(\"sa_save_file.bin\");\n    // Local Variables\n    int32_t status = CRYPTO_LIB_SUCCESS;\n\n    // Configure Parameters\n    Crypto_Config_CryptoLib(KEY_TYPE_INTERNAL, MC_TYPE_INTERNAL, SA_TYPE_INMEMORY, CRYPTOGRAPHY_TYPE_LIBGCRYPT,\n                            IV_INTERNAL, CRYPTO_TC_CREATE_FECF_TRUE, TC_PROCESS_SDLS_PDUS_TRUE, TC_HAS_PUS_HDR,\n                            TC_IGNORE_SA_STATE_FALSE, TC_IGNORE_ANTI_REPLAY_TRUE, TC_UNIQUE_SA_PER_MAP_ID_FALSE,\n                            TC_CHECK_FECF_TRUE, 0x3F, SA_INCREMENT_NONTRANSMITTED_IV_TRUE);\n    // AOS Tests\n    // Crypto_Config_Add_Gvcid_Managed_Parameter(0, 0x0003, 0, TC_HAS_FECF, TC_HAS_SEGMENT_HDRS, TC_OCF_NA, 1024,\n    // AOS_FHEC_NA, AOS_IZ_NA, 0);\n    GvcidManagedParameters_t AOS_Managed_Parameters = {\n        0, 0x0003, 0, TC_HAS_FECF, AOS_FHEC_NA, AOS_IZ_NA, 0, TC_HAS_SEGMENT_HDRS, 1024, TC_OCF_NA, 1};\n    Crypto_Config_Add_Gvcid_Managed_Parameters(AOS_Managed_Parameters);\n\n    status = Crypto_Init();\n\n    TC_t *tc_sdls_processed_frame;\n    tc_sdls_processed_frame = malloc(sizeof(uint8_t) * TC_SIZE);\n    memset(tc_sdls_processed_frame, 0, (sizeof(uint8_t) * TC_SIZE));\n\n    // Test frame setup\n    char    *test_frame_pt_h = \"080300007f0b000afd020202027fff02020202020202020202020202029bdd5f3c98dd1c50d27a430\"\n                               \"a4b6757aa33ec183952a9f76e504eb5f8001066ed6c00c8788e11997f2a058da1633e11fed9851d45\"\n                               \"7bb31a9637ec8f4f15bc8575a0e7104dba5c666b17f7cccdc2adbff9\";\n    uint8_t *test_frame_pt_b = NULL;\n    int      test_frame_pt_len = 0;\n\n    SecurityAssociation_t *test_association;\n    sa_if->sa_get_from_spi(10, &test_association);\n    test_association->sa_state  = SA_OPERATIONAL;\n    test_association->est       = 1;\n    test_association->arsn_len  = 0;\n    test_association->shsnf_len = 0;\n\n    crypto_key_t *ekp = NULL;\n    ekp               = key_if->get_key(test_association->ekid);\n    ekp->key_state    = KEY_ACTIVE;\n\n    // Convert input test frame\n    hex_conversion(test_frame_pt_h, (char **)&test_frame_pt_b, &test_frame_pt_len);\n\n    status = Crypto_TC_ProcessSecurity(test_frame_pt_b, &test_frame_pt_len, tc_sdls_processed_frame);\n\n    ASSERT_EQ(CRYPTO_LIB_ERR_TC_FRAME_LENGTH_UNDERFLOW, status);\n    free(test_frame_pt_b);\n    free(tc_sdls_processed_frame);\n    Crypto_Shutdown();\n}\n\nUTEST_MAIN();", "target": 0}
{"idx": 98, "func": "int LibRaw::phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, sum;\n#if 0\n  int val[4], dev[4], max;\n#endif\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {\n      {-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n      {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n  std::vector<unsigned> badCols;\n\n  if (!meta_length)\n    return 0;\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n  try\n  {\n    while (entries--)\n    {\n      checkCancel();\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n#if 1\n\t  if (ifp->eof())\n\t  {\n\t\t  // skip bad or unknown tag\n\t\t  fseek(ifp, save, SEEK_SET);\n\t\t  continue;\n\t  }\n#endif\n      if (tag == 0x0400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n#if 0\n            // Original code by Dave Coffin - it works better by\n            // not employing special logic for G1 channel below.\n            // Alternatively this column remap (including G1 channel\n            // logic) should be called prior to black subtraction\n            // unlike other corrections\n            for (row = 0; row < raw_height; row++)\n            {\n              if (FC(row - top_margin, col - left_margin)==1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = p1raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += p1raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) =\n                  0.5 + sum * 0.0732233 +\n                  (p1raw(row, col - 2) + p1raw(row, col + 2)) * 0.3535534;\n              }\n            }\n#else\n            // accumulae bad columns to be sorted later\n            badCols.push_back(col);\n#endif\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            unsigned count = 0;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += p1rawc(row + dir[i][0], col + dir[i][1], count);\n            if (count)\n              RAW(row, col) = (sum + (count >> 1)) / count;\n          }\n        }\n      }\n      else if (tag == 0x0419)\n      { /* Polynomial curve - output calibraion */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x041a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x0401)\n      { /* All-color flat fields - luma calibration*/\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x0416 || tag == 0x0410)\n      {\n        // 0x410 - luma calibration\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x040b)\n      { /* Red+blue flat field - croma calibration */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x0412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x041f && !qlin_applied && ph1.split_col > 0 && ph1.split_col < raw_width\n\t\t&& ph1.split_row > 0 && ph1.split_row < raw_height)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n\t\tbool baddiv = false;\n        for (qr = 0; qr < 2; qr++)\n\t\t\tfor (qc = 0; qc < 2; qc++)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\t\tlc[qr][qc][i] = get4();\n\t\t\t\tif (lc[qr][qc][15] == 0)\n\t\t\t\t\tbaddiv = true;\n\t\t\t}\n\t\tif(baddiv)\n\t\t\tcontinue;\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x041e && !qmult_applied)\n      { /* Quadrant multipliers - output calibraion */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= (unsigned)ph1.split_row][col >= (unsigned)ph1.split_col] *\n                RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x0431 && !qmult_applied && ph1.split_col > 0 && ph1.split_col < raw_width \n\t\t&& ph1.split_row > 0 && ph1.split_row < raw_height)\n      { /* Quadrant combined - four tile gain calibration */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (!badCols.empty())\n    {\n      qsort(badCols.data(), badCols.size(), sizeof(unsigned), unsigned_cmp);\n      bool prevIsolated = true;\n      for (i = 0; i < (int)badCols.size(); ++i)\n      {\n        bool nextIsolated = i == ((int)(badCols.size()-1)) || badCols[i+1]>badCols[i]+4;\n        for (row = 0; row < raw_height; ++row)\n          if (prevIsolated && nextIsolated)\n            phase_one_fix_pixel_grad(row,badCols[i]);\n          else\n            phase_one_fix_col_pixel_avg(row,badCols[i]);\n        prevIsolated = nextIsolated;\n      }\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n\t  unsigned w0 = head[1] * head[3], w1 = head[2] * head[4];\n\t  if (w0 > 10240000 || w1 > 10240000)\n\t\t  throw LIBRAW_EXCEPTION_ALLOC;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n        checkCancel();\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n\t\t\tif (j == 0 || j == head[1] || k < 1 || k >= w0+w1)\n\t\t\t\tfrac = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint xdiv = (xval[0][k] - xval[0][k - 1]);\n\t\t\t\tfrac = xdiv ? (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]) : 0;\n\t\t\t}\n\t\t\tif (k < w0 + w1)\n\t\t\t\tmult[i - cip] = yval[0][k > 0 ? k - 1 : 0] * frac + yval[0][k] * (1 - frac);\n\t\t\telse\n\t\t\t\tmult[i - cip] = 0;\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n  return 0;\n}", "target": 1}
{"idx": 99, "func": "int LibRaw::phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, sum;\n#if 0\n  int val[4], dev[4], max;\n#endif\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {\n      {-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n      {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n  std::vector<unsigned> badCols;\n\n  if (!meta_length)\n    return 0;\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n  try\n  {\n    while (entries--)\n    {\n      checkCancel();\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n#if 1\n\t  if (ifp->eof())\n\t  {\n\t\t  // skip bad or unknown tag\n\t\t  fseek(ifp, save, SEEK_SET);\n\t\t  continue;\n\t  }\n#endif\n      if (tag == 0x0400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n#if 0\n            // Original code by Dave Coffin - it works better by\n            // not employing special logic for G1 channel below.\n            // Alternatively this column remap (including G1 channel\n            // logic) should be called prior to black subtraction\n            // unlike other corrections\n            for (row = 0; row < raw_height; row++)\n            {\n              if (FC(row - top_margin, col - left_margin)==1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = p1raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += p1raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) =\n                  0.5 + sum * 0.0732233 +\n                  (p1raw(row, col - 2) + p1raw(row, col + 2)) * 0.3535534;\n              }\n            }\n#else\n            // accumulae bad columns to be sorted later\n            badCols.push_back(col);\n#endif\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            unsigned count = 0;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += p1rawc(row + dir[i][0], col + dir[i][1], count);\n            if (count)\n              RAW(row, col) = (sum + (count >> 1)) / count;\n          }\n        }\n      }\n      else if (tag == 0x0419)\n      { /* Polynomial curve - output calibraion */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x041a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x0401)\n      { /* All-color flat fields - luma calibration*/\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x0416 || tag == 0x0410)\n      {\n        // 0x410 - luma calibration\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x040b)\n      { /* Red+blue flat field - croma calibration */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x0412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x041f && !qlin_applied && ph1.split_col > 0 && ph1.split_col < raw_width\n\t\t&& ph1.split_row > 0 && ph1.split_row < raw_height)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n\t\tbool baddiv = false;\n        for (qr = 0; qr < 2; qr++)\n\t\t\tfor (qc = 0; qc < 2; qc++)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\t\tlc[qr][qc][i] = get4();\n\t\t\t\tif (lc[qr][qc][15] == 0)\n\t\t\t\t\tbaddiv = true;\n\t\t\t}\n\t\tif(baddiv)\n\t\t\tcontinue;\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x041e && !qmult_applied)\n      { /* Quadrant multipliers - output calibraion */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= (unsigned)ph1.split_row][col >= (unsigned)ph1.split_col] *\n                RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x0431 && !qmult_applied && ph1.split_col > 0 && ph1.split_col < raw_width \n\t\t&& ph1.split_row > 0 && ph1.split_row < raw_height)\n      { /* Quadrant combined - four tile gain calibration */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (!badCols.empty())\n    {\n      qsort(badCols.data(), badCols.size(), sizeof(unsigned), unsigned_cmp);\n      bool prevIsolated = true;\n      for (i = 0; i < (int)badCols.size(); ++i)\n      {\n        bool nextIsolated = i == ((int)(badCols.size()-1)) || badCols[i+1]>badCols[i]+4;\n        for (row = 0; row < raw_height; ++row)\n          if (prevIsolated && nextIsolated)\n            phase_one_fix_pixel_grad(row,badCols[i]);\n          else\n            phase_one_fix_col_pixel_avg(row,badCols[i]);\n        prevIsolated = nextIsolated;\n      }\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n\t  unsigned w0 = head[1] * head[3], w1 = head[2] * head[4];\n\t  if (w0 > 10240000 || w1 > 10240000)\n\t\t  throw LIBRAW_EXCEPTION_ALLOC;\n\t  if (w0 < 1 || w1 < 1)\n\t\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n        checkCancel();\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n\t\t\tif (j == 0 || j == head[1] || k < 1 || k >= w0+w1)\n\t\t\t\tfrac = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint xdiv = (xval[0][k] - xval[0][k - 1]);\n\t\t\t\tfrac = xdiv ? (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]) : 0;\n\t\t\t}\n\t\t\tif (k < w0 + w1)\n\t\t\t\tmult[i - cip] = yval[0][k > 0 ? k - 1 : 0] * frac + yval[0][k] * (1 - frac);\n\t\t\telse\n\t\t\t\tmult[i - cip] = 0;\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n  return 0;\n}", "target": 0}
{"idx": 100, "func": "void SceneCombiner::AddNodeHashes(aiNode *node, std::set<unsigned int> &hashes) {\n    // Add node name to hashing set if it is non-empty - empty nodes are allowed\n    // and they can't have any anims assigned so its absolutely safe to duplicate them.\n    if (node->mName.length) {\n        hashes.insert(SuperFastHash(node->mName.data, static_cast<uint32_t>(node->mName.length)));\n    }\n\n    // Process all children recursively\n    for (unsigned int i = 0; i < node->mNumChildren; ++i) {\n        AddNodeHashes(node->mChildren[i], hashes);\n    }\n}\n\n// ------------------------------------------------------------------------------------------------\n// Add a name prefix to all nodes in a hierarchy", "target": 1}
{"idx": 101, "func": "void SceneCombiner::AddNodeHashes(aiNode *node, std::set<unsigned int> &hashes) {\n    if (node == nullptr) {\n        ASSIMP_LOG_VERBOSE_ERROR(\"Pointer to aiNode is nullptr.\");\n        return;\n    }\n  \n    // Add node name to hashing set if it is non-empty - empty nodes are allowed\n    // and they can't have any anims assigned so its absolutely safe to duplicate them.\n    if (node->mName.length) {\n        hashes.insert(SuperFastHash(node->mName.data, static_cast<uint32_t>(node->mName.length)));\n    }\n\n    // Process all children recursively\n    for (unsigned int i = 0; i < node->mNumChildren; ++i) {\n        AddNodeHashes(node->mChildren[i], hashes);\n    }\n}\n\n// ------------------------------------------------------------------------------------------------\n// Add a name prefix to all nodes in a hierarchy", "target": 0}
{"idx": 102, "func": "int Job::Execute()\n{\n\tint rc = 0;\n\tbool succeeded = false;\n\tDBresultPtr steps = m_threadConn->Execute(\n\t\t\"SELECT * \"\n\t\t\"  FROM pgagent.pga_jobstep \"\n\t\t\" WHERE jstenabled \"\n\t\t\"   AND jstjobid=\" + m_jobid +\n\t\t\" ORDER BY jstname, jstid\");\n\n\tif (!steps)\n\t{\n\t\tLogMessage(\"No steps found for jobid \" + m_jobid, LOG_WARNING);\n\t\tm_status = \"i\";\n\t\treturn -1;\n\t}\n\n\twhile (steps->HasData())\n\t{\n\t\tDBconn      *stepConn = nullptr;\n\t\tstd::string  jslid, stepid, jpecode, output;\n\n\t\tstepid = steps->GetString(\"jstid\");\n\n\t\tDBresultPtr id = m_threadConn->Execute(\n\t\t\t\"SELECT nextval('pgagent.pga_jobsteplog_jslid_seq') AS id\"\n\t\t);\n\n\t\tif (id)\n\t\t{\n\t\t\tjslid = id->GetString(\"id\");\n\t\t\tDBresultPtr res = m_threadConn->Execute(\n\t\t\t\t\"INSERT INTO pgagent.pga_jobsteplog(jslid, jsljlgid, jsljstid, jslstatus) \"\n\t\t\t\t\"SELECT \" + jslid + \", \" + m_logid + \", \" + stepid + \", 'r'\" +\n\t\t\t\t\"  FROM pgagent.pga_jobstep WHERE jstid=\" + stepid);\n\n\t\t\tif (res)\n\t\t\t{\n\t\t\t\trc = res->RowsAffected();\n\t\t\t\tLogMessage(\"Number of rows affected for jobid \" + m_jobid, LOG_DEBUG);\n\t\t\t}\n\t\t\telse\n\t\t\t\trc = -1;\n\t\t}\n\n\t\tif (rc != 1)\n\t\t{\n\t\t\tLogMessage(\"Value of rc is \" + std::to_string(rc) + \" for job \" + m_jobid, LOG_WARNING);\n\t\t\tm_status = \"i\";\n\t\t\treturn -1;\n\t\t}\n\n\t\tswitch ((int)steps->GetString(\"jstkind\")[0])\n\t\t{\n\t\t\tcase 's':\n\t\t\t{\n\t\t\t\tstd::string jstdbname = steps->GetString(\"jstdbname\");\n\t\t\t\tstd::string jstconnstr = steps->GetString(\"jstconnstr\");\n\n\t\t\t\tstepConn = DBconn::Get(jstconnstr, jstdbname);\n\n\t\t\t\tif (stepConn)\n\t\t\t\t{\n\t\t\t\t\tLogMessage(\n\t\t\t\t\t\t\"Executing SQL step \" + stepid + \"(part of job \" + m_jobid + \")\",\n\t\t\t\t\t\t LOG_DEBUG\n\t\t\t\t\t);\n\t\t\t\t\trc = stepConn->ExecuteVoid(steps->GetString(\"jstcode\"));\n\t\t\t\t\tsucceeded = stepConn->LastCommandOk();\n\t\t\t\t\toutput = stepConn->GetLastError();\n\t\t\t\t\tstepConn->Return();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\toutput = \"Couldn't get a connection to the database!\";\n\t\t\t\t\tsucceeded = false;\n\t\t\t\t}\n\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'b':\n\t\t\t{\n\t\t\t\t// Batch jobs are more complex thank SQL, for obvious reasons...\n\t\t\t\tLogMessage(\n\t\t\t\t\t\"Executing batch step\" + stepid + \"(part of job \" + m_jobid + \")\",\n          LOG_DEBUG\n\t\t\t\t);\n\n\t\t\t\t// Get a temporary filename, then reuse it to create an empty directory.\n\t\t\t\tstd::string sDirectory = getTemporaryDirectoryPath();\n\t\t\t\tstd::string sFilesName = std::string(\"\");\n\t\t\t\tstd::string prefix = std::string(\"pga_\");\n\n\t\t\t\t// Generate random string of 6 characters long to make unique dir name\n\t\t\t\tstd::string result = generateRandomString(7);\n\t\t\t\tsFilesName = prefix + m_jobid + std::string(\"_\") + stepid + std::string(\"_\") + result;\n#if BOOST_OS_WINDOWS\n\t\t\t\tstd::string sModel = (boost::format(\"%s\\\\%s\") % sDirectory % sFilesName).str();\n#else\n\t\t\t\tstd::string sModel = (boost::format(\"%s/%s\") % sDirectory % sFilesName).str();\n#endif\n\t\t\t\tstd::string dirname = sModel;\n\n\t\t\t\tif (dirname == \"\")\n\t\t\t\t{\n\t\t\t\t\toutput = \"Couldn't get a temporary filename!\";\n\t\t\t\t\tLogMessage(output, LOG_WARNING);\n\t\t\t\t\trc = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!boost::filesystem::create_directory(boost::filesystem::path(dirname)))\n\t\t\t\t{\n\t\t\t\t\tLogMessage(\n\t\t\t\t\t\t\"Couldn't create temporary directory: \" + dirname, LOG_WARNING\n\t\t\t\t\t);\n\t\t\t\t\trc = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n#if BOOST_OS_WINDOWS\n\t\t\t\tstd::string filename = dirname + \"\\\\\" + m_jobid + \"_\" + stepid + \".bat\";\n\t\t\t\tstd::string errorFile = dirname + \"\\\\\" + m_jobid + \"_\" + stepid + \"_error.txt\";\n#else\n\t\t\t\tstd::string filename = dirname + \"/\" + m_jobid + \"_\" + stepid + \".scr\";\n\t\t\t\tstd::string errorFile = dirname + \"/\" + m_jobid + \"_\" + stepid + \"_error.txt\";\n#endif\n\n\t\t\t\tstd::string code = steps->GetString(\"jstcode\");\n\n\t\t\t\t// Cleanup the code. If we're on Windows, we need to make all line ends \\r\\n,\n\t\t\t\t// If we're on Unix, we need \\n\n\t\t\t\tboost::replace_all(code, \"\\r\\n\", \"\\n\");\n#if BOOST_OS_WINDOWS\n\t\t\t\tboost::replace_all(code, \"\\n\", \"\\r\\n\");\n#endif\n\t\t\t\tstd::ofstream out_file;\n\n\t\t\t\tout_file.open((const char *)filename.c_str(), std::ios::out);\n\n\t\t\t\tif (out_file.fail())\n\t\t\t\t{\n\t\t\t\t\tLogMessage(\n\t\t\t\t\t\t\"Couldn't open temporary script file: \" + filename,\n\t\t\t\t\t\tLOG_WARNING\n\t\t\t\t\t);\n\n\t\t\t\t\tif (boost::filesystem::exists(dirname))\n\t\t\t\t\t\tboost::filesystem::remove_all(dirname);\n\n\t\t\t\t\trc = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tout_file << code;\n\t\t\t\t\tout_file.close();\n\n#if !BOOST_OS_WINDOWS\n\t\t\t\t\t// change file permission to 700 for executable in linux\n\t\t\t\t\tint ret = chmod((const char *)filename.c_str(), S_IRWXU);\n\n\t\t\t\t\tif (ret != 0)\n\t\t\t\t\t\tLogMessage(\n\t\t\t\t\t\t\t\"Error setting executable permission to file: \" + filename,\n\t\t\t\t\t\t\tLOG_DEBUG\n\t\t\t\t\t\t);\n#endif\n\t\t\t\t}\n\n\t\t\t\tLogMessage(\"Executing script file: \" + filename, LOG_DEBUG);\n\n\t\t\t\t// freopen function is used to redirect output of stream (stderr in our case)\n\t\t\t\t// into the specified file.\n\t\t\t\tFILE *fpError = freopen((const char *)errorFile.c_str(), \"w\", stderr);\n\n\t\t\t\t// Execute the file and capture the output\n#if BOOST_OS_WINDOWS\n\t\t\t\t// The Windows way\n\t\t\t\tHANDLE h_script, h_process;\n\t\t\t\tDWORD  dwRead;\n\t\t\t\tchar   chBuf[4098];\n\n\t\t\t\th_script = win32_popen_r(s2ws(filename).c_str(), h_process);\n\n\t\t\t\tif (!h_script)\n\t\t\t\t{\n\t\t\t\t\tLogMessage((boost::format(\n\t\t\t\t\t\t\"Couldn't execute script: %s, GetLastError() returned %d, errno = %d\"\n\t\t\t\t\t) % filename.c_str() % GetLastError() % errno).str(), LOG_WARNING);\n\t\t\t\t\tCloseHandle(h_process);\n\t\t\t\t\trc = -1;\n\n\t\t\t\t\tif (fpError)\n\t\t\t\t\t\tfclose(fpError);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\t// Read output from the child process\n\t\t\t\tif (h_script)\n\t\t\t\t{\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!ReadFile(h_script, chBuf, 4096, &dwRead, NULL) || dwRead == 0)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tchBuf[dwRead] = 0;\n\t\t\t\t\t\toutput += (const char *)chBuf;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tGetExitCodeProcess(h_process, (LPDWORD)&rc);\n\t\t\t\tCloseHandle(h_process);\n\t\t\t\tCloseHandle(h_script);\n\n#else\n\t\t\t\t// The *nix way.\n\t\t\t\tFILE *fp_script = nullptr;\n\t\t\t\tchar  buf[4098];\n\n\t\t\t\tfp_script = popen((const char *)filename.c_str(), \"r\");\n\n\t\t\t\tif (!fp_script)\n\t\t\t\t{\n\t\t\t\t\tLogMessage((boost::format(\n\t\t\t\t\t\t\"Couldn't execute script: %s, errno = %d\"\n\t\t\t\t\t) % filename.c_str() % errno).str(), LOG_WARNING);\n\t\t\t\t\trc = -1;\n\n\t\t\t\t\tif(fpError)\n\t\t\t\t\t\tfclose(fpError);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\twhile(!feof(fp_script))\n\t\t\t\t{\n\t\t\t\t\tif (fgets(buf, 4096, fp_script) != NULL)\n\t\t\t\t\t\toutput += (const char *)buf;\n\t\t\t\t}\n\n\t\t\t\trc = pclose(fp_script);\n\n\t\t\t\tif (WIFEXITED(rc))\n\t\t\t\t\trc = WEXITSTATUS(rc);\n\t\t\t\telse\n\t\t\t\t\trc = -1;\n\n#endif\n\n\t\t\t\t// set success status for batch runs, be pessimistic by default\n\t\t\t\tLogMessage(\n\t\t\t\t\t(boost::format(\"Script return code: %d\") % rc).str(),\n\t\t\t\t\tLOG_DEBUG\n\t\t\t\t);\n\n\t\t\t\tsucceeded = ((rc == 0) ? true : false);\n\t\t\t\t// If output is empty then either script did not return any output\n\t\t\t\t// or script threw some error into stderr.\n\t\t\t\t// Check script threw some error into stderr\n\t\t\t\tif (fpError)\n\t\t\t\t{\n\t\t\t\t\tfclose(fpError);\n\t\t\t\t\tFILE* fpErr = fopen((const char *)errorFile.c_str(), \"r\");\n\n\t\t\t\t\tif (fpErr)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar buffer[4098];\n\t\t\t\t\t\tstd::string errorMsg = \"\";\n\n\t\t\t\t\t\twhile (!feof(fpErr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (fgets(buffer, 4096, fpErr) != NULL)\n\t\t\t\t\t\t\t\terrorMsg += buffer;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (errorMsg != \"\") {\n\t\t\t\t\t\t\tstd::string errmsg = \"Script Error: \\n\" + errorMsg + \"\\n\";\n\t\t\t\t\t\t\tLogMessage(\"Script Error: \\n\" + errorMsg + \"\\n\", LOG_WARNING);\n\t\t\t\t\t\t\toutput += \"\\n\" + errmsg;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfclose(fpErr);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Delete the file/directory. If we fail, don't overwrite the script\n\t\t\t\t// output in the log, just throw warnings.\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tboost::filesystem::path dir_path(dirname);\n\n\t\t\t\t\tif (boost::filesystem::exists(dir_path))\n\t\t\t\t\t\tboost::filesystem::remove_all(dir_path);\n\t\t\t\t}\n\t\t\t\tcatch (boost::filesystem::filesystem_error const & e)\n\t\t\t\t{\n\t\t\t\t\t//display error message\n\t\t\t\t\tLogMessage((const char *)e.what(), LOG_WARNING);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\toutput = \"Invalid step type!\";\n\t\t\t\tLogMessage(\"Invalid step type!\", LOG_WARNING);\n\t\t\t\tm_status = \"i\";\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tstd::string stepstatus;\n\t\tif (succeeded)\n\t\t\tstepstatus = \"s\";\n\t\telse\n\t\t\tstepstatus = steps->GetString(\"jstonerror\");\n\n\t\trc = m_threadConn->ExecuteVoid(\n\t\t\t\"UPDATE pgagent.pga_jobsteplog \"\n\t\t\t\"   SET jslduration = now() - jslstart, \"\n\t\t\t\"       jslresult = \" + NumToStr(rc) + \", jslstatus = '\" + stepstatus + \"', \" +\n\t\t\t\"       jsloutput = \" + m_threadConn->qtDbString(output) + \" \" +\n\t\t\t\" WHERE jslid=\" + jslid);\n\t\tif (rc != 1 || stepstatus == \"f\")\n\t\t{\n\t\t\tm_status = \"f\";\n\t\t\treturn -1;\n\t\t}\n\t\tsteps->MoveNext();\n\t}\n\n\tm_status = \"s\";\n\treturn 0;\n}", "target": 1}
{"idx": 103, "func": "int Job::Execute()\n{\n\tint rc = 0;\n\tbool succeeded = false;\n\tDBresultPtr steps = m_threadConn->Execute(\n\t\t\"SELECT * \"\n\t\t\"  FROM pgagent.pga_jobstep \"\n\t\t\" WHERE jstenabled \"\n\t\t\"   AND jstjobid=\" + m_jobid +\n\t\t\" ORDER BY jstname, jstid\");\n\n\tif (!steps)\n\t{\n\t\tLogMessage(\"No steps found for jobid \" + m_jobid, LOG_WARNING);\n\t\tm_status = \"i\";\n\t\treturn -1;\n\t}\n\n\twhile (steps->HasData())\n\t{\n\t\tDBconn      *stepConn = nullptr;\n\t\tstd::string  jslid, stepid, jpecode, output;\n\n\t\tstepid = steps->GetString(\"jstid\");\n\n\t\tDBresultPtr id = m_threadConn->Execute(\n\t\t\t\"SELECT nextval('pgagent.pga_jobsteplog_jslid_seq') AS id\"\n\t\t);\n\n\t\tif (id)\n\t\t{\n\t\t\tjslid = id->GetString(\"id\");\n\t\t\tDBresultPtr res = m_threadConn->Execute(\n\t\t\t\t\"INSERT INTO pgagent.pga_jobsteplog(jslid, jsljlgid, jsljstid, jslstatus) \"\n\t\t\t\t\"SELECT \" + jslid + \", \" + m_logid + \", \" + stepid + \", 'r'\" +\n\t\t\t\t\"  FROM pgagent.pga_jobstep WHERE jstid=\" + stepid);\n\n\t\t\tif (res)\n\t\t\t{\n\t\t\t\trc = res->RowsAffected();\n\t\t\t\tLogMessage(\"Number of rows affected for jobid \" + m_jobid, LOG_DEBUG);\n\t\t\t}\n\t\t\telse\n\t\t\t\trc = -1;\n\t\t}\n\n\t\tif (rc != 1)\n\t\t{\n\t\t\tLogMessage(\"Value of rc is \" + std::to_string(rc) + \" for job \" + m_jobid, LOG_WARNING);\n\t\t\tm_status = \"i\";\n\t\t\treturn -1;\n\t\t}\n\n\t\tswitch ((int)steps->GetString(\"jstkind\")[0])\n\t\t{\n\t\t\tcase 's':\n\t\t\t{\n\t\t\t\tstd::string jstdbname = steps->GetString(\"jstdbname\");\n\t\t\t\tstd::string jstconnstr = steps->GetString(\"jstconnstr\");\n\n\t\t\t\tstepConn = DBconn::Get(jstconnstr, jstdbname);\n\n\t\t\t\tif (stepConn)\n\t\t\t\t{\n\t\t\t\t\tLogMessage(\n\t\t\t\t\t\t\"Executing SQL step \" + stepid + \"(part of job \" + m_jobid + \")\",\n\t\t\t\t\t\t LOG_DEBUG\n\t\t\t\t\t);\n\t\t\t\t\trc = stepConn->ExecuteVoid(steps->GetString(\"jstcode\"));\n\t\t\t\t\tsucceeded = stepConn->LastCommandOk();\n\t\t\t\t\toutput = stepConn->GetLastError();\n\t\t\t\t\tstepConn->Return();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\toutput = \"Couldn't get a connection to the database!\";\n\t\t\t\t\tsucceeded = false;\n\t\t\t\t}\n\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'b':\n\t\t\t{\n\t\t\t\t// Batch jobs are more complex thank SQL, for obvious reasons...\n\t\t\t\tLogMessage(\n\t\t\t\t\t\"Executing batch step\" + stepid + \"(part of job \" + m_jobid + \")\",\n          LOG_DEBUG\n\t\t\t\t);\n\n\t\t\t\tnamespace fs = boost::filesystem;\n\n\t\t\t\t// Generate unique temporary directory\n\t\t\t\tstd::string prefix = (\n\t\t\t\t\tboost::format(\"pga_%s_%s_\") % m_jobid % stepid\n\t\t\t\t).str();\n\n\t\t\t\tfs::path jobDir;\n\t\t\t\tfs::path filepath((\n\t\t\t\t\tboost::format(\"%s_%s.%s\") %\n\t\t\t\t\tm_jobid % stepid %\n#if BOOST_OS_WINDOWS\n\t\t\t\t\t\".bat\"\n#else\n\t\t\t\t\t\".scr\"\n#endif\n\t\t\t\t).str());\n\t\t\t\tfs::path errorFilePath(\n\t\t\t\t\t(boost::format(\"%s_%s_error.txt\") % m_jobid % stepid).str()\n\t\t\t\t);\n\n\t\t\t\tif (!createUniqueTemporaryDirectory(prefix, jobDir))\n\t\t\t\t{\n\t\t\t\t\toutput = \"Couldn't get a temporary filename!\";\n\t\t\t\t\tLogMessage(output, LOG_WARNING);\n\t\t\t\t\trc = -1;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfilepath = jobDir / filepath;\n\t\t\t\terrorFilePath = jobDir / errorFilePath;\n\n\t\t\t\tstd::string filename = filepath.string();\n\t\t\t\tstd::string errorFile = errorFilePath.string();\n\n\t\t\t\tstd::string code = steps->GetString(\"jstcode\");\n\n\t\t\t\t// Cleanup the code. If we're on Windows, we need to make all line ends \\r\\n,\n\t\t\t\t// If we're on Unix, we need \\n\n\t\t\t\tboost::replace_all(code, \"\\r\\n\", \"\\n\");\n#if BOOST_OS_WINDOWS\n\t\t\t\tboost::replace_all(code, \"\\n\", \"\\r\\n\");\n#endif\n\t\t\t\tstd::ofstream out_file;\n\n\t\t\t\tout_file.open((const char *)filename.c_str(), std::ios::out);\n\n\t\t\t\tif (out_file.fail())\n\t\t\t\t{\n\t\t\t\t\tLogMessage(\n\t\t\t\t\t\t\"Couldn't open temporary script file: \" + filename,\n\t\t\t\t\t\tLOG_WARNING\n\t\t\t\t\t);\n\n\t\t\t\t\tif (boost::filesystem::exists(jobDir))\n\t\t\t\t\t\tboost::filesystem::remove_all(jobDir);\n\n\t\t\t\t\trc = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tout_file << code;\n\t\t\t\t\tout_file.close();\n\n#if !BOOST_OS_WINDOWS\n\t\t\t\t\t// Change file permission to 700 for executable in linux\n\t\t\t\t\ttry {\n\t\t\t\t\t\tboost::filesystem::permissions(\n\t\t\t\t\t\t\tfilepath, boost::filesystem::owner_all\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch (const fs::filesystem_error &ex) {\n\t\t\t\t\t\tLogMessage(\n\t\t\t\t\t\t\t\"Error setting executable permission to file: \" +\n\t\t\t\t\t\t\tfilename, LOG_DEBUG\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tLogMessage(\"Executing script file: \" + filename, LOG_DEBUG);\n\n\t\t\t\t// freopen function is used to redirect output of stream (stderr in our case)\n\t\t\t\t// into the specified file.\n\t\t\t\tFILE *fpError = freopen((const char *)errorFile.c_str(), \"w\", stderr);\n\n\t\t\t\t// Execute the file and capture the output\n#if BOOST_OS_WINDOWS\n\t\t\t\t// The Windows way\n\t\t\t\tHANDLE h_script, h_process;\n\t\t\t\tDWORD  dwRead;\n\t\t\t\tchar   chBuf[4098];\n\n\t\t\t\th_script = win32_popen_r(s2ws(filename).c_str(), h_process);\n\n\t\t\t\tif (!h_script)\n\t\t\t\t{\n\t\t\t\t\tLogMessage((boost::format(\n\t\t\t\t\t\t\"Couldn't execute script: %s, GetLastError() returned %d, errno = %d\"\n\t\t\t\t\t) % filename.c_str() % GetLastError() % errno).str(), LOG_WARNING);\n\t\t\t\t\tCloseHandle(h_process);\n\t\t\t\t\trc = -1;\n\n\t\t\t\t\tif (fpError)\n\t\t\t\t\t\tfclose(fpError);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\t// Read output from the child process\n\t\t\t\tif (h_script)\n\t\t\t\t{\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!ReadFile(h_script, chBuf, 4096, &dwRead, NULL) || dwRead == 0)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tchBuf[dwRead] = 0;\n\t\t\t\t\t\toutput += (const char *)chBuf;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tGetExitCodeProcess(h_process, (LPDWORD)&rc);\n\t\t\t\tCloseHandle(h_process);\n\t\t\t\tCloseHandle(h_script);\n\n#else\n\t\t\t\t// The *nix way.\n\t\t\t\tFILE *fp_script = nullptr;\n\t\t\t\tchar  buf[4098];\n\n\t\t\t\tfp_script = popen((const char *)filename.c_str(), \"r\");\n\n\t\t\t\tif (!fp_script)\n\t\t\t\t{\n\t\t\t\t\tLogMessage((boost::format(\n\t\t\t\t\t\t\"Couldn't execute script: %s, errno = %d\"\n\t\t\t\t\t) % filename.c_str() % errno).str(), LOG_WARNING);\n\t\t\t\t\trc = -1;\n\n\t\t\t\t\tif(fpError)\n\t\t\t\t\t\tfclose(fpError);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\twhile(!feof(fp_script))\n\t\t\t\t{\n\t\t\t\t\tif (fgets(buf, 4096, fp_script) != NULL)\n\t\t\t\t\t\toutput += (const char *)buf;\n\t\t\t\t}\n\n\t\t\t\trc = pclose(fp_script);\n\n\t\t\t\tif (WIFEXITED(rc))\n\t\t\t\t\trc = WEXITSTATUS(rc);\n\t\t\t\telse\n\t\t\t\t\trc = -1;\n\n#endif\n\n\t\t\t\t// set success status for batch runs, be pessimistic by default\n\t\t\t\tLogMessage(\n\t\t\t\t\t(boost::format(\"Script return code: %d\") % rc).str(),\n\t\t\t\t\tLOG_DEBUG\n\t\t\t\t);\n\n\t\t\t\tsucceeded = ((rc == 0) ? true : false);\n\t\t\t\t// If output is empty then either script did not return any output\n\t\t\t\t// or script threw some error into stderr.\n\t\t\t\t// Check script threw some error into stderr\n\t\t\t\tif (fpError)\n\t\t\t\t{\n\t\t\t\t\tfclose(fpError);\n\t\t\t\t\tFILE* fpErr = fopen((const char *)errorFile.c_str(), \"r\");\n\n\t\t\t\t\tif (fpErr)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar buffer[4098];\n\t\t\t\t\t\tstd::string errorMsg = \"\";\n\n\t\t\t\t\t\twhile (!feof(fpErr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (fgets(buffer, 4096, fpErr) != NULL)\n\t\t\t\t\t\t\t\terrorMsg += buffer;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (errorMsg != \"\") {\n\t\t\t\t\t\t\tstd::string errmsg = \"Script Error: \\n\" + errorMsg + \"\\n\";\n\t\t\t\t\t\t\tLogMessage(\"Script Error: \\n\" + errorMsg + \"\\n\", LOG_WARNING);\n\t\t\t\t\t\t\toutput += \"\\n\" + errmsg;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfclose(fpErr);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Delete the file/directory. If we fail, don't overwrite the script\n\t\t\t\t// output in the log, just throw warnings.\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tif (boost::filesystem::exists(jobDir))\n\t\t\t\t\t\tboost::filesystem::remove_all(jobDir);\n\t\t\t\t}\n\t\t\t\tcatch (boost::filesystem::filesystem_error const & e)\n\t\t\t\t{\n\t\t\t\t\t//display error message\n\t\t\t\t\tLogMessage((const char *)e.what(), LOG_WARNING);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\toutput = \"Invalid step type!\";\n\t\t\t\tLogMessage(\"Invalid step type!\", LOG_WARNING);\n\t\t\t\tm_status = \"i\";\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tstd::string stepstatus;\n\t\tif (succeeded)\n\t\t\tstepstatus = \"s\";\n\t\telse\n\t\t\tstepstatus = steps->GetString(\"jstonerror\");\n\n\t\trc = m_threadConn->ExecuteVoid(\n\t\t\t\"UPDATE pgagent.pga_jobsteplog \"\n\t\t\t\"   SET jslduration = now() - jslstart, \"\n\t\t\t\"       jslresult = \" + NumToStr(rc) + \", jslstatus = '\" + stepstatus + \"', \" +\n\t\t\t\"       jsloutput = \" + m_threadConn->qtDbString(output) + \" \" +\n\t\t\t\" WHERE jslid=\" + jslid);\n\t\tif (rc != 1 || stepstatus == \"f\")\n\t\t{\n\t\t\tm_status = \"f\";\n\t\t\treturn -1;\n\t\t}\n\t\tsteps->MoveNext();\n\t}\n\n\tm_status = \"s\";\n\treturn 0;\n}", "target": 0}
{"idx": 104, "func": "int mosquitto_main_loop(struct mosquitto__listener_sock *listensock, int listensock_count)\n{\n#ifdef WITH_SYS_TREE\n\ttime_t start_time = mosquitto_time();\n#endif\n#ifdef WITH_PERSISTENCE\n\ttime_t last_backup = mosquitto_time();\n#endif\n#ifdef WITH_WEBSOCKETS\n\tint i;\n#endif\n\tint rc;\n\n\n#if defined(WITH_WEBSOCKETS) && LWS_LIBRARY_VERSION_NUMBER == 3002000\n\tmemset(&sul, 0, sizeof(struct lws_sorted_usec_list));\n#endif\n\n\tdb.now_s = mosquitto_time();\n\tdb.now_real_s = time(NULL);\n\n#ifdef WITH_BRIDGE\n\trc = bridge__register_local_connections();\n\tif(rc) return rc;\n#endif\n\n\twhile(run){\n\t\tqueue_plugin_msgs();\n\t\tcontext__free_disused();\n#ifdef WITH_SYS_TREE\n\t\tif(db.config->sys_interval > 0){\n\t\t\tsys_tree__update(db.config->sys_interval, start_time);\n\t\t}\n#endif\n\n\t\tkeepalive__check();\n\n#ifdef WITH_BRIDGE\n\t\tbridge_check();\n#endif\n\n\t\trc = mux__handle(listensock, listensock_count);\n\t\tif(rc) return rc;\n\n\t\tsession_expiry__check();\n\t\twill_delay__check();\n#ifdef WITH_PERSISTENCE\n\t\tif(db.config->persistence && db.config->autosave_interval){\n\t\t\tif(db.config->autosave_on_changes){\n\t\t\t\tif(db.persistence_changes >= db.config->autosave_interval){\n\t\t\t\t\tpersist__backup(false);\n\t\t\t\t\tdb.persistence_changes = 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(last_backup + db.config->autosave_interval < db.now_s){\n\t\t\t\t\tpersist__backup(false);\n\t\t\t\t\tlast_backup = db.now_s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef WITH_PERSISTENCE\n\t\tif(flag_db_backup){\n\t\t\tpersist__backup(false);\n\t\t\tflag_db_backup = false;\n\t\t}\n#endif\n\t\tif(flag_reload){\n\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Reloading config.\");\n\t\t\tconfig__read(db.config, true);\n\t\t\tlisteners__reload_all_certificates();\n\t\t\tmosquitto_security_cleanup(true);\n\t\t\tmosquitto_security_init(true);\n\t\t\tmosquitto_security_apply();\n\t\t\tlog__close(db.config);\n\t\t\tlog__init(db.config);\n\t\t\tflag_reload = false;\n\t\t}\n\t\tif(flag_tree_print){\n\t\t\tsub__tree_print(db.subs, 0);\n\t\t\tflag_tree_print = false;\n#ifdef WITH_XTREPORT\n\t\t\txtreport();\n#endif\n\t\t}\n#ifdef WITH_WEBSOCKETS\n\t\tfor(i=0; i<db.config->listener_count; i++){\n\t\t\t/* Extremely hacky, should be using the lws provided external poll\n\t\t\t * interface, but their interface has changed recently and ours\n\t\t\t * will soon, so for now websockets clients are second class\n\t\t\t * citizens. */\n\t\t\tif(db.config->listeners[i].ws_context){\n#if LWS_LIBRARY_VERSION_NUMBER > 3002000\n\t\t\t\tlws_service(db.config->listeners[i].ws_context, -1);\n#elif LWS_LIBRARY_VERSION_NUMBER == 3002000\n\t\t\t\tlws_sul_schedule(db.config->listeners[i].ws_context, 0, &sul, lws__sul_callback, 10);\n\t\t\t\tlws_service(db.config->listeners[i].ws_context, 0);\n#else\n\t\t\t\tlws_service(db.config->listeners[i].ws_context, 0);\n#endif\n\n\t\t\t}\n\t\t}\n#endif\n\t\tplugin__handle_tick();\n\t}\n\n\tmux__cleanup();\n\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"idx": 105, "func": "int mosquitto_main_loop(struct mosquitto__listener_sock *listensock, int listensock_count)\n{\n#ifdef WITH_SYS_TREE\n\ttime_t start_time = mosquitto_time();\n#endif\n#ifdef WITH_PERSISTENCE\n\ttime_t last_backup = mosquitto_time();\n#endif\n#ifdef WITH_WEBSOCKETS\n\tint i;\n#endif\n\tint rc;\n\n\n#if defined(WITH_WEBSOCKETS) && LWS_LIBRARY_VERSION_NUMBER == 3002000\n\tmemset(&sul, 0, sizeof(struct lws_sorted_usec_list));\n#endif\n\n\tdb.now_s = mosquitto_time();\n\tdb.now_real_s = time(NULL);\n\n#ifdef WITH_BRIDGE\n\trc = bridge__register_local_connections();\n\tif(rc) return rc;\n#endif\n\n\twhile(run){\n\t\tqueue_plugin_msgs();\n\t\tcontext__free_disused();\n#ifdef WITH_SYS_TREE\n\t\tif(db.config->sys_interval > 0){\n\t\t\tsys_tree__update(db.config->sys_interval, start_time);\n\t\t}\n#endif\n\n\t\tkeepalive__check();\n\n#ifdef WITH_BRIDGE\n\t\tbridge_check();\n#endif\n\n\t\trc = mux__handle(listensock, listensock_count);\n\t\tif(rc) return rc;\n\n\t\tsession_expiry__check();\n\t\twill_delay__check();\n#ifdef WITH_PERSISTENCE\n\t\tif(db.config->persistence && db.config->autosave_interval){\n\t\t\tif(db.config->autosave_on_changes){\n\t\t\t\tif(db.persistence_changes >= db.config->autosave_interval){\n\t\t\t\t\tpersist__backup(false);\n\t\t\t\t\tdb.persistence_changes = 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(last_backup + db.config->autosave_interval < db.now_s){\n\t\t\t\t\tpersist__backup(false);\n\t\t\t\t\tlast_backup = db.now_s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef WITH_PERSISTENCE\n\t\tif(flag_db_backup){\n\t\t\tpersist__backup(false);\n\t\t\tflag_db_backup = false;\n\t\t}\n#endif\n\t\tif(flag_reload){\n\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Reloading config.\");\n\t\t\tconfig__read(db.config, true);\n\t\t\tlisteners__reload_all_certificates();\n\t\t\tmosquitto_security_cleanup(true);\n\t\t\tmosquitto_security_init(true);\n\t\t\tmosquitto_security_apply();\n\t\t\tlog__close(db.config);\n\t\t\tlog__init(db.config);\n\t\t\tflag_reload = false;\n\t\t}\n\t\tif(flag_tree_print){\n\t\t\tsub__tree_print(db.normal_subs, 0);\n\t\t\tsub__tree_print(db.shared_subs, 0);\n\t\t\tflag_tree_print = false;\n#ifdef WITH_XTREPORT\n\t\t\txtreport();\n#endif\n\t\t}\n#ifdef WITH_WEBSOCKETS\n\t\tfor(i=0; i<db.config->listener_count; i++){\n\t\t\t/* Extremely hacky, should be using the lws provided external poll\n\t\t\t * interface, but their interface has changed recently and ours\n\t\t\t * will soon, so for now websockets clients are second class\n\t\t\t * citizens. */\n\t\t\tif(db.config->listeners[i].ws_context){\n#if LWS_LIBRARY_VERSION_NUMBER > 3002000\n\t\t\t\tlws_service(db.config->listeners[i].ws_context, -1);\n#elif LWS_LIBRARY_VERSION_NUMBER == 3002000\n\t\t\t\tlws_sul_schedule(db.config->listeners[i].ws_context, 0, &sul, lws__sul_callback, 10);\n\t\t\t\tlws_service(db.config->listeners[i].ws_context, 0);\n#else\n\t\t\t\tlws_service(db.config->listeners[i].ws_context, 0);\n#endif\n\n\t\t\t}\n\t\t}\n#endif\n\t\tplugin__handle_tick();\n\t}\n\n\tmux__cleanup();\n\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 0}
{"idx": 106, "func": "static int persist__subs_save_all(FILE *db_fptr)\n{\n\tstruct mosquitto__subhier *subhier, *subhier_tmp;\n\n\tHASH_ITER(hh, db.subs, subhier, subhier_tmp){\n\t\tif(subhier->children){\n\t\t\tpersist__subs_save(db_fptr, subhier->children, \"\", 0);\n\t\t}\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"idx": 107, "func": "static int persist__subs_save_all(FILE *db_fptr)\n{\n\tstruct mosquitto__subhier *subhier, *subhier_tmp;\n\n\tHASH_ITER(hh, db.normal_subs, subhier, subhier_tmp){\n\t\tif(subhier->children){\n\t\t\tpersist__subs_save(db_fptr, subhier->children, \"\", 0);\n\t\t}\n\t}\n\n\tHASH_ITER(hh, db.shared_subs, subhier, subhier_tmp){\n\t\tif(subhier->children){\n\t\t\tpersist__subs_save(db_fptr, subhier->children, \"\", 0);\n\t\t}\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 0}
{"idx": 108, "func": "static void TEST_sub_add_single(void)\n{\n\tstruct mosquitto__config config;\n\tstruct mosquitto__listener listener;\n\tstruct mosquitto context;\n\tstruct mosquitto__subhier *sub;\n\tint rc;\n\n\tmemset(&db, 0, sizeof(struct mosquitto_db));\n\tmemset(&config, 0, sizeof(struct mosquitto__config));\n\tmemset(&listener, 0, sizeof(struct mosquitto__listener));\n\tmemset(&context, 0, sizeof(struct mosquitto));\n\n\tcontext.id = \"client\";\n\n\tdb.config = &config;\n\tlistener.port = 1883;\n\tconfig.listeners = &listener;\n\tconfig.listener_count = 1;\n\n\tdb__open(&config);\n\n\trc = sub__add(&context, \"a/b/c/d/e\", 0, 0, 0);\n\tCU_ASSERT_EQUAL(rc, MOSQ_ERR_SUCCESS);\n\tCU_ASSERT_PTR_NOT_NULL(db.subs);\n\tif(db.subs){\n\t\tsub = db.subs;\n\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"a\");\n\t\thier_quick_check(&sub, NULL, \"b\");\n\t\thier_quick_check(&sub, NULL, \"c\");\n\t\thier_quick_check(&sub, NULL, \"d\");\n\t\thier_quick_check(&sub, &context, \"e\");\n\t\tCU_ASSERT_PTR_NULL(sub);\n\t}\n\tmosquitto__free(context.subs);\n\tdb__close();\n}\n\n\n/* ========================================================================\n * TEST SUITE SETUP\n * ======================================================================== */", "target": 1}
{"idx": 109, "func": "static void TEST_sub_add_single(void)\n{\n\tstruct mosquitto__config config;\n\tstruct mosquitto__listener listener;\n\tstruct mosquitto context;\n\tstruct mosquitto__subhier *sub;\n\tint rc;\n\n\tmemset(&db, 0, sizeof(struct mosquitto_db));\n\tmemset(&config, 0, sizeof(struct mosquitto__config));\n\tmemset(&listener, 0, sizeof(struct mosquitto__listener));\n\tmemset(&context, 0, sizeof(struct mosquitto));\n\n\tcontext.id = \"client\";\n\n\tdb.config = &config;\n\tlistener.port = 1883;\n\tconfig.listeners = &listener;\n\tconfig.listener_count = 1;\n\n\tdb__open(&config);\n\n\trc = sub__add(&context, \"a/b/c/d/e\", 0, 0, 0);\n\tCU_ASSERT_EQUAL(rc, MOSQ_ERR_SUCCESS);\n\tCU_ASSERT_PTR_NOT_NULL(db.shared_subs);\n\tCU_ASSERT_PTR_NOT_NULL(db.normal_subs);\n\tif(db.normal_subs){\n\t\tsub = db.normal_subs;\n\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"a\");\n\t\thier_quick_check(&sub, NULL, \"b\");\n\t\thier_quick_check(&sub, NULL, \"c\");\n\t\thier_quick_check(&sub, NULL, \"d\");\n\t\thier_quick_check(&sub, &context, \"e\");\n\t\tCU_ASSERT_PTR_NULL(sub);\n\t}\n\tmosquitto__free(context.subs);\n\tdb__close();\n}\n\n\n/* ========================================================================\n * TEST SUITE SETUP\n * ======================================================================== */", "target": 0}
{"idx": 110, "func": "int ogs_dbi_auth_info(char *supi, ogs_dbi_auth_info_t *auth_info)\n{\n    int rv = OGS_OK;\n    mongoc_cursor_t *cursor = NULL;\n    bson_t *query = NULL;\n    bson_error_t error;\n    const bson_t *document;\n    bson_iter_t iter;\n    bson_iter_t inner_iter;\n    char buf[OGS_KEY_LEN];\n    char *utf8 = NULL;\n    uint32_t length = 0;\n\n    char *supi_type = NULL;\n    char *supi_id = NULL;\n\n    ogs_assert(supi);\n    ogs_assert(auth_info);\n\n    supi_type = ogs_id_get_type(supi);\n    ogs_assert(supi_type);\n    supi_id = ogs_id_get_value(supi);\n    ogs_assert(supi_id);\n\n    query = BCON_NEW(supi_type, BCON_UTF8(supi_id));\n#if MONGOC_CHECK_VERSION(1, 5, 0)\n    cursor = mongoc_collection_find_with_opts(\n            ogs_mongoc()->collection.subscriber, query, NULL, NULL);\n#else\n    cursor = mongoc_collection_find(ogs_mongoc()->collection.subscriber,\n            MONGOC_QUERY_NONE, 0, 0, 0, query, NULL, NULL);\n#endif\n\n    if (!mongoc_cursor_next(cursor, &document)) {\n        ogs_info(\"[%s] Cannot find IMSI in DB\", supi);\n\n        rv = OGS_ERROR;\n        goto out;\n    }\n\n    if (mongoc_cursor_error(cursor, &error)) {\n        ogs_error(\"Cursor Failure: %s\", error.message);\n\n        rv = OGS_ERROR;\n        goto out;\n    }\n\n    if (!bson_iter_init_find(&iter, document, OGS_SECURITY_STRING)) {\n        ogs_error(\"No '\" OGS_SECURITY_STRING \"' field in this document\");\n\n        rv = OGS_ERROR;\n        goto out;\n    }\n\n    memset(auth_info, 0, sizeof(ogs_dbi_auth_info_t));\n    bson_iter_recurse(&iter, &inner_iter);\n    while (bson_iter_next(&inner_iter)) {\n        const char *key = bson_iter_key(&inner_iter);\n\n        if (!strcmp(key, OGS_K_STRING) && BSON_ITER_HOLDS_UTF8(&inner_iter)) {\n            utf8 = (char *)bson_iter_utf8(&inner_iter, &length);\n            ogs_ascii_to_hex(utf8, length, buf, sizeof(buf));\n            memcpy(auth_info->k, buf, OGS_KEY_LEN);\n        } else if (!strcmp(key, OGS_OPC_STRING) &&\n                BSON_ITER_HOLDS_UTF8(&inner_iter)) {\n            utf8 = (char *)bson_iter_utf8(&inner_iter, &length);\n            auth_info->use_opc = 1;\n            ogs_ascii_to_hex(utf8, length, buf, sizeof(buf));\n            memcpy(auth_info->opc, buf, OGS_KEY_LEN);\n        } else if (!strcmp(key, OGS_OP_STRING) &&\n                BSON_ITER_HOLDS_UTF8(&inner_iter)) {\n            utf8 = (char *)bson_iter_utf8(&inner_iter, &length);\n            ogs_ascii_to_hex(utf8, length, buf, sizeof(buf));\n            memcpy(auth_info->op, buf, OGS_KEY_LEN);\n        } else if (!strcmp(key, OGS_AMF_STRING) &&\n                BSON_ITER_HOLDS_UTF8(&inner_iter)) {\n            utf8 = (char *)bson_iter_utf8(&inner_iter, &length);\n            ogs_ascii_to_hex(utf8, length, buf, sizeof(buf));\n            memcpy(auth_info->amf, buf, OGS_AMF_LEN);\n        } else if (!strcmp(key, OGS_RAND_STRING) &&\n                BSON_ITER_HOLDS_UTF8(&inner_iter)) {\n            utf8 = (char *)bson_iter_utf8(&inner_iter, &length);\n            ogs_ascii_to_hex(utf8, length, buf, sizeof(buf));\n            memcpy(auth_info->rand, buf, OGS_RAND_LEN);\n        } else if (!strcmp(key, OGS_SQN_STRING) &&\n                BSON_ITER_HOLDS_INT64(&inner_iter)) {\n            auth_info->sqn = bson_iter_int64(&inner_iter);\n        }\n    }\n\nout:\n    if (query) bson_destroy(query);\n    if (cursor) mongoc_cursor_destroy(cursor);\n\n    ogs_free(supi_type);\n    ogs_free(supi_id);\n\n    return rv;\n}", "target": 1}
{"idx": 111, "func": "int ogs_dbi_auth_info(char *supi, ogs_dbi_auth_info_t *auth_info)\n{\n    int rv = OGS_OK;\n    mongoc_cursor_t *cursor = NULL;\n    bson_t *query = NULL;\n    bson_error_t error;\n    const bson_t *document;\n    bson_iter_t iter;\n    bson_iter_t inner_iter;\n    char buf[OGS_KEY_LEN];\n    char *utf8 = NULL;\n    uint32_t length = 0;\n\n    char *supi_type = NULL;\n    char *supi_id = NULL;\n\n    ogs_assert(supi);\n    ogs_assert(auth_info);\n\n    supi_type = ogs_id_get_type(supi);\n    if (!supi_type) {\n        ogs_error(\"Invalid supi=%s\", supi);\n        return OGS_ERROR;\n    }\n    supi_id = ogs_id_get_value(supi);\n    if (!supi_id) {\n        ogs_error(\"Invalid supi=%s\", supi);\n        ogs_free(supi_type);\n        return OGS_ERROR;\n    }\n\n    query = BCON_NEW(supi_type, BCON_UTF8(supi_id));\n#if MONGOC_CHECK_VERSION(1, 5, 0)\n    cursor = mongoc_collection_find_with_opts(\n            ogs_mongoc()->collection.subscriber, query, NULL, NULL);\n#else\n    cursor = mongoc_collection_find(ogs_mongoc()->collection.subscriber,\n            MONGOC_QUERY_NONE, 0, 0, 0, query, NULL, NULL);\n#endif\n\n    if (!mongoc_cursor_next(cursor, &document)) {\n        ogs_info(\"[%s] Cannot find IMSI in DB\", supi);\n\n        rv = OGS_ERROR;\n        goto out;\n    }\n\n    if (mongoc_cursor_error(cursor, &error)) {\n        ogs_error(\"Cursor Failure: %s\", error.message);\n\n        rv = OGS_ERROR;\n        goto out;\n    }\n\n    if (!bson_iter_init_find(&iter, document, OGS_SECURITY_STRING)) {\n        ogs_error(\"No '\" OGS_SECURITY_STRING \"' field in this document\");\n\n        rv = OGS_ERROR;\n        goto out;\n    }\n\n    memset(auth_info, 0, sizeof(ogs_dbi_auth_info_t));\n    bson_iter_recurse(&iter, &inner_iter);\n    while (bson_iter_next(&inner_iter)) {\n        const char *key = bson_iter_key(&inner_iter);\n\n        if (!strcmp(key, OGS_K_STRING) && BSON_ITER_HOLDS_UTF8(&inner_iter)) {\n            utf8 = (char *)bson_iter_utf8(&inner_iter, &length);\n            ogs_ascii_to_hex(utf8, length, buf, sizeof(buf));\n            memcpy(auth_info->k, buf, OGS_KEY_LEN);\n        } else if (!strcmp(key, OGS_OPC_STRING) &&\n                BSON_ITER_HOLDS_UTF8(&inner_iter)) {\n            utf8 = (char *)bson_iter_utf8(&inner_iter, &length);\n            auth_info->use_opc = 1;\n            ogs_ascii_to_hex(utf8, length, buf, sizeof(buf));\n            memcpy(auth_info->opc, buf, OGS_KEY_LEN);\n        } else if (!strcmp(key, OGS_OP_STRING) &&\n                BSON_ITER_HOLDS_UTF8(&inner_iter)) {\n            utf8 = (char *)bson_iter_utf8(&inner_iter, &length);\n            ogs_ascii_to_hex(utf8, length, buf, sizeof(buf));\n            memcpy(auth_info->op, buf, OGS_KEY_LEN);\n        } else if (!strcmp(key, OGS_AMF_STRING) &&\n                BSON_ITER_HOLDS_UTF8(&inner_iter)) {\n            utf8 = (char *)bson_iter_utf8(&inner_iter, &length);\n            ogs_ascii_to_hex(utf8, length, buf, sizeof(buf));\n            memcpy(auth_info->amf, buf, OGS_AMF_LEN);\n        } else if (!strcmp(key, OGS_RAND_STRING) &&\n                BSON_ITER_HOLDS_UTF8(&inner_iter)) {\n            utf8 = (char *)bson_iter_utf8(&inner_iter, &length);\n            ogs_ascii_to_hex(utf8, length, buf, sizeof(buf));\n            memcpy(auth_info->rand, buf, OGS_RAND_LEN);\n        } else if (!strcmp(key, OGS_SQN_STRING) &&\n                BSON_ITER_HOLDS_INT64(&inner_iter)) {\n            auth_info->sqn = bson_iter_int64(&inner_iter);\n        }\n    }\n\nout:\n    if (query) bson_destroy(query);\n    if (cursor) mongoc_cursor_destroy(cursor);\n\n    ogs_free(supi_type);\n    ogs_free(supi_id);\n\n    return rv;\n}", "target": 0}
{"idx": 112, "func": "int32_t Crypto_TC_ProcessSecurity_Cam(uint8_t *ingest, int *len_ingest, TC_t *tc_sdls_processed_frame,\n                                      char *cam_cookies)\n// Loads the ingest frame into the global tc_frame while performing decryption\n{\n    // Local Variables\n    cam_cookies                            = cam_cookies;\n    int32_t                status          = CRYPTO_LIB_SUCCESS;\n    SecurityAssociation_t *sa_ptr          = NULL;\n    uint8_t                sa_service_type = -1;\n    uint8_t               *aad             = NULL;\n    uint16_t               aad_len;\n    uint32_t               encryption_cipher;\n    uint8_t                ecs_is_aead_algorithm = -1;\n    crypto_key_t          *ekp                   = NULL;\n    crypto_key_t          *akp                   = NULL;\n\n    int byte_idx = 0;\n\n    status = Crypto_TC_Process_Sanity_Check(len_ingest);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n    // Primary Header\n    tc_sdls_processed_frame->tc_header.tfvn   = ((uint8_t)ingest[byte_idx] & 0xC0) >> 6;\n    tc_sdls_processed_frame->tc_header.bypass = ((uint8_t)ingest[byte_idx] & 0x20) >> 5;\n    tc_sdls_processed_frame->tc_header.cc     = ((uint8_t)ingest[byte_idx] & 0x10) >> 4;\n    tc_sdls_processed_frame->tc_header.spare  = ((uint8_t)ingest[byte_idx] & 0x0C) >> 2;\n    tc_sdls_processed_frame->tc_header.scid   = ((uint8_t)ingest[byte_idx] & 0x03) << 8;\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.scid = tc_sdls_processed_frame->tc_header.scid | (uint8_t)ingest[byte_idx];\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.vcid = (((uint8_t)ingest[byte_idx] & 0xFC) >> 2) & crypto_config.vcid_bitmask;\n    tc_sdls_processed_frame->tc_header.fl   = ((uint8_t)ingest[byte_idx] & 0x03) << 8;\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.fl = tc_sdls_processed_frame->tc_header.fl | (uint8_t)ingest[byte_idx];\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.fsn = (uint8_t)ingest[byte_idx];\n    byte_idx++;\n\n    if (*len_ingest < tc_sdls_processed_frame->tc_header.fl + 1) // Specified frame length larger than provided frame!\n    {\n        status = CRYPTO_LIB_ERR_INPUT_FRAME_LENGTH_SHORTER_THAN_FRAME_HEADERS_LENGTH;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Lookup-retrieve managed parameters for frame via gvcid:\n    status = Crypto_Get_Managed_Parameters_For_Gvcid(\n        tc_sdls_processed_frame->tc_header.tfvn, tc_sdls_processed_frame->tc_header.scid,\n        tc_sdls_processed_frame->tc_header.vcid, gvcid_managed_parameters_array, &current_managed_parameters_struct);\n\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    } // Unable to get necessary Managed Parameters for TC TF -- return with error.\n\n    // Segment Header\n    Crypto_TC_Set_Segment_Header(tc_sdls_processed_frame, ingest, &byte_idx);\n\n    // Security Header\n    tc_sdls_processed_frame->tc_sec_header.spi = ((uint8_t)ingest[byte_idx] << 8) | (uint8_t)ingest[byte_idx + 1];\n    byte_idx += 2;\n\n#ifdef TC_DEBUG\n    printf(\"vcid = %d \\n\", tc_sdls_processed_frame->tc_header.vcid);\n    printf(\"spi  = %d \\n\", tc_sdls_processed_frame->tc_sec_header.spi);\n#endif\n\n    status = Crypto_TC_Sanity_Validations(tc_sdls_processed_frame, &sa_ptr);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Allocate the necessary byte arrays within the security header + trailer given the SA\n    // tc_sdls_processed_frame->tc_sec_header.iv = calloc(1, sa_ptr->iv_len);\n    // tc_sdls_processed_frame->tc_sec_header.sn = calloc(1, sa_ptr->arsn_len);\n    // tc_sdls_processed_frame->tc_sec_header.pad = calloc(1, sa_ptr->shplf_len);\n    // tc_sdls_processed_frame->tc_sec_trailer.mac = calloc(1, sa_ptr->stmacf_len);\n    // Set tc_sec_header + trailer fields for actual lengths from the SA (downstream apps won't know this length\n    // otherwise since they don't access the SADB!).\n    tc_sdls_processed_frame->tc_sec_header.iv_field_len  = sa_ptr->iv_len;\n    tc_sdls_processed_frame->tc_sec_header.sn_field_len  = sa_ptr->arsn_len;\n    tc_sdls_processed_frame->tc_sec_header.pad_field_len = sa_ptr->shplf_len;\n    // sprintf(tc_sdls_processed_frame->tc_sec_header.pad, \"%x\", pkcs_padding);\n\n    tc_sdls_processed_frame->tc_sec_trailer.mac_field_len = sa_ptr->stmacf_len;\n    // Determine SA Service Type\n    Crypto_TC_Get_SA_Service_Type(&sa_service_type, sa_ptr);\n\n    // Determine Algorithm cipher & mode. // TODO - Parse authentication_cipher, and handle AEAD cases properly\n    Crypto_TC_Get_Ciper_Mode_TCP(sa_service_type, &encryption_cipher, &ecs_is_aead_algorithm, sa_ptr);\n\n#ifdef TC_DEBUG\n    switch (sa_service_type)\n    {\n        case SA_PLAINTEXT:\n            printf(KBLU \"Processing a TC - CLEAR!\\n\" RESET);\n            break;\n        case SA_AUTHENTICATION:\n            printf(KBLU \"Processing a TC - AUTHENTICATED!\\n\" RESET);\n            break;\n        case SA_ENCRYPTION:\n            printf(KBLU \"Processing a TC - ENCRYPTED!\\n\" RESET);\n            break;\n        case SA_AUTHENTICATED_ENCRYPTION:\n            printf(KBLU \"Processing a TC - AUTHENTICATED ENCRYPTION!\\n\" RESET);\n            break;\n    }\n#endif\n\n    // TODO: Calculate lengths when needed\n    uint8_t fecf_len        = FECF_SIZE;\n    uint8_t segment_hdr_len = TC_SEGMENT_HDR_SIZE;\n\n    Crypto_TC_Calc_Lengths(&fecf_len, &segment_hdr_len);\n\n    // Parse & Check FECF\n    Crypto_TC_Parse_Check_FECF(ingest, len_ingest, tc_sdls_processed_frame);\n\n    // Parse transmitted portion of IV from received frame (Will be Whole IV if iv_len==shivf_len)\n    memcpy((tc_sdls_processed_frame->tc_sec_header.iv + (sa_ptr->iv_len - sa_ptr->shivf_len)),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN]), sa_ptr->shivf_len);\n\n    // Handle non-transmitted IV increment case (transmitted-portion roll-over)\n    status = Crypto_TC_Nontransmitted_IV_Increment(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(\"Full IV Value from Frame and SADB (if applicable):\\n\");\n    Crypto_hexprint(tc_sdls_processed_frame->tc_sec_header.iv, sa_ptr->iv_len);\n#endif\n\n    // Parse transmitted portion of ARSN\n    memcpy((tc_sdls_processed_frame->tc_sec_header.sn + (sa_ptr->arsn_len - sa_ptr->shsnf_len)),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len]), sa_ptr->shsnf_len);\n\n    // Handle non-transmitted SN increment case (transmitted-portion roll-over)\n    status = Crypto_TC_Nontransmitted_SN_Increment(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(\"Full ARSN Value from Frame and SADB (if applicable):\\n\");\n    Crypto_hexprint(tc_sdls_processed_frame->tc_sec_header.sn, sa_ptr->arsn_len);\n#endif\n\n    // Parse pad length\n    // tc_sdls_processed_frame->tc_sec_header.pad = malloc((sa_ptr->shplf_len * sizeof(uint8_t)));\n    memcpy((tc_sdls_processed_frame->tc_sec_header.pad),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len + sa_ptr->shsnf_len]),\n           sa_ptr->shplf_len);\n\n    // Parse MAC, prepare AAD\n    status = Crypto_TC_Prep_AAD(tc_sdls_processed_frame, fecf_len, sa_service_type, ecs_is_aead_algorithm, &aad_len,\n                                sa_ptr, segment_hdr_len, ingest, &aad);\n\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    uint16_t tc_enc_payload_start_index =\n        TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len + sa_ptr->shsnf_len + sa_ptr->shplf_len;\n\n    // Todo -- if encrypt only, ignore stmacf_len entirely to avoid erroring on SA misconfiguration... Or just throw a\n    // warning/error indicating SA misconfiguration?\n    tc_sdls_processed_frame->tc_pdu_len =\n        tc_sdls_processed_frame->tc_header.fl + 1 - tc_enc_payload_start_index - sa_ptr->stmacf_len - fecf_len;\n\n    if (tc_sdls_processed_frame->tc_pdu_len >\n        tc_sdls_processed_frame->tc_header.fl) // invalid header parsed, sizes overflowed & make no sense!\n    {\n        status = CRYPTO_LIB_ERR_INVALID_HEADER;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(KYEL \"TC PDU Calculated Length: %d \\n\" RESET, tc_sdls_processed_frame->tc_pdu_len);\n#endif\n\n    /* Get Key */\n    status = Crypto_TC_Get_Keys(&ekp, &akp, sa_ptr);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    status = Crypto_TC_Do_Decrypt(sa_service_type, ecs_is_aead_algorithm, ekp, sa_ptr, aad, tc_sdls_processed_frame,\n                                  ingest, tc_enc_payload_start_index, aad_len, cam_cookies, akp, segment_hdr_len);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        Crypto_TC_Safe_Free_Ptr(aad);\n        mc_if->mc_log(status);\n        return status; // Cryptography IF call failed, return.\n    }\n\n    // Now that MAC has been verified, check IV & ARSN if applicable\n    status = Crypto_TC_Check_IV_ARSN(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        Crypto_TC_Safe_Free_Ptr(aad);\n        mc_if->mc_log(status);\n        return status; // Cryptography IF call failed, return.\n    }\n    // Extended PDU processing, if applicable\n\n    if (status == CRYPTO_LIB_SUCCESS && crypto_config.process_sdls_pdus == TC_PROCESS_SDLS_PDUS_TRUE)\n    {\n        status = Crypto_Process_Extended_Procedure_Pdu(tc_sdls_processed_frame, ingest);\n    }\n\n    Crypto_TC_Safe_Free_Ptr(aad);\n\n    mc_if->mc_log(status);\n    return status;\n}\n\n/**\n * @brief Function: Crypto_Get_tcPayloadLength\n * Returns the payload length of current tc_frame in BYTES!\n * @param tc_frame: TC_t*\n * @param sa_ptr: SecurityAssociation_t\n * @return int32, Length of TCPayload\n **/\n/*\nint32_t Crypto_Get_tcPayloadLength(TC_t* tc_frame, SecurityAssociation_t* sa_ptr)\n{\n    int tf_hdr = 5;\n    int seg_hdr = 0;if(current_managed_parameters_struct.has_segmentation_hdr==TC_HAS_SEGMENT_HDRS){seg_hdr=1;}\n    int fecf = 0;if(current_managed_parameters_struct.has_fecf==TC_HAS_FECF){fecf=FECF_SIZE;}\n    int spi = 2;\n    int iv_size = sa_ptr->shivf_len;\n    int mac_size = sa_ptr->stmacf_len;\n\n    #ifdef TC_DEBUG\n        printf(\"Get_tcPayloadLength Debug [byte lengths]:\\n\");\n        printf(\"\\thdr.fl\\t%d\\n\", tc_frame->tc_header.fl);\n        printf(\"\\ttf_hdr\\t%d\\n\",tf_hdr);\n        printf(\"\\tSeg hdr\\t%d\\t\\n\",seg_hdr);\n        printf(\"\\tspi \\t%d\\n\",spi);\n        printf(\"\\tiv_size\\t%d\\n\",iv_size);\n        printf(\"\\tmac\\t%d\\n\",mac_size);\n        printf(\"\\tfecf \\t%d\\n\",fecf);\n        printf(\"\\tTOTAL LENGTH: %d\\n\", (tc_frame->tc_header.fl - (tf_hdr + seg_hdr + spi + iv_size ) - (mac_size +\nfecf))); #endif\n\n    return (tc_frame->tc_header.fl + 1 - (tf_hdr + seg_hdr + spi + iv_size ) - (mac_size + fecf) );\n}\n*/\n\n/**\n * @brief Function: Crypto_Prepare_TC_AAD\n * Callocs and returns pointer to buffer where AAD is created & bitwise-anded with bitmask!\n * Note: Function caller is responsible for freeing the returned buffer!\n * @param buffer: uint8_t*\n * @param len_aad: uint16_t\n * @param abm_buffer: uint8_t*\n **/", "target": 1}
{"idx": 113, "func": "int32_t Crypto_TC_ProcessSecurity_Cam(uint8_t *ingest, int *len_ingest, TC_t *tc_sdls_processed_frame,\n                                      char *cam_cookies)\n// Loads the ingest frame into the global tc_frame while performing decryption\n{\n    // Local Variables\n    cam_cookies                            = cam_cookies;\n    int32_t                status          = CRYPTO_LIB_SUCCESS;\n    SecurityAssociation_t *sa_ptr          = NULL;\n    uint8_t                sa_service_type = -1;\n    uint8_t               *aad             = NULL;\n    uint16_t               aad_len;\n    uint32_t               encryption_cipher;\n    uint8_t                ecs_is_aead_algorithm = -1;\n    crypto_key_t          *ekp                   = NULL;\n    crypto_key_t          *akp                   = NULL;\n\n    int byte_idx = 0;\n\n    status = Crypto_TC_Process_Sanity_Check(len_ingest);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n    // Primary Header\n    tc_sdls_processed_frame->tc_header.tfvn   = ((uint8_t)ingest[byte_idx] & 0xC0) >> 6;\n    tc_sdls_processed_frame->tc_header.bypass = ((uint8_t)ingest[byte_idx] & 0x20) >> 5;\n    tc_sdls_processed_frame->tc_header.cc     = ((uint8_t)ingest[byte_idx] & 0x10) >> 4;\n    tc_sdls_processed_frame->tc_header.spare  = ((uint8_t)ingest[byte_idx] & 0x0C) >> 2;\n    tc_sdls_processed_frame->tc_header.scid   = ((uint8_t)ingest[byte_idx] & 0x03) << 8;\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.scid = tc_sdls_processed_frame->tc_header.scid | (uint8_t)ingest[byte_idx];\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.vcid = (((uint8_t)ingest[byte_idx] & 0xFC) >> 2) & crypto_config.vcid_bitmask;\n    tc_sdls_processed_frame->tc_header.fl   = ((uint8_t)ingest[byte_idx] & 0x03) << 8;\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.fl = tc_sdls_processed_frame->tc_header.fl | (uint8_t)ingest[byte_idx];\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.fsn = (uint8_t)ingest[byte_idx];\n    byte_idx++;\n\n    if (*len_ingest < tc_sdls_processed_frame->tc_header.fl + 1) // Specified frame length larger than provided frame!\n    {\n        status = CRYPTO_LIB_ERR_INPUT_FRAME_LENGTH_SHORTER_THAN_FRAME_HEADERS_LENGTH;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Lookup-retrieve managed parameters for frame via gvcid:\n    status = Crypto_Get_Managed_Parameters_For_Gvcid(\n        tc_sdls_processed_frame->tc_header.tfvn, tc_sdls_processed_frame->tc_header.scid,\n        tc_sdls_processed_frame->tc_header.vcid, gvcid_managed_parameters_array, &current_managed_parameters_struct);\n\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    } // Unable to get necessary Managed Parameters for TC TF -- return with error.\n\n    // Segment Header\n    Crypto_TC_Set_Segment_Header(tc_sdls_processed_frame, ingest, &byte_idx);\n\n    // Security Header\n    tc_sdls_processed_frame->tc_sec_header.spi = ((uint8_t)ingest[byte_idx] << 8) | (uint8_t)ingest[byte_idx + 1];\n    byte_idx += 2;\n\n#ifdef TC_DEBUG\n    printf(\"vcid = %d \\n\", tc_sdls_processed_frame->tc_header.vcid);\n    printf(\"spi  = %d \\n\", tc_sdls_processed_frame->tc_sec_header.spi);\n#endif\n\n    status = Crypto_TC_Sanity_Validations(tc_sdls_processed_frame, &sa_ptr);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Allocate the necessary byte arrays within the security header + trailer given the SA\n    // tc_sdls_processed_frame->tc_sec_header.iv = calloc(1, sa_ptr->iv_len);\n    // tc_sdls_processed_frame->tc_sec_header.sn = calloc(1, sa_ptr->arsn_len);\n    // tc_sdls_processed_frame->tc_sec_header.pad = calloc(1, sa_ptr->shplf_len);\n    // tc_sdls_processed_frame->tc_sec_trailer.mac = calloc(1, sa_ptr->stmacf_len);\n    // Set tc_sec_header + trailer fields for actual lengths from the SA (downstream apps won't know this length\n    // otherwise since they don't access the SADB!).\n    tc_sdls_processed_frame->tc_sec_header.iv_field_len  = sa_ptr->iv_len;\n    tc_sdls_processed_frame->tc_sec_header.sn_field_len  = sa_ptr->arsn_len;\n    tc_sdls_processed_frame->tc_sec_header.pad_field_len = sa_ptr->shplf_len;\n    // sprintf(tc_sdls_processed_frame->tc_sec_header.pad, \"%x\", pkcs_padding);\n\n    tc_sdls_processed_frame->tc_sec_trailer.mac_field_len = sa_ptr->stmacf_len;\n    // Determine SA Service Type\n    Crypto_TC_Get_SA_Service_Type(&sa_service_type, sa_ptr);\n\n    // Determine Algorithm cipher & mode. // TODO - Parse authentication_cipher, and handle AEAD cases properly\n    Crypto_TC_Get_Ciper_Mode_TCP(sa_service_type, &encryption_cipher, &ecs_is_aead_algorithm, sa_ptr);\n\n#ifdef TC_DEBUG\n    switch (sa_service_type)\n    {\n        case SA_PLAINTEXT:\n            printf(KBLU \"Processing a TC - CLEAR!\\n\" RESET);\n            break;\n        case SA_AUTHENTICATION:\n            printf(KBLU \"Processing a TC - AUTHENTICATED!\\n\" RESET);\n            break;\n        case SA_ENCRYPTION:\n            printf(KBLU \"Processing a TC - ENCRYPTED!\\n\" RESET);\n            break;\n        case SA_AUTHENTICATED_ENCRYPTION:\n            printf(KBLU \"Processing a TC - AUTHENTICATED ENCRYPTION!\\n\" RESET);\n            break;\n    }\n#endif\n\n    // TODO: Calculate lengths when needed\n    uint8_t fecf_len        = FECF_SIZE;\n    uint8_t segment_hdr_len = TC_SEGMENT_HDR_SIZE;\n\n    Crypto_TC_Calc_Lengths(&fecf_len, &segment_hdr_len);\n\n    if(tc_sdls_processed_frame->tc_header.fl <= TC_FRAME_HEADER_SIZE - segment_hdr_len - fecf_len + 1)\n    {\n        status = CRYPTO_LIB_ERR_TC_FRAME_LENGTH_UNDERFLOW;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Parse & Check FECF\n    Crypto_TC_Parse_Check_FECF(ingest, len_ingest, tc_sdls_processed_frame);\n\n    // Parse transmitted portion of IV from received frame (Will be Whole IV if iv_len==shivf_len)\n    memcpy((tc_sdls_processed_frame->tc_sec_header.iv + (sa_ptr->iv_len - sa_ptr->shivf_len)),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN]), sa_ptr->shivf_len);\n\n    // Handle non-transmitted IV increment case (transmitted-portion roll-over)\n    status = Crypto_TC_Nontransmitted_IV_Increment(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(\"Full IV Value from Frame and SADB (if applicable):\\n\");\n    Crypto_hexprint(tc_sdls_processed_frame->tc_sec_header.iv, sa_ptr->iv_len);\n#endif\n\n    // Parse transmitted portion of ARSN\n    memcpy((tc_sdls_processed_frame->tc_sec_header.sn + (sa_ptr->arsn_len - sa_ptr->shsnf_len)),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len]), sa_ptr->shsnf_len);\n\n    // Handle non-transmitted SN increment case (transmitted-portion roll-over)\n    status = Crypto_TC_Nontransmitted_SN_Increment(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(\"Full ARSN Value from Frame and SADB (if applicable):\\n\");\n    Crypto_hexprint(tc_sdls_processed_frame->tc_sec_header.sn, sa_ptr->arsn_len);\n#endif\n\n    // Parse pad length\n    // tc_sdls_processed_frame->tc_sec_header.pad = malloc((sa_ptr->shplf_len * sizeof(uint8_t)));\n    memcpy((tc_sdls_processed_frame->tc_sec_header.pad),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len + sa_ptr->shsnf_len]),\n           sa_ptr->shplf_len);\n\n    // Parse MAC, prepare AAD\n    status = Crypto_TC_Prep_AAD(tc_sdls_processed_frame, fecf_len, sa_service_type, ecs_is_aead_algorithm, &aad_len,\n                                sa_ptr, segment_hdr_len, ingest, &aad);\n\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    uint16_t tc_enc_payload_start_index =\n        TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len + sa_ptr->shsnf_len + sa_ptr->shplf_len;\n\n    // Todo -- if encrypt only, ignore stmacf_len entirely to avoid erroring on SA misconfiguration... Or just throw a\n    // warning/error indicating SA misconfiguration?\n    tc_sdls_processed_frame->tc_pdu_len =\n        tc_sdls_processed_frame->tc_header.fl + 1 - tc_enc_payload_start_index - sa_ptr->stmacf_len - fecf_len;\n\n    if (tc_sdls_processed_frame->tc_pdu_len >\n        tc_sdls_processed_frame->tc_header.fl) // invalid header parsed, sizes overflowed & make no sense!\n    {\n        status = CRYPTO_LIB_ERR_INVALID_HEADER;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(KYEL \"TC PDU Calculated Length: %d \\n\" RESET, tc_sdls_processed_frame->tc_pdu_len);\n#endif\n\n    /* Get Key */\n    status = Crypto_TC_Get_Keys(&ekp, &akp, sa_ptr);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    status = Crypto_TC_Do_Decrypt(sa_service_type, ecs_is_aead_algorithm, ekp, sa_ptr, aad, tc_sdls_processed_frame,\n                                  ingest, tc_enc_payload_start_index, aad_len, cam_cookies, akp, segment_hdr_len);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        Crypto_TC_Safe_Free_Ptr(aad);\n        mc_if->mc_log(status);\n        return status; // Cryptography IF call failed, return.\n    }\n\n    // Now that MAC has been verified, check IV & ARSN if applicable\n    status = Crypto_TC_Check_IV_ARSN(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        Crypto_TC_Safe_Free_Ptr(aad);\n        mc_if->mc_log(status);\n        return status; // Cryptography IF call failed, return.\n    }\n    // Extended PDU processing, if applicable\n\n    if (status == CRYPTO_LIB_SUCCESS && crypto_config.process_sdls_pdus == TC_PROCESS_SDLS_PDUS_TRUE)\n    {\n        status = Crypto_Process_Extended_Procedure_Pdu(tc_sdls_processed_frame, ingest);\n    }\n\n    Crypto_TC_Safe_Free_Ptr(aad);\n\n    mc_if->mc_log(status);\n    return status;\n}\n\n/**\n * @brief Function: Crypto_Get_tcPayloadLength\n * Returns the payload length of current tc_frame in BYTES!\n * @param tc_frame: TC_t*\n * @param sa_ptr: SecurityAssociation_t\n * @return int32, Length of TCPayload\n **/\n/*\nint32_t Crypto_Get_tcPayloadLength(TC_t* tc_frame, SecurityAssociation_t* sa_ptr)\n{\n    int tf_hdr = 5;\n    int seg_hdr = 0;if(current_managed_parameters_struct.has_segmentation_hdr==TC_HAS_SEGMENT_HDRS){seg_hdr=1;}\n    int fecf = 0;if(current_managed_parameters_struct.has_fecf==TC_HAS_FECF){fecf=FECF_SIZE;}\n    int spi = 2;\n    int iv_size = sa_ptr->shivf_len;\n    int mac_size = sa_ptr->stmacf_len;\n\n    #ifdef TC_DEBUG\n        printf(\"Get_tcPayloadLength Debug [byte lengths]:\\n\");\n        printf(\"\\thdr.fl\\t%d\\n\", tc_frame->tc_header.fl);\n        printf(\"\\ttf_hdr\\t%d\\n\",tf_hdr);\n        printf(\"\\tSeg hdr\\t%d\\t\\n\",seg_hdr);\n        printf(\"\\tspi \\t%d\\n\",spi);\n        printf(\"\\tiv_size\\t%d\\n\",iv_size);\n        printf(\"\\tmac\\t%d\\n\",mac_size);\n        printf(\"\\tfecf \\t%d\\n\",fecf);\n        printf(\"\\tTOTAL LENGTH: %d\\n\", (tc_frame->tc_header.fl - (tf_hdr + seg_hdr + spi + iv_size ) - (mac_size +\nfecf))); #endif\n\n    return (tc_frame->tc_header.fl + 1 - (tf_hdr + seg_hdr + spi + iv_size ) - (mac_size + fecf) );\n}\n*/\n\n/**\n * @brief Function: Crypto_Prepare_TC_AAD\n * Callocs and returns pointer to buffer where AAD is created & bitwise-anded with bitmask!\n * Note: Function caller is responsible for freeing the returned buffer!\n * @param buffer: uint8_t*\n * @param len_aad: uint16_t\n * @param abm_buffer: uint8_t*\n **/", "target": 0}
{"idx": 114, "func": "UTEST(TC_PROCESS, TC_KEY_STATE_TEST)\n{\n    remove(\"sa_save_file.bin\");\n    // Local Variables\n    int32_t status = CRYPTO_LIB_SUCCESS;\n\n    // Configure Parameters\n    Crypto_Config_CryptoLib(KEY_TYPE_INTERNAL, MC_TYPE_INTERNAL, SA_TYPE_INMEMORY, CRYPTOGRAPHY_TYPE_LIBGCRYPT,\n                            IV_INTERNAL, CRYPTO_TC_CREATE_FECF_TRUE, TC_PROCESS_SDLS_PDUS_TRUE, TC_HAS_PUS_HDR,\n                            TC_IGNORE_SA_STATE_FALSE, TC_IGNORE_ANTI_REPLAY_TRUE, TC_UNIQUE_SA_PER_MAP_ID_FALSE,\n                            TC_CHECK_FECF_TRUE, 0x3F, SA_INCREMENT_NONTRANSMITTED_IV_TRUE);\n    // AOS Tests\n    // Crypto_Config_Add_Gvcid_Managed_Parameter(0, 0x0003, 0, TC_HAS_FECF, TC_HAS_SEGMENT_HDRS, TC_OCF_NA, 1024,\n    // AOS_FHEC_NA, AOS_IZ_NA, 0);\n    GvcidManagedParameters_t AOS_Managed_Parameters = {\n        0, 0x0003, 0, TC_HAS_FECF, AOS_FHEC_NA, AOS_IZ_NA, 0, TC_HAS_SEGMENT_HDRS, 1024, TC_OCF_NA, 1};\n    Crypto_Config_Add_Gvcid_Managed_Parameters(AOS_Managed_Parameters);\n\n    status = Crypto_Init();\n\n    TC_t *tc_sdls_processed_frame;\n    tc_sdls_processed_frame = malloc(sizeof(uint8_t) * TC_SIZE);\n    memset(tc_sdls_processed_frame, 0, (sizeof(uint8_t) * TC_SIZE));\n\n    // Test frame setup\n    char    *test_frame_pt_h = \"2003002A0000000100000000000000000000000000000000025364F9BC3344AF359DA06CA886748F59A0AB\";\n    uint8_t *test_frame_pt_b = NULL;\n    int      test_frame_pt_len = 0;\n\n    SecurityAssociation_t *test_association;\n    sa_if->sa_get_from_spi(1, &test_association);\n    test_association->sa_state  = SA_OPERATIONAL;\n    test_association->est       = 1;\n    test_association->arsn_len  = 0;\n    test_association->shsnf_len = 0;\n\n    crypto_key_t *ekp = NULL;\n    ekp               = key_if->get_key(test_association->ekid);\n    ekp->key_state    = KEY_DEACTIVATED;\n\n    crypto_key_t *akp = NULL;\n    akp               = key_if->get_key(test_association->akid);\n    akp->key_state    = KEY_DEACTIVATED;\n\n    // Convert input test frame\n    hex_conversion(test_frame_pt_h, (char **)&test_frame_pt_b, &test_frame_pt_len);\n\n    status = Crypto_TC_ProcessSecurity(test_frame_pt_b, &test_frame_pt_len, tc_sdls_processed_frame);\n\n    ASSERT_EQ(CRYPTO_LIB_ERR_KEY_STATE_INVALID, status);\n    free(test_frame_pt_b);\n    free(tc_sdls_processed_frame);\n    Crypto_Shutdown();\n}\n\nUTEST_MAIN();", "target": 1}
{"idx": 115, "func": "UTEST(TC_PROCESS, TC_HEAP_BUFFER_OVERFLOW_TEST)\n{\n    remove(\"sa_save_file.bin\");\n    // Local Variables\n    int32_t status = CRYPTO_LIB_SUCCESS;\n\n    // Configure Parameters\n    Crypto_Config_CryptoLib(KEY_TYPE_INTERNAL, MC_TYPE_INTERNAL, SA_TYPE_INMEMORY, CRYPTOGRAPHY_TYPE_LIBGCRYPT,\n                            IV_INTERNAL, CRYPTO_TC_CREATE_FECF_TRUE, TC_PROCESS_SDLS_PDUS_TRUE, TC_HAS_PUS_HDR,\n                            TC_IGNORE_SA_STATE_FALSE, TC_IGNORE_ANTI_REPLAY_TRUE, TC_UNIQUE_SA_PER_MAP_ID_FALSE,\n                            TC_CHECK_FECF_TRUE, 0x3F, SA_INCREMENT_NONTRANSMITTED_IV_TRUE);\n    // AOS Tests\n    // Crypto_Config_Add_Gvcid_Managed_Parameter(0, 0x0003, 0, TC_HAS_FECF, TC_HAS_SEGMENT_HDRS, TC_OCF_NA, 1024,\n    // AOS_FHEC_NA, AOS_IZ_NA, 0);\n    GvcidManagedParameters_t AOS_Managed_Parameters = {\n        0, 0x0003, 0, TC_HAS_FECF, AOS_FHEC_NA, AOS_IZ_NA, 0, TC_HAS_SEGMENT_HDRS, 1024, TC_OCF_NA, 1};\n    Crypto_Config_Add_Gvcid_Managed_Parameters(AOS_Managed_Parameters);\n\n    status = Crypto_Init();\n\n    TC_t *tc_sdls_processed_frame;\n    tc_sdls_processed_frame = malloc(sizeof(uint8_t) * TC_SIZE);\n    memset(tc_sdls_processed_frame, 0, (sizeof(uint8_t) * TC_SIZE));\n\n    // Test frame setup\n    char    *test_frame_pt_h = \"080300007f0b000afd020202027fff02020202020202020202020202029bdd5f3c98dd1c50d27a430\"\n                               \"a4b6757aa33ec183952a9f76e504eb5f8001066ed6c00c8788e11997f2a058da1633e11fed9851d45\"\n                               \"7bb31a9637ec8f4f15bc8575a0e7104dba5c666b17f7cccdc2adbff9\";\n    uint8_t *test_frame_pt_b = NULL;\n    int      test_frame_pt_len = 0;\n\n    SecurityAssociation_t *test_association;\n    sa_if->sa_get_from_spi(10, &test_association);\n    test_association->sa_state  = SA_OPERATIONAL;\n    test_association->est       = 1;\n    test_association->arsn_len  = 0;\n    test_association->shsnf_len = 0;\n\n    crypto_key_t *ekp = NULL;\n    ekp               = key_if->get_key(test_association->ekid);\n    ekp->key_state    = KEY_ACTIVE;\n\n    // Convert input test frame\n    hex_conversion(test_frame_pt_h, (char **)&test_frame_pt_b, &test_frame_pt_len);\n\n    status = Crypto_TC_ProcessSecurity(test_frame_pt_b, &test_frame_pt_len, tc_sdls_processed_frame);\n\n    ASSERT_EQ(CRYPTO_LIB_ERR_TC_FRAME_LENGTH_UNDERFLOW, status);\n    free(test_frame_pt_b);\n    free(tc_sdls_processed_frame);\n    Crypto_Shutdown();\n}\n\nUTEST_MAIN();", "target": 0}
{"idx": 116, "func": "S_pmtrans(pTHX_ OP *o, OP *expr, OP *repl)\n{\n    /* This function compiles a tr///, from data gathered from toke.c, into a\n     * form suitable for use by do_trans() in doop.c at runtime.\n     *\n     * It has two passes.  The second is mainly to streamline the result of the\n     * first pass, resulting in less memory usage and faster runtime execution\n     * besides.\n     *\n     * The first pass normalizes the data, while discarding extraneous inputs.\n     * The normalization allows for complete analysis, and avoids some false\n     * negatives and positives earlier versions of this code had.\n     *\n     * The normalizd form is an inversion map (described below in detail).\n     * This is essentially the compiled form for tr///'s that require UTF-8,\n     * There is a different form for those that don't need UTF-8, identical to\n     * what's been in use for many perl versions, except that it doesn't handle\n     * some edge cases that it used to, involving code points above 255.  The\n     * UTF-8 form now handles these.  (This could be changed with extra coding\n     * should it shown to be desirable.)\n     *\n     * If the complement (/c) option is specified, the lhs string (tstr) is\n     * parsed into an inversion list.  Complementing these is trivial.  Then a\n     * complemented tstr is built from that, and used thenceforth.  This hides\n     * the fact that it was complemented from almost all successive code.\n     *\n     * One of the important characteristics to know about the input is whether\n     * the transliteration may be done in place, or does a temporary need to be\n     * allocated, then copied.  If the replacement for every character in every\n     * possible string takes up no more bytes than the character it\n     * replaces, then it can be edited in place.  Otherwise the replacement\n     * could overwrite a byte we are about to read, depending on the strings\n     * being processed.  The comments and variable names here refer to this as\n     * \"growing\".  Some inputs won't grow, and might even shrink under /d, but\n     * some inputs could grow, so we have to assume any given one might grow.\n     * On very long inputs, the temporary could eat up a lot of memory, so we\n     * want to avoid it if possible.  For non-UTF-8 inputs, everything is\n     * single-byte, so can be edited in place, unless there is something in the\n     * pattern that could force it into UTF-8.  The inversion map makes it\n     * feasible to determine this.  Previous versions of this code pretty much\n     * punted on determining if UTF-8 could be edited in place.  Now, this code\n     * is rigorous in making that determination.\n     *\n     * Another characteristic we need to know is whether the lhs and rhs are\n     * identical.  If so, and no other flags are present, the only effect of\n     * the tr/// is to count the characters present in the input that are\n     * mentioned in the lhs string.  The implementation of that is easier and\n     * runs faster than the more general case.  Normalizing here allows for\n     * accurate determination of this.  Previously there were false negatives\n     * possible.\n     *\n     * Instead of 'transliterated', the comments here use 'unmapped' for the\n     * characters that are left unchanged by the operation; otherwise they are\n     * 'mapped'\n     *\n     * The lhs of the tr/// is here referred to as the t side.\n     * The rhs of the tr/// is here referred to as the r side.\n     *\n     * An inversion map consists of two parallel arrays.  One is essentially an\n     * inversion list: an ordered list of code points such that each element\n     * gives the first code point of a range of consecutive code points that\n     * map to the element in the other array that has the same index as this\n     * one (in other words, the corresponding element).  Thus the range extends\n     * up to (but not including) the code point given by the next higher\n     * element.  In a true inversion map, the corresponding element in the\n     * other array (the inversion list) gives the mapping of the first code\n     * point in the range, with the understanding that the next higher code\n     * point in the inversion list's range will map to the next higher code\n     * point in the map.\n     *\n     * So if at element [i], let's say we have:\n     *\n     *     t_invlist  r_map\n     * [i]    A         a\n     *\n     * This means that A => a, B => b, C => c....  Let's say that the situation\n     * is such that:\n     *\n     * [i+1]  L        -1\n     *\n     * This means the sequence that started at [i] stops at K => k.  This\n     * illustrates that you need to look at the next element to find where a\n     * sequence stops.  Except, the highest element in the inversion list\n     * begins a range that is understood to extend to the platform's infinity.\n     *\n     * This routine modifies traditional inversion maps to reserve two\n     * mappings:\n     *\n     *  TR_UNLISTED (or -1) indicates that no code point in the range is listed\n     *      in the tr/// searchlist.  At runtime, these are always passed\n     *      through unchanged.  In the inversion map, all points in the range\n     *      are mapped to -1, instead of increasing.  The 'L' entry in the\n     *      example above illustrates this.\n     *\n     *      We start the parse with every code point mapped to this, and as we\n     *      parse and find ones that are listed in the search list, we carve\n     *      out ranges as we go along that override that.\n     *\n     *  So, if the next element in our main example is such that it yields:\n     *\n     * [i]    A        a\n     * [i+1]  L       -1\n     * [i+2]  Q        q\n     *\n     * Then all of L, M, N, O, and P map to TR_UNLISTED.  We know that Q maps\n     * to q, but we need the next element (or know this is the final one) to\n     * figure out what comes next.\n     *\n     * The other special mapping is\n     *\n     *  TR_SPECIAL_HANDLING (or -2) indicates that every code point in the\n     *      range needs special handling.  Again, all code points in the range\n     *      are mapped to -2, instead of increasing.\n     *\n     *      There are two cases where this mapping is used:\n     *\n     *      Under /d this value means the code point should be deleted from the\n     *      transliteration when encountered.\n     *\n     *      Otherwise, it marks that every code point in the range is to map to\n     *      the final character in the replacement list.  This happens only\n     *      when the replacement list is shorter than the search one, so there\n     *      are things in the search list that have no correspondence in the\n     *      replacement list.  For example, in tr/a-z/A/, 'A' is the final\n     *      value, and the inversion map generated for this would be like this:\n     *          \\0  =>  -1\n     *          a   =>   A\n     *          b-z =>  -2\n     *          z+1 =>  -1\n     *      'A' appears once, then the remainder of the range maps to -2.  The\n     *      use of -2 isn't strictly necessary, as an inversion map is capable\n     *      of representing this situation, but not nearly so compactly, and\n     *      this is actually quite commonly encountered.  Indeed, the original\n     *      design of this code used a full inversion map for this.  But things\n     *      like\n     *          tr/\\0-\\x{FFFF}/A/\n     *      generated huge data structures, slowly, and the execution was also\n     *      slow.  So the current scheme was implemented.\n     *\n     * If the next few elements in the example yield\n     *\n     * [i]    A        a\n     * [i+1]  L       -1\n     * [i+2]  Q        q\n     * [i+3]  R        z\n     * [i+4]  S       TR_UNLISTED\n     *\n     * Then Q => q; R => z; and S => TR_UNLISTED.  If [i+4] (the 'S') is the\n     * final element in the arrays, every code point from S to infinity maps to\n     * TR_UNLISTED.\n     */\n\n    SV * const tstr = cSVOPx(expr)->op_sv;\n    SV * const rstr = cSVOPx(repl)->op_sv;\n    STRLEN tlen;\n    STRLEN rlen;\n    const U8 * t0 = (U8*)SvPV_const(tstr, tlen);\n    const U8 * r0 = (U8*)SvPV_const(rstr, rlen);\n    const U8 * t = t0;\n    const U8 * r = r0;\n    UV t_count = 0, r_count = 0;  /* Number of characters in search and\n                                         replacement lists */\n\n    /* khw thinks some of the private flags for this op are quaintly named.\n     * OPpTRANS_GROWS for example is TRUE if the replacement for some lhs\n     * character when represented in UTF-8 is longer than the original\n     * character's UTF-8 representation */\n    const bool complement = cBOOL(o->op_private & OPpTRANS_COMPLEMENT);\n    const bool squash     = cBOOL(o->op_private & OPpTRANS_SQUASH);\n    const bool del        = cBOOL(o->op_private & OPpTRANS_DELETE);\n\n    /* Set to true if there is some character < 256 in the lhs that maps to\n     * above 255.  If so, a non-UTF-8 match string can be forced into being in\n     * UTF-8 by a tr/// operation. */\n    bool can_force_utf8 = FALSE;\n\n    /* If only ASCII-range characters are involved, some shortcuts can be done\n     * at runtime */\n    bool has_utf8_variant = false;\n\n    /* What is the maximum expansion factor in UTF-8 transliterations,\n     * calculated in the first pass.  If a 2-byte UTF-8 encoded character is to\n     * be replaced by a 3-byte one, its expansion factor is 1.5.  This number\n     * is used at runtime to calculate how much space to allocate for\n     * non-inplace transliterations.  Without this number, the worst case is\n     * 14, which is extremely unlikely to happen in real life, and could\n     * require significant memory overhead. */\n    NV max_expansion = 1.;\n\n    UV t_range_count, r_range_count, min_range_count;\n    UV* t_array;\n    SV* t_invlist;\n    UV* r_map;\n    UV r_cp = 0, t_cp = 0;\n    UV t_cp_end = (UV) -1;\n    UV r_cp_end;\n    Size_t len;\n    AV* invmap;\n    UV final_map = TR_UNLISTED;    /* The final character in the replacement\n                                      list, updated as we go along.  Initialize\n                                      to something illegal */\n\n    bool rstr_utf8 = cBOOL(SvUTF8(rstr));\n    bool tstr_utf8 = cBOOL(SvUTF8(tstr));\n\n    const U8* tend = t + tlen;\n    const U8* rend = r + rlen;\n\n    SV * inverted_tstr = NULL;\n\n    Size_t i;\n    unsigned int pass2;\n\n    /* This routine implements detection of a transliteration having a longer\n     * UTF-8 representation than its source, by partitioning in the first pass\n     * all the possible code points of the platform into equivalence classes of\n     * the same UTF-8 byte length.  PL_partition_by_byte_length[] is the guts\n     * of an inversion list that does this.  It is used to avoid the expense of\n     * constructing the partition at runtime.  It covers the entire range of\n     * code points possible on this platform, and each entry is for the single\n     * range of code points whose UTF-8 representation has the same length.\n     * (The definition of UTF-8 guarantees that there is a single range for\n     * each length.) */\n    UV PL_partition_by_byte_length[] = {\n        0,\n\n        /* 0 .. 127  all have 1 byte\n         * representations */\n        0x80,\n\n        /* The highest two UTF-8 byte representable code point is the one with\n         * all 1's in the payload bearing bits of the start byte and its single\n         * continuation byte.  Those start bytes have 5 bits in their payload,\n         * and the single start byte has UTF_ACCUMULATION_SHIFT payload bits.\n         * The range for three byte code points starts at 1 plus that. */\n        1 + nBIT_UMAX(5 + 1 * UTF_ACCUMULATION_SHIFT),  /* begins 3 bytes */\n\n       /* The same is true for each succeeding byte length.  Each has one less\n        * bit in the start byte than the previous one, but one more\n        * continuation byte. */\n        1 + nBIT_UMAX(4 + 2 * UTF_ACCUMULATION_SHIFT),  /* begins 4 bytes */\n        1 + nBIT_UMAX(3 + 3 * UTF_ACCUMULATION_SHIFT),  /* begins 5 bytes */\n        1 + nBIT_UMAX(2 + 4 * UTF_ACCUMULATION_SHIFT),  /* begins 6 bytes */\n        1 + nBIT_UMAX(1 + 5 * UTF_ACCUMULATION_SHIFT),  /* begins 7 bytes */\n\n#  ifdef UV_IS_QUAD\n\n        /* begins platform's longest number of bytes */\n        1 + nBIT_UMAX(0 + 6 * UTF_ACCUMULATION_SHIFT)\n#  endif\n\n    };\n\n    /* At the beginning of the first pass, the inversion map will look like\n     * this on a 32-bit ASCII platform\n     *\n     *  [0]         0 .. 0x7F      TR_UNLISTED\n     *  [1]      0x80 .. 0x07FF    TR_UNLISTED\n     *  [2]    0x0800 .. 0xFFFF    TR_UNLISTED\n     *  [3]   0x10000 .. 0x1FFFFF  TR_UNLISTED\n     *  [4]  0x200000 .. 0x3FFFFFF TR_UNLISTED\n     *  [5] 0x4000000 .. INFTY     TR_UNLISTED\n     *\n     * Now suppose that we are compiling tr/A-Z/a-z/\n     * At the end of the first pass, the inversion map will be\n     *\n     *  [0]         0 .. 0x40      TR_UNLISTED\n     *  [1]      0x41 .. 0x5A      0x61\n     *  [2]      0x5B .. 0x7F      TR_UNLISTED\n     *  [3]      0x80 .. 0x07FF    TR_UNLISTED\n     *  [4]    0x0800 .. 0xFFFF    TR_UNLISTED\n     *  [5]   0x10000 .. 0x1FFFFF  TR_UNLISTED\n     *  [6]  0x200000 .. 0x3FFFFFF TR_UNLISTED\n     *  [7] 0x4000000 .. INFTY     TR_UNLISTED\n     *\n     * The second pass will merge adjacent ranges, squashing this down to\n     *\n     *  [0]    0 .. 0x40   TR_UNLISTED\n     *  [1] 0x41 .. 0x5A   0x61\n     *  [2] 0x5B .. INFTY  TR_UNLISTED\n     *\n     * The actual compiled code will be the traditional 257 byte lookup array\n     * with 26 bytes in the middle looking like\n     *\n     *      [ord \"A\"] => ord(\"a\")\n     *      [ord \"B\"] => ord(\"b\")\n     *      ...\n     *      [ord \"Z\"] => ord(\"z\")\n     *\n     * The 257th byte will contain information about the flags this tr is\n     * compiled with.  The remaining bytes will all contain TR_UNLISTED to\n     * indicate they are not to be touched by this operation.\n     *\n     * The reason the code space is partitioned is illustrated by the example\n     * oF compiling tr/\\x{7FF}-\\x{FFFE}/\\x{800}-\\x{FFFF}/\n     * This example effectively adds 1 to each code point in the lhs range.  By\n     * the end of the first pass, the inversion map will look like\n     *\n     *  [0]         0 .. 0x7F      TR_UNLISTED\n     *  [1]      0x80 .. 0x07FE    TR_UNLISTED\n     *  [2]    0x07FF              0x0800\n     *  [2]    0x0800 .. 0xFFFE    0x0801\n     *  [2]    0xFFFF              TR_UNLISTED\n     *  [3]   0x10000 .. 0x1FFFFF  TR_UNLISTED\n     *  [4]  0x200000 .. 0x3FFFFFF TR_UNLISTED\n     *  [5] 0x4000000 .. INFTY     TR_UNLISTED\n     *\n     * In this large range, just one code point, \\x{7FF} translates to a code\n     * point which has a longer representation than it does.  This means that a\n     * string containing that code point cannot be edited in place, a fact we\n     * need to know at compilation time.  The partitioning forces the algorithm\n     * to split off the code point into a separate element from the rest of the\n     * range.  This makes it easy to find such cases.  That information is\n     * noted, and the second pass squashes this down to\n     *\n     *  [0]      0 .. 0x07FE  TR_UNLISTED\n     *  [1] 0x07FF .. 0xFFFE  0x0800\n     *  [2] 0xFFFF .. INFTY   TR_UNLISTED\n     *\n     * This inversion map is what is used at runtime; the 257 element table\n     * would be useless here, and is not generated.\n     *\n     * Note that we determine here if there is any possible input that can't be\n     * done in place.  It might be that a particular input contains only code\n     * points that can be done in place.  One could examine at runtime to see,\n     * but this could be as expensive as just doing the copy.\n     */\n\n    PERL_ARGS_ASSERT_PMTRANS;\n\n    PL_hints |= HINT_BLOCK_SCOPE;\n\n    /* If /c, the search list is sorted and complemented.  This is now done by\n     * creating an inversion list from it, and then trivially inverting that.\n     * The previous implementation used qsort, but creating the list\n     * automatically keeps it sorted as we go along */\n    if (complement) {\n        UV start, end;\n        SV * inverted_tlist = _new_invlist(tlen);\n        Size_t temp_len;\n\n        DEBUG_y(PerlIO_printf(Perl_debug_log,\n                    \"%s: %d: tstr before inversion=\\n%s\\n\",\n                    __FILE__, __LINE__, _byte_dump_string(t, tend - t, 0)));\n\n        while (t < tend) {\n\n            /* Non-utf8 strings don't have ranges, so each character is listed\n             * out */\n            if (! tstr_utf8) {\n                inverted_tlist = add_cp_to_invlist(inverted_tlist, *t);\n                t++;\n            }\n            else {  /* But UTF-8 strings have been parsed in toke.c to have\n                 * ranges if appropriate. */\n                UV t_cp;\n                Size_t t_char_len;\n\n                /* Get the first character */\n                t_cp = valid_utf8_to_uvchr(t, &t_char_len);\n                t += t_char_len;\n\n                /* If the next byte indicates that this wasn't the first\n                 * element of a range, the range is just this one */\n                if (t >= tend || *t != RANGE_INDICATOR) {\n                    inverted_tlist = add_cp_to_invlist(inverted_tlist, t_cp);\n                }\n                else { /* Otherwise, ignore the indicator byte, and get the\n                          final element, and add the whole range */\n                    t++;\n                    t_cp_end = valid_utf8_to_uvchr(t, &t_char_len);\n                    t += t_char_len;\n\n                    inverted_tlist = _add_range_to_invlist(inverted_tlist,\n                                                      t_cp, t_cp_end);\n                }\n            }\n        } /* End of parse through tstr */\n\n        /* The inversion list is done; now invert it */\n        _invlist_invert(inverted_tlist);\n\n        /* Now go through the inverted list and create a new tstr for the rest\n         * of the routine to use.  Since the UTF-8 version can have ranges, and\n         * can be much more compact than the non-UTF-8 version, we create the\n         * string in UTF-8 even if not necessary.  (This is just an intermediate\n         * value that gets thrown away anyway.) */\n        invlist_iterinit(inverted_tlist);\n        inverted_tstr = newSVpvs(\"\");\n        while (invlist_iternext(inverted_tlist, &start, &end)) {\n            U8 temp[UTF8_MAXBYTES];\n            U8 * temp_end_pos;\n\n            /* IV_MAX keeps things from going out of bounds */\n            start = MIN(IV_MAX, start);\n            end   = MIN(IV_MAX, end);\n\n            temp_end_pos = uv_to_utf8(temp, start);\n            sv_catpvn(inverted_tstr, (char *) temp, temp_end_pos - temp);\n\n            if (start != end) {\n                sv_catpvf(inverted_tstr, \"%c\", RANGE_INDICATOR);\n                temp_end_pos = uv_to_utf8(temp, end);\n                sv_catpvn(inverted_tstr, (char *) temp, temp_end_pos - temp);\n            }\n        }\n\n        /* Set up so the remainder of the routine uses this complement, instead\n         * of the actual input */\n        t0 = t = (U8*)SvPV_const(inverted_tstr, temp_len);\n        tend = t0 + temp_len;\n        tstr_utf8 = TRUE;\n\n        SvREFCNT_dec_NN(inverted_tlist);\n    }\n\n    /* For non-/d, an empty rhs means to use the lhs */\n    if (rlen == 0 && ! del) {\n        r0 = t0;\n        rend = tend;\n        rstr_utf8  = tstr_utf8;\n    }\n\n    t_invlist = _new_invlist(1);\n\n    /* Initialize to a single range */\n    t_invlist = _add_range_to_invlist(t_invlist, 0, UV_MAX);\n\n    /* Below, we parse the (potentially adjusted) input, creating the inversion\n     * map.  This is done in two passes.  The first pass is just to determine\n     * if the transliteration can be done in-place.  It can be done in place if\n     * no possible inputs result in the replacement taking up more bytes than\n     * the input.  To figure that out, in the first pass we start with all the\n     * possible code points partitioned into ranges so that every code point in\n     * a range occupies the same number of UTF-8 bytes as every other code\n     * point in the range.  Constructing the inversion map doesn't merge ranges\n     * together, but can split them into multiple ones.  Given the starting\n     * partition, the ending state will also have the same characteristic,\n     * namely that each code point in each partition requires the same number\n     * of UTF-8 bytes to represent as every other code point in the same\n     * partition.\n     *\n     * This partitioning has been pre-compiled.  Copy it to initialize */\n    len = C_ARRAY_LENGTH(PL_partition_by_byte_length);\n    invlist_extend(t_invlist, len);\n    t_array = invlist_array(t_invlist);\n    Copy(PL_partition_by_byte_length, t_array, len, UV);\n    invlist_set_len(t_invlist, len, *(get_invlist_offset_addr(t_invlist)));\n    Newx(r_map, len + 1, UV);\n\n    /* The inversion map the first pass creates could be used as-is, but\n     * generally would be larger and slower to run than the output of the\n     * second pass.  */\n\n    for (pass2 = 0; pass2 < 2; pass2++) {\n        if (pass2) {\n\n            DEBUG_yv(PerlIO_printf(Perl_debug_log, \"After pass1: \\n\"));\n            DEBUG_yv(invmap_dump(t_invlist, r_map));\n\n            /* In the second pass, we start with a single range */\n            t_invlist = _add_range_to_invlist(t_invlist, 0, UV_MAX);\n            len = 1;\n            t_array = invlist_array(t_invlist);\n        }\n\n/* In EBCDIC, the byte length is not monotonically increasing for code points\n * below 256, which the algorithm below requires.  To accommodate that, the\n * macro CP_ADJUST defined below converts those code points to ASCII in the\n * first pass and does nothing in the second.  This works because the first\n * pass is looking only for the existence of anomalies; and not the specific\n * code point values.  The growth factor is going to be 2 regardless, because\n * one byte can become two.  Only code points below 256 differ between the two\n * character sets in this regard.  For these, we also can't have any ranges, as\n * they have to be individually converted. */\n#ifdef EBCDIC\n#  define CP_ADJUST(x)          ((pass2) ? (x) : NATIVE_TO_UNI(x))\n#  define FORCE_RANGE_LEN_1(x)  ((pass2) ? 0 : ((x) < 256))\n#  define CP_SKIP(x)            ((pass2) ? UVCHR_SKIP(x) : OFFUNISKIP(x))\n#  define CP_VARIANT(x)         ((pass2) ? ! UVCHR_IS_INVARIANT(x)          \\\n                                         : ! OFFUNI_IS_INVARIANT(x))\n#else\n#  define CP_ADJUST(x)          (x)\n#  define FORCE_RANGE_LEN_1(x)  0\n#  define CP_SKIP(x)            UVCHR_SKIP(x)\n#  define CP_VARIANT(x)       ! UVCHR_IS_INVARIANT(x)\n#endif\n\n        /* And the mapping of each of the ranges is initialized.  Initially,\n         * everything is TR_UNLISTED. */\n        for (i = 0; i < len; i++) {\n            r_map[i] = TR_UNLISTED;\n        }\n\n        t = t0;\n        t_count = 0;\n        r = r0;\n        r_count = 0;\n        t_range_count = r_range_count = 0;\n\n        DEBUG_y(PerlIO_printf(Perl_debug_log, \"%s: %d:\\ntstr=%s\\n\",\n                    __FILE__, __LINE__, _byte_dump_string(t, tend - t, 0)));\n        DEBUG_y(PerlIO_printf(Perl_debug_log, \"rstr=%s\\n\",\n                                        _byte_dump_string(r, rend - r, 0)));\n        DEBUG_y(PerlIO_printf(Perl_debug_log, \"/c=%d; /s=%d; /d=%d\\n\"\n                                              \" At the beginning of pass %u\\n\",\n                                              complement, squash, del,\n                                              pass2 + 1));\n        DEBUG_y(invmap_dump(t_invlist, r_map));\n\n        /* Now go through the search list constructing an inversion map.  The\n         * input is not necessarily in any particular order.  Making it an\n         * inversion map orders it, potentially simplifying, and makes it easy\n         * to deal with at run time.  This is the only place in core that\n         * generates an inversion map; if others were introduced, it might be\n         * better to create general purpose routines to handle them.\n         * (Inversion lists are created in perl in other places.)\n         */\n                           /* Finish up range started in what otherwise would\n                            * have been the final iteration */\n        while (t < tend || t_range_count > 0) {\n            bool adjacent_to_range_above = FALSE;\n            bool adjacent_to_range_below = FALSE;\n\n            bool merge_with_range_above = FALSE;\n            bool merge_with_range_below = FALSE;\n\n            UV span, invmap_range_length_remaining;\n            SSize_t j;\n            Size_t i;\n\n            /* If we are in the middle of processing a range in the 'target'\n             * side, the previous iteration has set us up.  Otherwise, look at\n             * the next character in the search list */\n            if (t_range_count <= 0) {\n                if (! tstr_utf8) {\n\n                    /* Here, not in the middle of a range, and not UTF-8.  The\n                     * next code point is the single byte where we're at */\n                    t_cp = CP_ADJUST(*t);\n                    t_range_count = 1;\n                    t++;\n                }\n                else {\n                    Size_t t_char_len;\n\n                    /* Here, not in the middle of a range, and is UTF-8.  The\n                     * next code point is the next UTF-8 char in the input.  We\n                     * know the input is valid, because the toker constructed\n                     * it */\n                    t_cp = CP_ADJUST(valid_utf8_to_uvchr(t, &t_char_len));\n                    t += t_char_len;\n\n                    /* UTF-8 strings (only) have been parsed in toke.c to have\n                     * ranges.  See if the next byte indicates that this was\n                     * the first element of a range.  If so, get the final\n                     * element and calculate the range size.  If not, the range\n                     * size is 1 */\n                    if (   t < tend && *t == RANGE_INDICATOR\n                        && ! FORCE_RANGE_LEN_1(t_cp))\n                    {\n                        t++;\n                        t_range_count = valid_utf8_to_uvchr(t, &t_char_len)\n                                      - t_cp + 1;\n                        t += t_char_len;\n                    }\n                    else {\n                        t_range_count = 1;\n                    }\n                }\n\n                if (CP_VARIANT(t_cp)) {\n                    has_utf8_variant = true;\n                }\n\n                /* Count the total number of listed code points * */\n                t_count += t_range_count;\n            }\n\n            /* Similarly, get the next character in the replacement list */\n            if (r_range_count <= 0) {\n                if (r >= rend) {\n\n                    /* But if we've exhausted the rhs, there is nothing to map\n                     * to, except the special handling one, and we make the\n                     * range the same size as the lhs one. */\n                    r_cp = TR_SPECIAL_HANDLING;\n                    r_range_count = t_range_count;\n\n#ifdef DEBUGGING\n                    if (DEBUG_y_TEST && ! del) {\n                        PerlIO_printf(Perl_debug_log,\n                                          \"final_map =%\" UVXf \"\\n\", final_map);\n                    }\n#endif\n                }\n                else {\n                    if (! rstr_utf8) {\n                        r_cp = CP_ADJUST(*r);\n                        r_range_count = 1;\n                        r++;\n                    }\n                    else {\n                        Size_t r_char_len;\n\n                        r_cp = CP_ADJUST(valid_utf8_to_uvchr(r, &r_char_len));\n                        r += r_char_len;\n                        if (   r < rend && *r == RANGE_INDICATOR\n                            && ! FORCE_RANGE_LEN_1(r_cp))\n                        {\n                            r++;\n                            r_range_count = valid_utf8_to_uvchr(r,\n                                                    &r_char_len) - r_cp + 1;\n                            r += r_char_len;\n                        }\n                        else {\n                            r_range_count = 1;\n                        }\n                    }\n\n                    if (r_cp == TR_SPECIAL_HANDLING) {\n                        r_range_count = t_range_count;\n                    }\n                    else if (CP_VARIANT(r_cp)) {\n                        has_utf8_variant = true;\n                    }\n\n                    /* This is the final character so far */\n                    final_map = r_cp + r_range_count - 1;\n\n                    r_count += r_range_count;\n                }\n            }\n\n            /* Here, we have the next things ready in both sides.  They are\n             * potentially ranges.  We try to process as big a chunk as\n             * possible at once, but the lhs and rhs must be synchronized, so\n             * things like tr/A-Z/a-ij-z/ will need to be processed in 2 chunks\n             * */\n            min_range_count = MIN(t_range_count, r_range_count);\n\n            /* Search the inversion list for the entry that contains the input\n             * code point <cp>.  The inversion map was initialized to cover the\n             * entire range of possible inputs, so this should not fail.  So\n             * the return value is the index into the list's array of the range\n             * that contains <cp>, that is, 'i' such that\n             *      array[i] <= cp < * array[i+1] */\n            j = _invlist_search(t_invlist, t_cp);\n            assert(j >= 0);\n            i = j;\n\n            /* Here, the data structure might look like:\n             *\n             * index    t   r     Meaning\n             * [i-1]    J   j   # J-L => j-l\n             * [i]      M  -1   # M => default; as do N, O, P, Q\n             * [i+1]    R   x   # R => x, S => x+1, T => x+2\n             * [i+2]    U   y   # U => y, V => y+1, ...\n             * ...\n             * [-1]     Z  -1   # Z => default; as do Z+1, ... infinity\n             *\n             * where 'x' and 'y' above are not to be taken literally.\n             *\n             * The maximum chunk we can handle in this loop iteration, is the\n             * smallest of the three components: the lhs 't_', the rhs 'r_',\n             * and the remainder of the range in element [i].  (In pass 1, that\n             * range will have everything in it be of the same class; we can't\n             * cross into another class.)  'min_range_count' already contains\n             * the smallest of the first two values.  The final one is\n             * irrelevant if the map is to the special indicator */\n\n            invmap_range_length_remaining = (i + 1 < len)\n                                            ? t_array[i+1] - t_cp\n                                            : IV_MAX - t_cp;\n            span = MAX(1, MIN(min_range_count, invmap_range_length_remaining));\n\n            /* The end point of this chunk is where we are, plus the span, but\n             * never larger than the platform's infinity */\n            t_cp_end = MIN(IV_MAX, t_cp + span - 1);\n\n            if (r_cp == TR_SPECIAL_HANDLING) {\n\n                /* If unmatched lhs code points map to the final map, use that\n                 * value.  This being set to TR_SPECIAL_HANDLING indicates that\n                 * we don't have a final map: unmatched lhs code points are\n                 * simply deleted */\n                r_cp_end = (del) ? TR_SPECIAL_HANDLING : final_map;\n            }\n            else {\n                r_cp_end = MIN(IV_MAX, r_cp + span - 1);\n\n                /* If something on the lhs is below 256, and something on the\n                 * rhs is above, there is a potential mapping here across that\n                 * boundary.  Indeed the only way there isn't is if both sides\n                 * start at the same point.  That means they both cross at the\n                 * same time.  But otherwise one crosses before the other */\n                if (t_cp < 256 && r_cp_end > 255 && r_cp != t_cp) {\n                    can_force_utf8 = TRUE;\n                }\n            }\n\n            /* If a character appears in the search list more than once, the\n             * 2nd and succeeding occurrences are ignored, so only do this\n             * range if haven't already processed this character.  (The range\n             * has been set up so that all members in it will be of the same\n             * ilk) */\n            if (r_map[i] == TR_UNLISTED) {\n                DEBUG_yv(PerlIO_printf(Perl_debug_log,\n                    \"Processing %\" UVxf \"-%\" UVxf \" => %\" UVxf \"-%\" UVxf \"\\n\",\n                    t_cp, t_cp_end, r_cp, r_cp_end));\n\n                /* This is the first definition for this chunk, hence is valid\n                 * and needs to be processed.  Here and in the comments below,\n                 * we use the above sample data.  The t_cp chunk must be any\n                 * contiguous subset of M, N, O, P, and/or Q.\n                 *\n                 * In the first pass, calculate if there is any possible input\n                 * string that has a character whose transliteration will be\n                 * longer than it.  If none, the transliteration may be done\n                 * in-place, as it can't write over a so-far unread byte.\n                 * Otherwise, a copy must first be made.  This could be\n                 * expensive for long inputs.\n                 *\n                 * In the first pass, the t_invlist has been partitioned so\n                 * that all elements in any single range have the same number\n                 * of bytes in their UTF-8 representations.  And the r space is\n                 * either a single byte, or a range of strictly monotonically\n                 * increasing code points.  So the final element in the range\n                 * will be represented by no fewer bytes than the initial one.\n                 * That means that if the final code point in the t range has\n                 * at least as many bytes as the final code point in the r,\n                 * then all code points in the t range have at least as many\n                 * bytes as their corresponding r range element.  But if that's\n                 * not true, the transliteration of at least the final code\n                 * point grows in length.  As an example, suppose we had\n                 *      tr/\\x{fff0}-\\x{fff1}/\\x{ffff}-\\x{10000}/\n                 * The UTF-8 for all but 10000 occupies 3 bytes on ASCII\n                 * platforms.  We have deliberately set up the data structure\n                 * so that any range in the lhs gets split into chunks for\n                 * processing, such that every code point in a chunk has the\n                 * same number of UTF-8 bytes.  We only have to check the final\n                 * code point in the rhs against any code point in the lhs. */\n                if ( ! pass2\n                    && r_cp_end != TR_SPECIAL_HANDLING\n                    && CP_SKIP(t_cp_end) < CP_SKIP(r_cp_end))\n                {\n                    /* Here, we will need to make a copy of the input string\n                     * before doing the transliteration.  The worst possible\n                     * case is an expansion ratio of 14:1. This is rare, and\n                     * we'd rather allocate only the necessary amount of extra\n                     * memory for that copy.  We can calculate the worst case\n                     * for this particular transliteration by keeping track of\n                     * the expansion factor for each range.\n                     *\n                     * Consider tr/\\xCB/\\X{E000}/.  The maximum expansion\n                     * factor is 1 byte going to 3 if the target string is not\n                     * UTF-8, but 2 bytes going to 3 if it is in UTF-8.  We\n                     * could pass two different values so doop could choose\n                     * based on the UTF-8ness of the target.  But khw thinks\n                     * (perhaps wrongly) that is overkill.  It is used only to\n                     * make sure we malloc enough space.\n                     *\n                     * If no target string can force the result to be UTF-8,\n                     * then we don't have to worry about the case of the target\n                     * string not being UTF-8 */\n                    NV t_size = (can_force_utf8 && t_cp < 256)\n                                ? 1\n                                : CP_SKIP(t_cp_end);\n                    NV ratio = CP_SKIP(r_cp_end) / t_size;\n\n                    o->op_private |= OPpTRANS_GROWS;\n\n                    /* Now that we know it grows, we can keep track of the\n                     * largest ratio */\n                    if (ratio > max_expansion) {\n                        max_expansion = ratio;\n                        DEBUG_y(PerlIO_printf(Perl_debug_log,\n                                        \"New expansion factor: %\" NVgf \"\\n\",\n                                        max_expansion));\n                    }\n                }\n\n                /* The very first range is marked as adjacent to the\n                 * non-existent range below it, as it causes things to \"just\n                 * work\" (TradeMark)\n                 *\n                 * If the lowest code point in this chunk is M, it adjoins the\n                 * J-L range */\n                if (t_cp == t_array[i]) {\n                    adjacent_to_range_below = TRUE;\n\n                    /* And if the map has the same offset from the beginning of\n                     * the range as does this new code point (or both are for\n                     * TR_SPECIAL_HANDLING), this chunk can be completely\n                     * merged with the range below.  EXCEPT, in the first pass,\n                     * we don't merge ranges whose UTF-8 byte representations\n                     * have different lengths, so that we can more easily\n                     * detect if a replacement is longer than the source, that\n                     * is if it 'grows'.  But in the 2nd pass, there's no\n                     * reason to not merge */\n                    if (   (i > 0 && (   pass2\n                                      || CP_SKIP(t_array[i-1])\n                                                            == CP_SKIP(t_cp)))\n                        && (   (   r_cp == TR_SPECIAL_HANDLING\n                                && r_map[i-1] == TR_SPECIAL_HANDLING)\n                            || (   r_cp != TR_SPECIAL_HANDLING\n                                && r_cp - r_map[i-1] == t_cp - t_array[i-1])))\n                    {\n                        merge_with_range_below = TRUE;\n                    }\n                }\n\n                /* Similarly, if the highest code point in this chunk is 'Q',\n                 * it adjoins the range above, and if the map is suitable, can\n                 * be merged with it */\n                if (    t_cp_end >= IV_MAX - 1\n                    || (   i + 1 < len\n                        && t_cp_end + 1 == t_array[i+1]))\n                {\n                    adjacent_to_range_above = TRUE;\n                    if (i + 1 < len)\n                    if (    (   pass2\n                             || CP_SKIP(t_cp) == CP_SKIP(t_array[i+1]))\n                        && (   (   r_cp == TR_SPECIAL_HANDLING\n                                && r_map[i+1] == (UV) TR_SPECIAL_HANDLING)\n                            || (   r_cp != TR_SPECIAL_HANDLING\n                                && r_cp_end == r_map[i+1] - 1)))\n                    {\n                        merge_with_range_above = TRUE;\n                    }\n                }\n\n                if (merge_with_range_below && merge_with_range_above) {\n\n                    /* Here the new chunk looks like M => m, ... Q => q; and\n                     * the range above is like R => r, ....  Thus, the [i-1]\n                     * and [i+1] ranges should be seamlessly melded so the\n                     * result looks like\n                     *\n                     * [i-1]    J   j   # J-T => j-t\n                     * [i]      U   y   # U => y, V => y+1, ...\n                     * ...\n                     * [-1]     Z  -1   # Z => default; as do Z+1, ... infinity\n                     */\n                    Move(t_array + i + 2, t_array + i, len - i - 2, UV);\n                    Move(r_map   + i + 2, r_map   + i, len - i - 2, UV);\n                    len -= 2;\n                    invlist_set_len(t_invlist,\n                                    len,\n                                    *(get_invlist_offset_addr(t_invlist)));\n                }\n                else if (merge_with_range_below) {\n\n                    /* Here the new chunk looks like M => m, .... But either\n                     * (or both) it doesn't extend all the way up through Q; or\n                     * the range above doesn't start with R => r. */\n                    if (! adjacent_to_range_above) {\n\n                        /* In the first case, let's say the new chunk extends\n                         * through O.  We then want:\n                         *\n                         * [i-1]    J   j   # J-O => j-o\n                         * [i]      P  -1   # P => -1, Q => -1\n                         * [i+1]    R   x   # R => x, S => x+1, T => x+2\n                         * [i+2]    U   y   # U => y, V => y+1, ...\n                         * ...\n                         * [-1]     Z  -1   # Z => default; as do Z+1, ...\n                         *                                            infinity\n                         */\n                        t_array[i] = t_cp_end + 1;\n                        r_map[i] = TR_UNLISTED;\n                    }\n                    else { /* Adjoins the range above, but can't merge with it\n                              (because 'x' is not the next map after q) */\n                        /*\n                         * [i-1]    J   j   # J-Q => j-q\n                         * [i]      R   x   # R => x, S => x+1, T => x+2\n                         * [i+1]    U   y   # U => y, V => y+1, ...\n                         * ...\n                         * [-1]     Z  -1   # Z => default; as do Z+1, ...\n                         *                                          infinity\n                         */\n\n                        Move(t_array + i + 1, t_array + i, len - i - 1, UV);\n                        Move(r_map + i + 1, r_map + i, len - i - 1, UV);\n                        len--;\n                        invlist_set_len(t_invlist, len,\n                                        *(get_invlist_offset_addr(t_invlist)));\n                    }\n                }\n                else if (merge_with_range_above) {\n\n                    /* Here the new chunk ends with Q => q, and the range above\n                     * must start with R => r, so the two can be merged. But\n                     * either (or both) the new chunk doesn't extend all the\n                     * way down to M; or the mapping of the final code point\n                     * range below isn't m */\n                    if (! adjacent_to_range_below) {\n\n                        /* In the first case, let's assume the new chunk starts\n                         * with P => p.  Then, because it's merge-able with the\n                         * range above, that range must be R => r.  We want:\n                         *\n                         * [i-1]    J   j   # J-L => j-l\n                         * [i]      M  -1   # M => -1, N => -1\n                         * [i+1]    P   p   # P-T => p-t\n                         * [i+2]    U   y   # U => y, V => y+1, ...\n                         * ...\n                         * [-1]     Z  -1   # Z => default; as do Z+1, ...\n                         *                                          infinity\n                         */\n                        t_array[i+1] = t_cp;\n                        r_map[i+1] = r_cp;\n                    }\n                    else { /* Adjoins the range below, but can't merge with it\n                            */\n                        /*\n                         * [i-1]    J   j   # J-L => j-l\n                         * [i]      M   x   # M-T => x-5 .. x+2\n                         * [i+1]    U   y   # U => y, V => y+1, ...\n                         * ...\n                         * [-1]     Z  -1   # Z => default; as do Z+1, ...\n                         *                                          infinity\n                         */\n                        Move(t_array + i + 1, t_array + i, len - i - 1, UV);\n                        Move(r_map   + i + 1, r_map   + i, len - i - 1, UV);\n                        len--;\n                        t_array[i] = t_cp;\n                        r_map[i] = r_cp;\n                        invlist_set_len(t_invlist, len,\n                                        *(get_invlist_offset_addr(t_invlist)));\n                    }\n                }\n                else if (adjacent_to_range_below && adjacent_to_range_above) {\n                    /* The new chunk completely fills the gap between the\n                     * ranges on either side, but can't merge with either of\n                     * them.\n                     *\n                     * [i-1]    J   j   # J-L => j-l\n                     * [i]      M   z   # M => z, N => z+1 ... Q => z+4\n                     * [i+1]    R   x   # R => x, S => x+1, T => x+2\n                     * [i+2]    U   y   # U => y, V => y+1, ...\n                     * ...\n                     * [-1]     Z  -1   # Z => default; as do Z+1, ... infinity\n                     */\n                    r_map[i] = r_cp;\n                }\n                else if (adjacent_to_range_below) {\n                    /* The new chunk adjoins the range below, but not the range\n                     * above, and can't merge.  Let's assume the chunk ends at\n                     * O.\n                     *\n                     * [i-1]    J   j   # J-L => j-l\n                     * [i]      M   z   # M => z, N => z+1, O => z+2\n                     * [i+1]    P   -1  # P => -1, Q => -1\n                     * [i+2]    R   x   # R => x, S => x+1, T => x+2\n                     * [i+3]    U   y   # U => y, V => y+1, ...\n                     * ...\n                     * [-w]     Z  -1   # Z => default; as do Z+1, ... infinity\n                     */\n                    invlist_extend(t_invlist, len + 1);\n                    t_array = invlist_array(t_invlist);\n                    Renew(r_map, len + 1, UV);\n\n                    Move(t_array + i + 1, t_array + i + 2, len - i - 1, UV);\n                    Move(r_map + i + 1,   r_map   + i + 2, len - i - 1, UV);\n                    r_map[i] = r_cp;\n                    t_array[i+1] = t_cp_end + 1;\n                    r_map[i+1] = TR_UNLISTED;\n                    len++;\n                    invlist_set_len(t_invlist, len,\n                                    *(get_invlist_offset_addr(t_invlist)));\n                }\n                else if (adjacent_to_range_above) {\n                    /* The new chunk adjoins the range above, but not the range\n                     * below, and can't merge.  Let's assume the new chunk\n                     * starts at O\n                     *\n                     * [i-1]    J   j   # J-L => j-l\n                     * [i]      M  -1   # M => default, N => default\n                     * [i+1]    O   z   # O => z, P => z+1, Q => z+2\n                     * [i+2]    R   x   # R => x, S => x+1, T => x+2\n                     * [i+3]    U   y   # U => y, V => y+1, ...\n                     * ...\n                     * [-1]     Z  -1   # Z => default; as do Z+1, ... infinity\n                     */\n                    invlist_extend(t_invlist, len + 1);\n                    t_array = invlist_array(t_invlist);\n                    Renew(r_map, len + 1, UV);\n\n                    Move(t_array + i + 1, t_array + i + 2, len - i - 1, UV);\n                    Move(r_map   + i + 1, r_map   + i + 2, len - i - 1, UV);\n                    t_array[i+1] = t_cp;\n                    r_map[i+1] = r_cp;\n                    len++;\n                    invlist_set_len(t_invlist, len,\n                                    *(get_invlist_offset_addr(t_invlist)));\n                }\n                else {\n                    /* The new chunk adjoins neither the range above, nor the\n                     * range below.  Lets assume it is N..P => n..p\n                     *\n                     * [i-1]    J   j   # J-L => j-l\n                     * [i]      M  -1   # M => default\n                     * [i+1]    N   n   # N..P => n..p\n                     * [i+2]    Q  -1   # Q => default\n                     * [i+3]    R   x   # R => x, S => x+1, T => x+2\n                     * [i+4]    U   y   # U => y, V => y+1, ...\n                     * ...\n                     * [-1]     Z  -1   # Z => default; as do Z+1, ... infinity\n                     */\n\n                    DEBUG_yv(PerlIO_printf(Perl_debug_log,\n                                        \"Before fixing up: len=%d, i=%d\\n\",\n                                        (int) len, (int) i));\n                    DEBUG_yv(invmap_dump(t_invlist, r_map));\n\n                    invlist_extend(t_invlist, len + 2);\n                    t_array = invlist_array(t_invlist);\n                    Renew(r_map, len + 2, UV);\n\n                    Move(t_array + i + 1,\n                         t_array + i + 2 + 1, len - i - (2 - 1), UV);\n                    Move(r_map   + i + 1,\n                         r_map   + i + 2 + 1, len - i - (2 - 1), UV);\n\n                    len += 2;\n                    invlist_set_len(t_invlist, len,\n                                    *(get_invlist_offset_addr(t_invlist)));\n\n                    t_array[i+1] = t_cp;\n                    r_map[i+1] = r_cp;\n\n                    t_array[i+2] = t_cp_end + 1;\n                    r_map[i+2] = TR_UNLISTED;\n                }\n                DEBUG_yv(PerlIO_printf(Perl_debug_log,\n                          \"After iteration: span=%\" UVuf \", t_range_count=%\"\n                          UVuf \" r_range_count=%\" UVuf \"\\n\",\n                          span, t_range_count, r_range_count));\n                DEBUG_yv(invmap_dump(t_invlist, r_map));\n            } /* End of this chunk needs to be processed */\n\n            /* Done with this chunk. */\n            t_cp += span;\n            if (t_cp >= IV_MAX) {\n                break;\n            }\n            t_range_count -= span;\n            if (r_cp != TR_SPECIAL_HANDLING) {\n                r_cp += span;\n                r_range_count -= span;\n            }\n            else {\n                r_range_count = 0;\n            }\n\n        } /* End of loop through the search list */\n\n        /* We don't need an exact count, but we do need to know if there is\n         * anything left over in the replacement list.  So, just assume it's\n         * one byte per character */\n        if (rend > r) {\n            r_count++;\n        }\n    } /* End of passes */\n\n    SvREFCNT_dec(inverted_tstr);\n\n    DEBUG_y(PerlIO_printf(Perl_debug_log, \"After everything: \\n\"));\n    DEBUG_y(invmap_dump(t_invlist, r_map));\n\n    /* We now have normalized the input into an inversion map.\n     *\n     * See if the lhs and rhs are equivalent.  If so, this tr/// is a no-op\n     * except for the count, and streamlined runtime code can be used */\n    if (!del && !squash) {\n\n        /* They are identical if they point to the same address, or if\n         * everything maps to UNLISTED or to itself.  This catches things that\n         * not looking at the normalized inversion map doesn't catch, like\n         * tr/aa/ab/ or tr/\\x{100}-\\x{104}/\\x{100}-\\x{102}\\x{103}-\\x{104}  */\n        if (r0 != t0) {\n            for (i = 0; i < len; i++) {\n                if (r_map[i] != TR_UNLISTED && r_map[i] != t_array[i]) {\n                    goto done_identical_check;\n                }\n            }\n        }\n\n        /* Here have gone through entire list, and didn't find any\n         * non-identical mappings */\n        o->op_private |= OPpTRANS_IDENTICAL;\n\n      done_identical_check: ;\n    }\n\n    t_array = invlist_array(t_invlist);\n\n    /* If has components above 255, we generally need to use the inversion map\n     * implementation */\n    if (   can_force_utf8\n        || (   len > 0\n            && t_array[len-1] > 255\n                 /* But if the final range is 0x100-INFINITY and is a special\n                  * mapping, the table implementation can handle it */\n            && ! (   t_array[len-1] == 256\n                  && (   r_map[len-1] == TR_UNLISTED\n                      || r_map[len-1] == TR_SPECIAL_HANDLING))))\n    {\n        SV* r_map_sv;\n        SV* temp_sv;\n\n        /* A UTF-8 op is generated, indicated by this flag.  This op is an\n         * sv_op */\n        o->op_private |= OPpTRANS_USE_SVOP;\n\n        if (can_force_utf8) {\n            o->op_private |= OPpTRANS_CAN_FORCE_UTF8;\n        }\n\n        /* The inversion map is pushed; first the list. */\n        invmap = MUTABLE_AV(newAV());\n\n        SvREADONLY_on(t_invlist);\n        av_push(invmap, t_invlist);\n\n        /* 2nd is the mapping */\n        r_map_sv = newSVpvn((char *) r_map, len * sizeof(UV));\n        SvREADONLY_on(r_map_sv);\n        av_push(invmap, r_map_sv);\n\n        /* 3rd is the max possible expansion factor */\n        temp_sv = newSVnv(max_expansion);\n        SvREADONLY_on(temp_sv);\n        av_push(invmap, temp_sv);\n\n        /* Characters that are in the search list, but not in the replacement\n         * list are mapped to the final character in the replacement list */\n        if (! del && r_count < t_count) {\n            temp_sv = newSVuv(final_map);\n            SvREADONLY_on(temp_sv);\n            av_push(invmap, temp_sv);\n        }\n\n#ifdef USE_ITHREADS\n        cPADOPo->op_padix = pad_alloc(OP_TRANS, SVf_READONLY);\n        SvREFCNT_dec(PAD_SVl(cPADOPo->op_padix));\n        PAD_SETSV(cPADOPo->op_padix, (SV *) invmap);\n        SvPADTMP_on(invmap);\n        SvREADONLY_on(invmap);\n#else\n        cSVOPo->op_sv = (SV *) invmap;\n#endif\n\n    }\n    else {\n        OPtrans_map *tbl;\n        unsigned short i;\n\n        /* The OPtrans_map struct already contains one slot; hence the -1. */\n        SSize_t struct_size = sizeof(OPtrans_map)\n                            + (256 - 1 + 1)*sizeof(short);\n\n        /* Non-utf8 case: set o->op_pv to point to a simple 256+ entry lookup\n         * table. Entries with the value TR_UNMAPPED indicate chars not to be\n         * translated, while TR_DELETE indicates a search char without a\n         * corresponding replacement char under /d.\n         *\n         * In addition, an extra slot at the end is used to store the final\n         * repeating char, or TR_R_EMPTY under an empty replacement list, or\n         * TR_DELETE under /d; which makes the runtime code easier. */\n\n        /* Indicate this is an op_pv */\n        o->op_private &= ~OPpTRANS_USE_SVOP;\n\n        /* Indicate if no variants, but complementing means the runtime has to\n         * consider variants anyway */\n        if (! complement && ! has_utf8_variant) {\n            o->op_private |= OPpTRANS_ONLY_UTF8_INVARIANTS;\n        }\n\n        tbl = (OPtrans_map*)PerlMemShared_calloc(struct_size, 1);\n        tbl->size = 256;\n        cPVOPo->op_pv = (char*)tbl;\n\n        for (i = 0; i < len; i++) {\n            STATIC_ASSERT_DECL(TR_SPECIAL_HANDLING == TR_DELETE);\n            short upper = i >= len - 1 ? 256 : (short) t_array[i+1];\n            short to = (short) r_map[i];\n            short j;\n            bool do_increment = TRUE;\n\n            /* Any code points above our limit should be irrelevant */\n            if (t_array[i] >= tbl->size) break;\n\n            /* Set up the map */\n            if (to == (short) TR_SPECIAL_HANDLING && ! del) {\n                to = (short) final_map;\n                do_increment = FALSE;\n            }\n            else if (to < 0) {\n                do_increment = FALSE;\n            }\n\n            /* Create a map for everything in this range.  The value increases\n             * except for the special cases */\n            for (j = (short) t_array[i]; j < upper; j++) {\n                tbl->map[j] = to;\n                if (do_increment) to++;\n            }\n        }\n\n        tbl->map[tbl->size] = del\n                              ? (short) TR_DELETE\n                              : (short) rlen\n                                ? (short) final_map\n                                : (short) TR_R_EMPTY;\n#ifdef DEBUGGING\n        if (DEBUG_y_TEST) {\n            PerlIO_printf(Perl_debug_log,\"%s: %d\\n\", __FILE__, __LINE__);\n            for (i = 0; i < tbl->size; i++) {\n                if (tbl->map[i] < 0) {\n                    PerlIO_printf(Perl_debug_log,\" %02x=>%d\",\n                                                    (unsigned) i, tbl->map[i]);\n                }\n                else {\n                    PerlIO_printf(Perl_debug_log,\" %02x=>%02x\",\n                                                    (unsigned) i, tbl->map[i]);\n                }\n                if ((i+1) % 8 == 0 || i + 1 == (short) tbl->size) {\n                    PerlIO_printf(Perl_debug_log,\"\\n\");\n                }\n            }\n            PerlIO_printf(Perl_debug_log,\"Final map 0x%x=>%02x\\n\",\n                                    (unsigned) tbl->size, tbl->map[tbl->size]);\n        };\n#endif\n\n        SvREFCNT_dec(t_invlist);\n\n#if 0   /* code that added excess above-255 chars at the end of the table, in\n           case we ever want to not use the inversion map implementation for\n           this */\n\n        ASSUME(j <= rlen);\n        excess = rlen - j;\n\n        if (excess) {\n            /* More replacement chars than search chars:\n             * store excess replacement chars at end of main table.\n             */\n\n            struct_size += excess;\n            tbl = (OPtrans_map*)PerlMemShared_realloc(tbl,\n                        struct_size + excess * sizeof(short));\n            tbl->size += excess;\n            cPVOPo->op_pv = (char*)tbl;\n\n            for (i = 0; i < excess; i++)\n                tbl->map[i + 256] = r[j+i];\n        }\n        else {\n            /* no more replacement chars than search chars */\n        }\n#endif\n\n    }\n\n    DEBUG_y(PerlIO_printf(Perl_debug_log,\n            \"/d=%d, /s=%d, /c=%d, identical=%d, grows=%d,\"\n            \" use_svop=%d, can_force_utf8=%d,\\nexpansion=%\" NVgf \"\\n\",\n            del, squash, complement,\n            cBOOL(o->op_private & OPpTRANS_IDENTICAL),\n            cBOOL(o->op_private & OPpTRANS_USE_SVOP),\n            (o->op_private & OPpTRANS_MASK) == OPpTRANS_GROWS,\n            (o->op_private & OPpTRANS_MASK) == OPpTRANS_CAN_FORCE_UTF8,\n            max_expansion));\n\n    Safefree(r_map);\n\n    if(del && rlen != 0 && r_count == t_count) {\n        ck_warner(packWARN(WARN_MISC), \"Useless use of /d modifier in transliteration operator\");\n    } else if(r_count > t_count) {\n        ck_warner(packWARN(WARN_MISC), \"Replacement list is longer than search list\");\n    }\n\n    op_free(expr);\n    op_free(repl);\n\n    return o;\n}\n\n\n/*\n=for apidoc newPMOP\n\nConstructs, checks, and returns an op of any pattern matching type.\nC<type> is the opcode.  C<flags> gives the eight bits of C<op_flags>\nand, shifted up eight bits, the eight bits of C<op_private>.\n\n=cut\n*/\n\nOP *", "target": 1}
{"idx": 117, "func": "S_pmtrans(pTHX_ OP *o, OP *expr, OP *repl)\n{\n    /* This function compiles a tr///, from data gathered from toke.c, into a\n     * form suitable for use by do_trans() in doop.c at runtime.\n     *\n     * It has two passes.  The second is mainly to streamline the result of the\n     * first pass, resulting in less memory usage and faster runtime execution\n     * besides.\n     *\n     * The first pass normalizes the data, while discarding extraneous inputs.\n     * The normalization allows for complete analysis, and avoids some false\n     * negatives and positives earlier versions of this code had.\n     *\n     * The normalizd form is an inversion map (described below in detail).\n     * This is essentially the compiled form for tr///'s that require UTF-8,\n     * There is a different form for those that don't need UTF-8, identical to\n     * what's been in use for many perl versions, except that it doesn't handle\n     * some edge cases that it used to, involving code points above 255.  The\n     * UTF-8 form now handles these.  (This could be changed with extra coding\n     * should it shown to be desirable.)\n     *\n     * If the complement (/c) option is specified, the lhs string (tstr) is\n     * parsed into an inversion list.  Complementing these is trivial.  Then a\n     * complemented tstr is built from that, and used thenceforth.  This hides\n     * the fact that it was complemented from almost all successive code.\n     *\n     * One of the important characteristics to know about the input is whether\n     * the transliteration may be done in place, or does a temporary need to be\n     * allocated, then copied.  If the replacement for every character in every\n     * possible string takes up no more bytes than the character it\n     * replaces, then it can be edited in place.  Otherwise the replacement\n     * could overwrite a byte we are about to read, depending on the strings\n     * being processed.  The comments and variable names here refer to this as\n     * \"growing\".  Some inputs won't grow, and might even shrink under /d, but\n     * some inputs could grow, so we have to assume any given one might grow.\n     * On very long inputs, the temporary could eat up a lot of memory, so we\n     * want to avoid it if possible.  For non-UTF-8 inputs, everything is\n     * single-byte, so can be edited in place, unless there is something in the\n     * pattern that could force it into UTF-8.  The inversion map makes it\n     * feasible to determine this.  Previous versions of this code pretty much\n     * punted on determining if UTF-8 could be edited in place.  Now, this code\n     * is rigorous in making that determination.\n     *\n     * Another characteristic we need to know is whether the lhs and rhs are\n     * identical.  If so, and no other flags are present, the only effect of\n     * the tr/// is to count the characters present in the input that are\n     * mentioned in the lhs string.  The implementation of that is easier and\n     * runs faster than the more general case.  Normalizing here allows for\n     * accurate determination of this.  Previously there were false negatives\n     * possible.\n     *\n     * Instead of 'transliterated', the comments here use 'unmapped' for the\n     * characters that are left unchanged by the operation; otherwise they are\n     * 'mapped'\n     *\n     * The lhs of the tr/// is here referred to as the t side.\n     * The rhs of the tr/// is here referred to as the r side.\n     *\n     * An inversion map consists of two parallel arrays.  One is essentially an\n     * inversion list: an ordered list of code points such that each element\n     * gives the first code point of a range of consecutive code points that\n     * map to the element in the other array that has the same index as this\n     * one (in other words, the corresponding element).  Thus the range extends\n     * up to (but not including) the code point given by the next higher\n     * element.  In a true inversion map, the corresponding element in the\n     * other array (the inversion list) gives the mapping of the first code\n     * point in the range, with the understanding that the next higher code\n     * point in the inversion list's range will map to the next higher code\n     * point in the map.\n     *\n     * So if at element [i], let's say we have:\n     *\n     *     t_invlist  r_map\n     * [i]    A         a\n     *\n     * This means that A => a, B => b, C => c....  Let's say that the situation\n     * is such that:\n     *\n     * [i+1]  L        -1\n     *\n     * This means the sequence that started at [i] stops at K => k.  This\n     * illustrates that you need to look at the next element to find where a\n     * sequence stops.  Except, the highest element in the inversion list\n     * begins a range that is understood to extend to the platform's infinity.\n     *\n     * This routine modifies traditional inversion maps to reserve two\n     * mappings:\n     *\n     *  TR_UNLISTED (or -1) indicates that no code point in the range is listed\n     *      in the tr/// searchlist.  At runtime, these are always passed\n     *      through unchanged.  In the inversion map, all points in the range\n     *      are mapped to -1, instead of increasing.  The 'L' entry in the\n     *      example above illustrates this.\n     *\n     *      We start the parse with every code point mapped to this, and as we\n     *      parse and find ones that are listed in the search list, we carve\n     *      out ranges as we go along that override that.\n     *\n     *  So, if the next element in our main example is such that it yields:\n     *\n     * [i]    A        a\n     * [i+1]  L       -1\n     * [i+2]  Q        q\n     *\n     * Then all of L, M, N, O, and P map to TR_UNLISTED.  We know that Q maps\n     * to q, but we need the next element (or know this is the final one) to\n     * figure out what comes next.\n     *\n     * The other special mapping is\n     *\n     *  TR_SPECIAL_HANDLING (or -2) indicates that every code point in the\n     *      range needs special handling.  Again, all code points in the range\n     *      are mapped to -2, instead of increasing.\n     *\n     *      There are two cases where this mapping is used:\n     *\n     *      Under /d this value means the code point should be deleted from the\n     *      transliteration when encountered.\n     *\n     *      Otherwise, it marks that every code point in the range is to map to\n     *      the final character in the replacement list.  This happens only\n     *      when the replacement list is shorter than the search one, so there\n     *      are things in the search list that have no correspondence in the\n     *      replacement list.  For example, in tr/a-z/A/, 'A' is the final\n     *      value, and the inversion map generated for this would be like this:\n     *          \\0  =>  -1\n     *          a   =>   A\n     *          b-z =>  -2\n     *          z+1 =>  -1\n     *      'A' appears once, then the remainder of the range maps to -2.  The\n     *      use of -2 isn't strictly necessary, as an inversion map is capable\n     *      of representing this situation, but not nearly so compactly, and\n     *      this is actually quite commonly encountered.  Indeed, the original\n     *      design of this code used a full inversion map for this.  But things\n     *      like\n     *          tr/\\0-\\x{FFFF}/A/\n     *      generated huge data structures, slowly, and the execution was also\n     *      slow.  So the current scheme was implemented.\n     *\n     * If the next few elements in the example yield\n     *\n     * [i]    A        a\n     * [i+1]  L       -1\n     * [i+2]  Q        q\n     * [i+3]  R        z\n     * [i+4]  S       TR_UNLISTED\n     *\n     * Then Q => q; R => z; and S => TR_UNLISTED.  If [i+4] (the 'S') is the\n     * final element in the arrays, every code point from S to infinity maps to\n     * TR_UNLISTED.\n     */\n\n    SV * const tstr = cSVOPx(expr)->op_sv;\n    SV * const rstr = cSVOPx(repl)->op_sv;\n    STRLEN tlen;\n    STRLEN rlen;\n    const U8 * t0 = (U8*)SvPV_const(tstr, tlen);\n    const U8 * r0 = (U8*)SvPV_const(rstr, rlen);\n    const U8 * t = t0;\n    const U8 * r = r0;\n    UV t_count = 0, r_count = 0;  /* Number of characters in search and\n                                         replacement lists */\n\n    /* khw thinks some of the private flags for this op are quaintly named.\n     * OPpTRANS_GROWS for example is TRUE if the replacement for some lhs\n     * character when represented in UTF-8 is longer than the original\n     * character's UTF-8 representation */\n    const bool complement = cBOOL(o->op_private & OPpTRANS_COMPLEMENT);\n    const bool squash     = cBOOL(o->op_private & OPpTRANS_SQUASH);\n    const bool del        = cBOOL(o->op_private & OPpTRANS_DELETE);\n\n    /* Set to true if there is some character < 256 in the lhs that maps to\n     * above 255.  If so, a non-UTF-8 match string can be forced into being in\n     * UTF-8 by a tr/// operation. */\n    bool can_force_utf8 = FALSE;\n\n    /* If only ASCII-range characters are involved, some shortcuts can be done\n     * at runtime */\n    bool has_utf8_variant = false;\n\n    /* What is the maximum expansion factor in UTF-8 transliterations,\n     * calculated in the first pass.  If a 2-byte UTF-8 encoded character is to\n     * be replaced by a 3-byte one, its expansion factor is 1.5.  This number\n     * is used at runtime to calculate how much space to allocate for\n     * non-inplace transliterations.  Without this number, the worst case is\n     * 14, which is extremely unlikely to happen in real life, and could\n     * require significant memory overhead. */\n    NV max_expansion = 1.;\n\n    UV t_range_count, r_range_count, min_range_count;\n    UV* t_array;\n    SV* t_invlist;\n    UV* r_map;\n    UV r_cp = 0, t_cp = 0;\n    UV t_cp_end = (UV) -1;\n    UV r_cp_end;\n    Size_t len;\n    AV* invmap;\n    UV final_map = TR_UNLISTED;    /* The final character in the replacement\n                                      list, updated as we go along.  Initialize\n                                      to something illegal */\n\n    bool rstr_utf8 = cBOOL(SvUTF8(rstr));\n    bool tstr_utf8 = cBOOL(SvUTF8(tstr));\n\n    const U8* tend = t + tlen;\n    const U8* rend = r + rlen;\n\n    SV * inverted_tstr = NULL;\n\n    Size_t i;\n    unsigned int pass2;\n\n    /* This routine implements detection of a transliteration having a longer\n     * UTF-8 representation than its source, by partitioning in the first pass\n     * all the possible code points of the platform into equivalence classes of\n     * the same UTF-8 byte length.  PL_partition_by_byte_length[] is the guts\n     * of an inversion list that does this.  It is used to avoid the expense of\n     * constructing the partition at runtime.  It covers the entire range of\n     * code points possible on this platform, and each entry is for the single\n     * range of code points whose UTF-8 representation has the same length.\n     * (The definition of UTF-8 guarantees that there is a single range for\n     * each length.) */\n    UV PL_partition_by_byte_length[] = {\n        0,\n\n        /* 0 .. 127  all have 1 byte\n         * representations */\n        0x80,\n\n        /* The highest two UTF-8 byte representable code point is the one with\n         * all 1's in the payload bearing bits of the start byte and its single\n         * continuation byte.  Those start bytes have 5 bits in their payload,\n         * and the single start byte has UTF_ACCUMULATION_SHIFT payload bits.\n         * The range for three byte code points starts at 1 plus that. */\n        1 + nBIT_UMAX(5 + 1 * UTF_ACCUMULATION_SHIFT),  /* begins 3 bytes */\n\n       /* The same is true for each succeeding byte length.  Each has one less\n        * bit in the start byte than the previous one, but one more\n        * continuation byte. */\n        1 + nBIT_UMAX(4 + 2 * UTF_ACCUMULATION_SHIFT),  /* begins 4 bytes */\n        1 + nBIT_UMAX(3 + 3 * UTF_ACCUMULATION_SHIFT),  /* begins 5 bytes */\n        1 + nBIT_UMAX(2 + 4 * UTF_ACCUMULATION_SHIFT),  /* begins 6 bytes */\n        1 + nBIT_UMAX(1 + 5 * UTF_ACCUMULATION_SHIFT),  /* begins 7 bytes */\n\n#  ifdef UV_IS_QUAD\n\n        /* begins platform's longest number of bytes */\n        1 + nBIT_UMAX(0 + 6 * UTF_ACCUMULATION_SHIFT)\n#  endif\n\n    };\n\n    /* At the beginning of the first pass, the inversion map will look like\n     * this on a 32-bit ASCII platform\n     *\n     *  [0]         0 .. 0x7F      TR_UNLISTED\n     *  [1]      0x80 .. 0x07FF    TR_UNLISTED\n     *  [2]    0x0800 .. 0xFFFF    TR_UNLISTED\n     *  [3]   0x10000 .. 0x1FFFFF  TR_UNLISTED\n     *  [4]  0x200000 .. 0x3FFFFFF TR_UNLISTED\n     *  [5] 0x4000000 .. INFTY     TR_UNLISTED\n     *\n     * Now suppose that we are compiling tr/A-Z/a-z/\n     * At the end of the first pass, the inversion map will be\n     *\n     *  [0]         0 .. 0x40      TR_UNLISTED\n     *  [1]      0x41 .. 0x5A      0x61\n     *  [2]      0x5B .. 0x7F      TR_UNLISTED\n     *  [3]      0x80 .. 0x07FF    TR_UNLISTED\n     *  [4]    0x0800 .. 0xFFFF    TR_UNLISTED\n     *  [5]   0x10000 .. 0x1FFFFF  TR_UNLISTED\n     *  [6]  0x200000 .. 0x3FFFFFF TR_UNLISTED\n     *  [7] 0x4000000 .. INFTY     TR_UNLISTED\n     *\n     * The second pass will merge adjacent ranges, squashing this down to\n     *\n     *  [0]    0 .. 0x40   TR_UNLISTED\n     *  [1] 0x41 .. 0x5A   0x61\n     *  [2] 0x5B .. INFTY  TR_UNLISTED\n     *\n     * The actual compiled code will be the traditional 257 byte lookup array\n     * with 26 bytes in the middle looking like\n     *\n     *      [ord \"A\"] => ord(\"a\")\n     *      [ord \"B\"] => ord(\"b\")\n     *      ...\n     *      [ord \"Z\"] => ord(\"z\")\n     *\n     * The 257th byte will contain information about the flags this tr is\n     * compiled with.  The remaining bytes will all contain TR_UNLISTED to\n     * indicate they are not to be touched by this operation.\n     *\n     * The reason the code space is partitioned is illustrated by the example\n     * oF compiling tr/\\x{7FF}-\\x{FFFE}/\\x{800}-\\x{FFFF}/\n     * This example effectively adds 1 to each code point in the lhs range.  By\n     * the end of the first pass, the inversion map will look like\n     *\n     *  [0]         0 .. 0x7F      TR_UNLISTED\n     *  [1]      0x80 .. 0x07FE    TR_UNLISTED\n     *  [2]    0x07FF              0x0800\n     *  [2]    0x0800 .. 0xFFFE    0x0801\n     *  [2]    0xFFFF              TR_UNLISTED\n     *  [3]   0x10000 .. 0x1FFFFF  TR_UNLISTED\n     *  [4]  0x200000 .. 0x3FFFFFF TR_UNLISTED\n     *  [5] 0x4000000 .. INFTY     TR_UNLISTED\n     *\n     * In this large range, just one code point, \\x{7FF} translates to a code\n     * point which has a longer representation than it does.  This means that a\n     * string containing that code point cannot be edited in place, a fact we\n     * need to know at compilation time.  The partitioning forces the algorithm\n     * to split off the code point into a separate element from the rest of the\n     * range.  This makes it easy to find such cases.  That information is\n     * noted, and the second pass squashes this down to\n     *\n     *  [0]      0 .. 0x07FE  TR_UNLISTED\n     *  [1] 0x07FF .. 0xFFFE  0x0800\n     *  [2] 0xFFFF .. INFTY   TR_UNLISTED\n     *\n     * This inversion map is what is used at runtime; the 257 element table\n     * would be useless here, and is not generated.\n     *\n     * Note that we determine here if there is any possible input that can't be\n     * done in place.  It might be that a particular input contains only code\n     * points that can be done in place.  One could examine at runtime to see,\n     * but this could be as expensive as just doing the copy.\n     */\n\n    PERL_ARGS_ASSERT_PMTRANS;\n\n    PL_hints |= HINT_BLOCK_SCOPE;\n\n    /* If /c, the search list is sorted and complemented.  This is now done by\n     * creating an inversion list from it, and then trivially inverting that.\n     * The previous implementation used qsort, but creating the list\n     * automatically keeps it sorted as we go along */\n    if (complement) {\n        UV start, end;\n        SV * inverted_tlist = _new_invlist(tlen);\n        Size_t temp_len;\n\n        DEBUG_y(PerlIO_printf(Perl_debug_log,\n                    \"%s: %d: tstr before inversion=\\n%s\\n\",\n                    __FILE__, __LINE__, _byte_dump_string(t, tend - t, 0)));\n\n        while (t < tend) {\n\n            /* Non-utf8 strings don't have ranges, so each character is listed\n             * out */\n            if (! tstr_utf8) {\n                inverted_tlist = add_cp_to_invlist(inverted_tlist, *t);\n                t++;\n            }\n            else {  /* But UTF-8 strings have been parsed in toke.c to have\n                 * ranges if appropriate. */\n                UV t_cp;\n                Size_t t_char_len;\n\n                /* Get the first character */\n                t_cp = valid_utf8_to_uvchr(t, &t_char_len);\n                t += t_char_len;\n\n                /* If the next byte indicates that this wasn't the first\n                 * element of a range, the range is just this one */\n                if (t >= tend || *t != RANGE_INDICATOR) {\n                    inverted_tlist = add_cp_to_invlist(inverted_tlist, t_cp);\n                }\n                else { /* Otherwise, ignore the indicator byte, and get the\n                          final element, and add the whole range */\n                    t++;\n                    t_cp_end = valid_utf8_to_uvchr(t, &t_char_len);\n                    t += t_char_len;\n\n                    inverted_tlist = _add_range_to_invlist(inverted_tlist,\n                                                      t_cp, t_cp_end);\n                }\n            }\n        } /* End of parse through tstr */\n\n        /* The inversion list is done; now invert it */\n        _invlist_invert(inverted_tlist);\n\n        /* Now go through the inverted list and create a new tstr for the rest\n         * of the routine to use.  Since the UTF-8 version can have ranges, and\n         * can be much more compact than the non-UTF-8 version, we create the\n         * string in UTF-8 even if not necessary.  (This is just an intermediate\n         * value that gets thrown away anyway.) */\n        invlist_iterinit(inverted_tlist);\n        inverted_tstr = newSVpvs(\"\");\n        while (invlist_iternext(inverted_tlist, &start, &end)) {\n            U8 temp[UTF8_MAXBYTES];\n            U8 * temp_end_pos;\n\n            /* IV_MAX keeps things from going out of bounds */\n            start = MIN(IV_MAX, start);\n            end   = MIN(IV_MAX, end);\n\n            temp_end_pos = uv_to_utf8(temp, start);\n            sv_catpvn(inverted_tstr, (char *) temp, temp_end_pos - temp);\n\n            if (start != end) {\n                sv_catpvf(inverted_tstr, \"%c\", RANGE_INDICATOR);\n                temp_end_pos = uv_to_utf8(temp, end);\n                sv_catpvn(inverted_tstr, (char *) temp, temp_end_pos - temp);\n            }\n        }\n\n        /* Set up so the remainder of the routine uses this complement, instead\n         * of the actual input */\n        t0 = t = (U8*)SvPV_const(inverted_tstr, temp_len);\n        tend = t0 + temp_len;\n        tstr_utf8 = TRUE;\n\n        SvREFCNT_dec_NN(inverted_tlist);\n    }\n\n    /* For non-/d, an empty rhs means to use the lhs */\n    if (rlen == 0 && ! del) {\n        r0 = t0;\n        rend = tend;\n        rstr_utf8  = tstr_utf8;\n    }\n\n    t_invlist = _new_invlist(1);\n\n    /* Initialize to a single range */\n    t_invlist = _add_range_to_invlist(t_invlist, 0, UV_MAX);\n\n    /* Below, we parse the (potentially adjusted) input, creating the inversion\n     * map.  This is done in two passes.  The first pass is just to determine\n     * if the transliteration can be done in-place.  It can be done in place if\n     * no possible inputs result in the replacement taking up more bytes than\n     * the input.  To figure that out, in the first pass we start with all the\n     * possible code points partitioned into ranges so that every code point in\n     * a range occupies the same number of UTF-8 bytes as every other code\n     * point in the range.  Constructing the inversion map doesn't merge ranges\n     * together, but can split them into multiple ones.  Given the starting\n     * partition, the ending state will also have the same characteristic,\n     * namely that each code point in each partition requires the same number\n     * of UTF-8 bytes to represent as every other code point in the same\n     * partition.\n     *\n     * This partitioning has been pre-compiled.  Copy it to initialize */\n    len = C_ARRAY_LENGTH(PL_partition_by_byte_length);\n    invlist_extend(t_invlist, len);\n    t_array = invlist_array(t_invlist);\n    Copy(PL_partition_by_byte_length, t_array, len, UV);\n    invlist_set_len(t_invlist, len, *(get_invlist_offset_addr(t_invlist)));\n    Newx(r_map, len + 1, UV);\n\n    /* The inversion map the first pass creates could be used as-is, but\n     * generally would be larger and slower to run than the output of the\n     * second pass.  */\n\n    for (pass2 = 0; pass2 < 2; pass2++) {\n        if (pass2) {\n\n            DEBUG_yv(PerlIO_printf(Perl_debug_log, \"After pass1: \\n\"));\n            DEBUG_yv(invmap_dump(t_invlist, r_map));\n\n            /* In the second pass, we start with a single range */\n            t_invlist = _add_range_to_invlist(t_invlist, 0, UV_MAX);\n            len = 1;\n            t_array = invlist_array(t_invlist);\n        }\n\n/* In EBCDIC, the byte length is not monotonically increasing for code points\n * below 256, which the algorithm below requires.  To accommodate that, the\n * macro CP_ADJUST defined below converts those code points to ASCII in the\n * first pass and does nothing in the second.  This works because the first\n * pass is looking only for the existence of anomalies; and not the specific\n * code point values.  The growth factor is going to be 2 regardless, because\n * one byte can become two.  Only code points below 256 differ between the two\n * character sets in this regard.  For these, we also can't have any ranges, as\n * they have to be individually converted. */\n#ifdef EBCDIC\n#  define CP_ADJUST(x)          ((pass2) ? (x) : NATIVE_TO_UNI(x))\n#  define FORCE_RANGE_LEN_1(x)  ((pass2) ? 0 : ((x) < 256))\n#  define CP_SKIP(x)            ((pass2) ? UVCHR_SKIP(x) : OFFUNISKIP(x))\n#  define CP_VARIANT(x)         ((pass2) ? ! UVCHR_IS_INVARIANT(x)          \\\n                                         : ! OFFUNI_IS_INVARIANT(x))\n#else\n#  define CP_ADJUST(x)          (x)\n#  define FORCE_RANGE_LEN_1(x)  0\n#  define CP_SKIP(x)            UVCHR_SKIP(x)\n#  define CP_VARIANT(x)       ! UVCHR_IS_INVARIANT(x)\n#endif\n\n        /* And the mapping of each of the ranges is initialized.  Initially,\n         * everything is TR_UNLISTED. */\n        for (i = 0; i < len; i++) {\n            r_map[i] = TR_UNLISTED;\n        }\n\n        t = t0;\n        t_count = 0;\n        r = r0;\n        r_count = 0;\n        t_range_count = r_range_count = 0;\n\n        DEBUG_y(PerlIO_printf(Perl_debug_log, \"%s: %d:\\ntstr=%s\\n\",\n                    __FILE__, __LINE__, _byte_dump_string(t, tend - t, 0)));\n        DEBUG_y(PerlIO_printf(Perl_debug_log, \"rstr=%s\\n\",\n                                        _byte_dump_string(r, rend - r, 0)));\n        DEBUG_y(PerlIO_printf(Perl_debug_log, \"/c=%d; /s=%d; /d=%d\\n\"\n                                              \" At the beginning of pass %u\\n\",\n                                              complement, squash, del,\n                                              pass2 + 1));\n        DEBUG_y(invmap_dump(t_invlist, r_map));\n\n        /* Now go through the search list constructing an inversion map.  The\n         * input is not necessarily in any particular order.  Making it an\n         * inversion map orders it, potentially simplifying, and makes it easy\n         * to deal with at run time.  This is the only place in core that\n         * generates an inversion map; if others were introduced, it might be\n         * better to create general purpose routines to handle them.\n         * (Inversion lists are created in perl in other places.)\n         */\n                           /* Finish up range started in what otherwise would\n                            * have been the final iteration */\n        while (t < tend || t_range_count > 0) {\n            bool adjacent_to_range_above = FALSE;\n            bool adjacent_to_range_below = FALSE;\n\n            bool merge_with_range_above = FALSE;\n            bool merge_with_range_below = FALSE;\n\n            UV span, invmap_range_length_remaining;\n            SSize_t j;\n            Size_t i;\n\n            /* If we are in the middle of processing a range in the 'target'\n             * side, the previous iteration has set us up.  Otherwise, look at\n             * the next character in the search list */\n            if (t_range_count <= 0) {\n                if (! tstr_utf8) {\n\n                    /* Here, not in the middle of a range, and not UTF-8.  The\n                     * next code point is the single byte where we're at */\n                    t_cp = CP_ADJUST(*t);\n                    t_range_count = 1;\n                    t++;\n                }\n                else {\n                    Size_t t_char_len;\n\n                    /* Here, not in the middle of a range, and is UTF-8.  The\n                     * next code point is the next UTF-8 char in the input.  We\n                     * know the input is valid, because the toker constructed\n                     * it */\n                    t_cp = CP_ADJUST(valid_utf8_to_uvchr(t, &t_char_len));\n                    t += t_char_len;\n\n                    /* UTF-8 strings (only) have been parsed in toke.c to have\n                     * ranges.  See if the next byte indicates that this was\n                     * the first element of a range.  If so, get the final\n                     * element and calculate the range size.  If not, the range\n                     * size is 1 */\n                    if (   t < tend && *t == RANGE_INDICATOR\n                        && ! FORCE_RANGE_LEN_1(t_cp))\n                    {\n                        t++;\n                        t_range_count = valid_utf8_to_uvchr(t, &t_char_len)\n                                      - t_cp + 1;\n                        t += t_char_len;\n                    }\n                    else {\n                        t_range_count = 1;\n                    }\n                }\n\n                if (CP_VARIANT(t_cp)) {\n                    has_utf8_variant = true;\n                }\n\n                /* Count the total number of listed code points * */\n                t_count += t_range_count;\n            }\n\n            /* Similarly, get the next character in the replacement list */\n            if (r_range_count <= 0) {\n                if (r >= rend) {\n\n                    /* But if we've exhausted the rhs, there is nothing to map\n                     * to, except the special handling one, and we make the\n                     * range the same size as the lhs one. */\n                    r_cp = TR_SPECIAL_HANDLING;\n                    r_range_count = t_range_count;\n\n#ifdef DEBUGGING\n                    if (DEBUG_y_TEST && ! del) {\n                        PerlIO_printf(Perl_debug_log,\n                                          \"final_map =%\" UVXf \"\\n\", final_map);\n                    }\n#endif\n                }\n                else {\n                    if (! rstr_utf8) {\n                        r_cp = CP_ADJUST(*r);\n                        r_range_count = 1;\n                        r++;\n                    }\n                    else {\n                        Size_t r_char_len;\n\n                        r_cp = CP_ADJUST(valid_utf8_to_uvchr(r, &r_char_len));\n                        r += r_char_len;\n                        if (   r < rend && *r == RANGE_INDICATOR\n                            && ! FORCE_RANGE_LEN_1(r_cp))\n                        {\n                            r++;\n                            r_range_count = valid_utf8_to_uvchr(r,\n                                                    &r_char_len) - r_cp + 1;\n                            r += r_char_len;\n                        }\n                        else {\n                            r_range_count = 1;\n                        }\n                    }\n\n                    if (r_cp == TR_SPECIAL_HANDLING) {\n                        r_range_count = t_range_count;\n                    }\n                    else if (CP_VARIANT(r_cp)) {\n                        has_utf8_variant = true;\n                    }\n\n                    /* This is the final character so far */\n                    final_map = r_cp + r_range_count - 1;\n\n                    r_count += r_range_count;\n                }\n            }\n\n            /* Here, we have the next things ready in both sides.  They are\n             * potentially ranges.  We try to process as big a chunk as\n             * possible at once, but the lhs and rhs must be synchronized, so\n             * things like tr/A-Z/a-ij-z/ will need to be processed in 2 chunks\n             * */\n            min_range_count = MIN(t_range_count, r_range_count);\n\n            /* Search the inversion list for the entry that contains the input\n             * code point <cp>.  The inversion map was initialized to cover the\n             * entire range of possible inputs, so this should not fail.  So\n             * the return value is the index into the list's array of the range\n             * that contains <cp>, that is, 'i' such that\n             *      array[i] <= cp < * array[i+1] */\n            j = _invlist_search(t_invlist, t_cp);\n            assert(j >= 0);\n            i = j;\n\n            /* Here, the data structure might look like:\n             *\n             * index    t   r     Meaning\n             * [i-1]    J   j   # J-L => j-l\n             * [i]      M  -1   # M => default; as do N, O, P, Q\n             * [i+1]    R   x   # R => x, S => x+1, T => x+2\n             * [i+2]    U   y   # U => y, V => y+1, ...\n             * ...\n             * [-1]     Z  -1   # Z => default; as do Z+1, ... infinity\n             *\n             * where 'x' and 'y' above are not to be taken literally.\n             *\n             * The maximum chunk we can handle in this loop iteration, is the\n             * smallest of the three components: the lhs 't_', the rhs 'r_',\n             * and the remainder of the range in element [i].  (In pass 1, that\n             * range will have everything in it be of the same class; we can't\n             * cross into another class.)  'min_range_count' already contains\n             * the smallest of the first two values.  The final one is\n             * irrelevant if the map is to the special indicator */\n\n            invmap_range_length_remaining = (i + 1 < len)\n                                            ? t_array[i+1] - t_cp\n                                            : IV_MAX - t_cp;\n            span = MAX(1, MIN(min_range_count, invmap_range_length_remaining));\n\n            /* The end point of this chunk is where we are, plus the span, but\n             * never larger than the platform's infinity */\n            t_cp_end = MIN(IV_MAX, t_cp + span - 1);\n\n            if (r_cp == TR_SPECIAL_HANDLING) {\n\n                /* If unmatched lhs code points map to the final map, use that\n                 * value.  This being set to TR_SPECIAL_HANDLING indicates that\n                 * we don't have a final map: unmatched lhs code points are\n                 * simply deleted */\n                r_cp_end = (del) ? TR_SPECIAL_HANDLING : final_map;\n            }\n            else {\n                r_cp_end = MIN(IV_MAX, r_cp + span - 1);\n\n                /* If something on the lhs is below 256, and something on the\n                 * rhs is above, there is a potential mapping here across that\n                 * boundary.  Indeed the only way there isn't is if both sides\n                 * start at the same point.  That means they both cross at the\n                 * same time.  But otherwise one crosses before the other */\n                if (t_cp < 256 && r_cp_end > 255 && r_cp != t_cp) {\n                    can_force_utf8 = TRUE;\n                    max_expansion = MAX(2, max_expansion);\n                }\n            }\n\n            /* If a character appears in the search list more than once, the\n             * 2nd and succeeding occurrences are ignored, so only do this\n             * range if haven't already processed this character.  (The range\n             * has been set up so that all members in it will be of the same\n             * ilk) */\n            if (r_map[i] == TR_UNLISTED) {\n                DEBUG_yv(PerlIO_printf(Perl_debug_log,\n                    \"Processing %\" UVxf \"-%\" UVxf \" => %\" UVxf \"-%\" UVxf \"\\n\",\n                    t_cp, t_cp_end, r_cp, r_cp_end));\n\n                /* This is the first definition for this chunk, hence is valid\n                 * and needs to be processed.  Here and in the comments below,\n                 * we use the above sample data.  The t_cp chunk must be any\n                 * contiguous subset of M, N, O, P, and/or Q.\n                 *\n                 * In the first pass, calculate if there is any possible input\n                 * string that has a character whose transliteration will be\n                 * longer than it.  If none, the transliteration may be done\n                 * in-place, as it can't write over a so-far unread byte.\n                 * Otherwise, a copy must first be made.  This could be\n                 * expensive for long inputs.\n                 *\n                 * In the first pass, the t_invlist has been partitioned so\n                 * that all elements in any single range have the same number\n                 * of bytes in their UTF-8 representations.  And the r space is\n                 * either a single byte, or a range of strictly monotonically\n                 * increasing code points.  So the final element in the range\n                 * will be represented by no fewer bytes than the initial one.\n                 * That means that if the final code point in the t range has\n                 * at least as many bytes as the final code point in the r,\n                 * then all code points in the t range have at least as many\n                 * bytes as their corresponding r range element.  But if that's\n                 * not true, the transliteration of at least the final code\n                 * point grows in length.  As an example, suppose we had\n                 *      tr/\\x{fff0}-\\x{fff1}/\\x{ffff}-\\x{10000}/\n                 * The UTF-8 for all but 10000 occupies 3 bytes on ASCII\n                 * platforms.  We have deliberately set up the data structure\n                 * so that any range in the lhs gets split into chunks for\n                 * processing, such that every code point in a chunk has the\n                 * same number of UTF-8 bytes.  We only have to check the final\n                 * code point in the rhs against any code point in the lhs. */\n                if ( ! pass2\n                    && r_cp_end != TR_SPECIAL_HANDLING\n                    && CP_SKIP(t_cp_end) < CP_SKIP(r_cp_end))\n                {\n                    /* Here, we will need to make a copy of the input string\n                     * before doing the transliteration.  The worst possible\n                     * case is an expansion ratio of 14:1. This is rare, and\n                     * we'd rather allocate only the necessary amount of extra\n                     * memory for that copy.  We can calculate the worst case\n                     * for this particular transliteration by keeping track of\n                     * the expansion factor for each range.\n                     *\n                     * Consider tr/\\xCB/\\X{E000}/.  The maximum expansion\n                     * factor is 1 byte going to 3 if the target string is not\n                     * UTF-8, but 2 bytes going to 3 if it is in UTF-8.  We\n                     * could pass two different values so doop could choose\n                     * based on the UTF-8ness of the target.  But khw thinks\n                     * (perhaps wrongly) that is overkill.  It is used only to\n                     * make sure we malloc enough space.\n                     *\n                     * If no target string can force the result to be UTF-8,\n                     * then we don't have to worry about the case of the target\n                     * string not being UTF-8 */\n                    NV t_size = (can_force_utf8 && t_cp < 256)\n                                ? 1\n                                : CP_SKIP(t_cp_end);\n                    NV ratio = CP_SKIP(r_cp_end) / t_size;\n\n                    o->op_private |= OPpTRANS_GROWS;\n\n                    /* Now that we know it grows, we can keep track of the\n                     * largest ratio */\n                    if (ratio > max_expansion) {\n                        max_expansion = ratio;\n                        DEBUG_y(PerlIO_printf(Perl_debug_log,\n                                        \"New expansion factor: %\" NVgf \"\\n\",\n                                        max_expansion));\n                    }\n                }\n\n                /* The very first range is marked as adjacent to the\n                 * non-existent range below it, as it causes things to \"just\n                 * work\" (TradeMark)\n                 *\n                 * If the lowest code point in this chunk is M, it adjoins the\n                 * J-L range */\n                if (t_cp == t_array[i]) {\n                    adjacent_to_range_below = TRUE;\n\n                    /* And if the map has the same offset from the beginning of\n                     * the range as does this new code point (or both are for\n                     * TR_SPECIAL_HANDLING), this chunk can be completely\n                     * merged with the range below.  EXCEPT, in the first pass,\n                     * we don't merge ranges whose UTF-8 byte representations\n                     * have different lengths, so that we can more easily\n                     * detect if a replacement is longer than the source, that\n                     * is if it 'grows'.  But in the 2nd pass, there's no\n                     * reason to not merge */\n                    if (   (i > 0 && (   pass2\n                                      || CP_SKIP(t_array[i-1])\n                                                            == CP_SKIP(t_cp)))\n                        && (   (   r_cp == TR_SPECIAL_HANDLING\n                                && r_map[i-1] == TR_SPECIAL_HANDLING)\n                            || (   r_cp != TR_SPECIAL_HANDLING\n                                && r_cp - r_map[i-1] == t_cp - t_array[i-1])))\n                    {\n                        merge_with_range_below = TRUE;\n                    }\n                }\n\n                /* Similarly, if the highest code point in this chunk is 'Q',\n                 * it adjoins the range above, and if the map is suitable, can\n                 * be merged with it */\n                if (    t_cp_end >= IV_MAX - 1\n                    || (   i + 1 < len\n                        && t_cp_end + 1 == t_array[i+1]))\n                {\n                    adjacent_to_range_above = TRUE;\n                    if (i + 1 < len)\n                    if (    (   pass2\n                             || CP_SKIP(t_cp) == CP_SKIP(t_array[i+1]))\n                        && (   (   r_cp == TR_SPECIAL_HANDLING\n                                && r_map[i+1] == (UV) TR_SPECIAL_HANDLING)\n                            || (   r_cp != TR_SPECIAL_HANDLING\n                                && r_cp_end == r_map[i+1] - 1)))\n                    {\n                        merge_with_range_above = TRUE;\n                    }\n                }\n\n                if (merge_with_range_below && merge_with_range_above) {\n\n                    /* Here the new chunk looks like M => m, ... Q => q; and\n                     * the range above is like R => r, ....  Thus, the [i-1]\n                     * and [i+1] ranges should be seamlessly melded so the\n                     * result looks like\n                     *\n                     * [i-1]    J   j   # J-T => j-t\n                     * [i]      U   y   # U => y, V => y+1, ...\n                     * ...\n                     * [-1]     Z  -1   # Z => default; as do Z+1, ... infinity\n                     */\n                    Move(t_array + i + 2, t_array + i, len - i - 2, UV);\n                    Move(r_map   + i + 2, r_map   + i, len - i - 2, UV);\n                    len -= 2;\n                    invlist_set_len(t_invlist,\n                                    len,\n                                    *(get_invlist_offset_addr(t_invlist)));\n                }\n                else if (merge_with_range_below) {\n\n                    /* Here the new chunk looks like M => m, .... But either\n                     * (or both) it doesn't extend all the way up through Q; or\n                     * the range above doesn't start with R => r. */\n                    if (! adjacent_to_range_above) {\n\n                        /* In the first case, let's say the new chunk extends\n                         * through O.  We then want:\n                         *\n                         * [i-1]    J   j   # J-O => j-o\n                         * [i]      P  -1   # P => -1, Q => -1\n                         * [i+1]    R   x   # R => x, S => x+1, T => x+2\n                         * [i+2]    U   y   # U => y, V => y+1, ...\n                         * ...\n                         * [-1]     Z  -1   # Z => default; as do Z+1, ...\n                         *                                            infinity\n                         */\n                        t_array[i] = t_cp_end + 1;\n                        r_map[i] = TR_UNLISTED;\n                    }\n                    else { /* Adjoins the range above, but can't merge with it\n                              (because 'x' is not the next map after q) */\n                        /*\n                         * [i-1]    J   j   # J-Q => j-q\n                         * [i]      R   x   # R => x, S => x+1, T => x+2\n                         * [i+1]    U   y   # U => y, V => y+1, ...\n                         * ...\n                         * [-1]     Z  -1   # Z => default; as do Z+1, ...\n                         *                                          infinity\n                         */\n\n                        Move(t_array + i + 1, t_array + i, len - i - 1, UV);\n                        Move(r_map + i + 1, r_map + i, len - i - 1, UV);\n                        len--;\n                        invlist_set_len(t_invlist, len,\n                                        *(get_invlist_offset_addr(t_invlist)));\n                    }\n                }\n                else if (merge_with_range_above) {\n\n                    /* Here the new chunk ends with Q => q, and the range above\n                     * must start with R => r, so the two can be merged. But\n                     * either (or both) the new chunk doesn't extend all the\n                     * way down to M; or the mapping of the final code point\n                     * range below isn't m */\n                    if (! adjacent_to_range_below) {\n\n                        /* In the first case, let's assume the new chunk starts\n                         * with P => p.  Then, because it's merge-able with the\n                         * range above, that range must be R => r.  We want:\n                         *\n                         * [i-1]    J   j   # J-L => j-l\n                         * [i]      M  -1   # M => -1, N => -1\n                         * [i+1]    P   p   # P-T => p-t\n                         * [i+2]    U   y   # U => y, V => y+1, ...\n                         * ...\n                         * [-1]     Z  -1   # Z => default; as do Z+1, ...\n                         *                                          infinity\n                         */\n                        t_array[i+1] = t_cp;\n                        r_map[i+1] = r_cp;\n                    }\n                    else { /* Adjoins the range below, but can't merge with it\n                            */\n                        /*\n                         * [i-1]    J   j   # J-L => j-l\n                         * [i]      M   x   # M-T => x-5 .. x+2\n                         * [i+1]    U   y   # U => y, V => y+1, ...\n                         * ...\n                         * [-1]     Z  -1   # Z => default; as do Z+1, ...\n                         *                                          infinity\n                         */\n                        Move(t_array + i + 1, t_array + i, len - i - 1, UV);\n                        Move(r_map   + i + 1, r_map   + i, len - i - 1, UV);\n                        len--;\n                        t_array[i] = t_cp;\n                        r_map[i] = r_cp;\n                        invlist_set_len(t_invlist, len,\n                                        *(get_invlist_offset_addr(t_invlist)));\n                    }\n                }\n                else if (adjacent_to_range_below && adjacent_to_range_above) {\n                    /* The new chunk completely fills the gap between the\n                     * ranges on either side, but can't merge with either of\n                     * them.\n                     *\n                     * [i-1]    J   j   # J-L => j-l\n                     * [i]      M   z   # M => z, N => z+1 ... Q => z+4\n                     * [i+1]    R   x   # R => x, S => x+1, T => x+2\n                     * [i+2]    U   y   # U => y, V => y+1, ...\n                     * ...\n                     * [-1]     Z  -1   # Z => default; as do Z+1, ... infinity\n                     */\n                    r_map[i] = r_cp;\n                }\n                else if (adjacent_to_range_below) {\n                    /* The new chunk adjoins the range below, but not the range\n                     * above, and can't merge.  Let's assume the chunk ends at\n                     * O.\n                     *\n                     * [i-1]    J   j   # J-L => j-l\n                     * [i]      M   z   # M => z, N => z+1, O => z+2\n                     * [i+1]    P   -1  # P => -1, Q => -1\n                     * [i+2]    R   x   # R => x, S => x+1, T => x+2\n                     * [i+3]    U   y   # U => y, V => y+1, ...\n                     * ...\n                     * [-w]     Z  -1   # Z => default; as do Z+1, ... infinity\n                     */\n                    invlist_extend(t_invlist, len + 1);\n                    t_array = invlist_array(t_invlist);\n                    Renew(r_map, len + 1, UV);\n\n                    Move(t_array + i + 1, t_array + i + 2, len - i - 1, UV);\n                    Move(r_map + i + 1,   r_map   + i + 2, len - i - 1, UV);\n                    r_map[i] = r_cp;\n                    t_array[i+1] = t_cp_end + 1;\n                    r_map[i+1] = TR_UNLISTED;\n                    len++;\n                    invlist_set_len(t_invlist, len,\n                                    *(get_invlist_offset_addr(t_invlist)));\n                }\n                else if (adjacent_to_range_above) {\n                    /* The new chunk adjoins the range above, but not the range\n                     * below, and can't merge.  Let's assume the new chunk\n                     * starts at O\n                     *\n                     * [i-1]    J   j   # J-L => j-l\n                     * [i]      M  -1   # M => default, N => default\n                     * [i+1]    O   z   # O => z, P => z+1, Q => z+2\n                     * [i+2]    R   x   # R => x, S => x+1, T => x+2\n                     * [i+3]    U   y   # U => y, V => y+1, ...\n                     * ...\n                     * [-1]     Z  -1   # Z => default; as do Z+1, ... infinity\n                     */\n                    invlist_extend(t_invlist, len + 1);\n                    t_array = invlist_array(t_invlist);\n                    Renew(r_map, len + 1, UV);\n\n                    Move(t_array + i + 1, t_array + i + 2, len - i - 1, UV);\n                    Move(r_map   + i + 1, r_map   + i + 2, len - i - 1, UV);\n                    t_array[i+1] = t_cp;\n                    r_map[i+1] = r_cp;\n                    len++;\n                    invlist_set_len(t_invlist, len,\n                                    *(get_invlist_offset_addr(t_invlist)));\n                }\n                else {\n                    /* The new chunk adjoins neither the range above, nor the\n                     * range below.  Lets assume it is N..P => n..p\n                     *\n                     * [i-1]    J   j   # J-L => j-l\n                     * [i]      M  -1   # M => default\n                     * [i+1]    N   n   # N..P => n..p\n                     * [i+2]    Q  -1   # Q => default\n                     * [i+3]    R   x   # R => x, S => x+1, T => x+2\n                     * [i+4]    U   y   # U => y, V => y+1, ...\n                     * ...\n                     * [-1]     Z  -1   # Z => default; as do Z+1, ... infinity\n                     */\n\n                    DEBUG_yv(PerlIO_printf(Perl_debug_log,\n                                        \"Before fixing up: len=%d, i=%d\\n\",\n                                        (int) len, (int) i));\n                    DEBUG_yv(invmap_dump(t_invlist, r_map));\n\n                    invlist_extend(t_invlist, len + 2);\n                    t_array = invlist_array(t_invlist);\n                    Renew(r_map, len + 2, UV);\n\n                    Move(t_array + i + 1,\n                         t_array + i + 2 + 1, len - i - (2 - 1), UV);\n                    Move(r_map   + i + 1,\n                         r_map   + i + 2 + 1, len - i - (2 - 1), UV);\n\n                    len += 2;\n                    invlist_set_len(t_invlist, len,\n                                    *(get_invlist_offset_addr(t_invlist)));\n\n                    t_array[i+1] = t_cp;\n                    r_map[i+1] = r_cp;\n\n                    t_array[i+2] = t_cp_end + 1;\n                    r_map[i+2] = TR_UNLISTED;\n                }\n                DEBUG_yv(PerlIO_printf(Perl_debug_log,\n                          \"After iteration: span=%\" UVuf \", t_range_count=%\"\n                          UVuf \" r_range_count=%\" UVuf \"\\n\",\n                          span, t_range_count, r_range_count));\n                DEBUG_yv(invmap_dump(t_invlist, r_map));\n            } /* End of this chunk needs to be processed */\n\n            /* Done with this chunk. */\n            t_cp += span;\n            if (t_cp >= IV_MAX) {\n                break;\n            }\n            t_range_count -= span;\n            if (r_cp != TR_SPECIAL_HANDLING) {\n                r_cp += span;\n                r_range_count -= span;\n            }\n            else {\n                r_range_count = 0;\n            }\n\n        } /* End of loop through the search list */\n\n        /* We don't need an exact count, but we do need to know if there is\n         * anything left over in the replacement list.  So, just assume it's\n         * one byte per character */\n        if (rend > r) {\n            r_count++;\n        }\n    } /* End of passes */\n\n    SvREFCNT_dec(inverted_tstr);\n\n    DEBUG_y(PerlIO_printf(Perl_debug_log, \"After everything: \\n\"));\n    DEBUG_y(invmap_dump(t_invlist, r_map));\n\n    /* We now have normalized the input into an inversion map.\n     *\n     * See if the lhs and rhs are equivalent.  If so, this tr/// is a no-op\n     * except for the count, and streamlined runtime code can be used */\n    if (!del && !squash) {\n\n        /* They are identical if they point to the same address, or if\n         * everything maps to UNLISTED or to itself.  This catches things that\n         * not looking at the normalized inversion map doesn't catch, like\n         * tr/aa/ab/ or tr/\\x{100}-\\x{104}/\\x{100}-\\x{102}\\x{103}-\\x{104}  */\n        if (r0 != t0) {\n            for (i = 0; i < len; i++) {\n                if (r_map[i] != TR_UNLISTED && r_map[i] != t_array[i]) {\n                    goto done_identical_check;\n                }\n            }\n        }\n\n        /* Here have gone through entire list, and didn't find any\n         * non-identical mappings */\n        o->op_private |= OPpTRANS_IDENTICAL;\n\n      done_identical_check: ;\n    }\n\n    t_array = invlist_array(t_invlist);\n\n    /* If has components above 255, we generally need to use the inversion map\n     * implementation */\n    if (   can_force_utf8\n        || (   len > 0\n            && t_array[len-1] > 255\n                 /* But if the final range is 0x100-INFINITY and is a special\n                  * mapping, the table implementation can handle it */\n            && ! (   t_array[len-1] == 256\n                  && (   r_map[len-1] == TR_UNLISTED\n                      || r_map[len-1] == TR_SPECIAL_HANDLING))))\n    {\n        SV* r_map_sv;\n        SV* temp_sv;\n\n        /* A UTF-8 op is generated, indicated by this flag.  This op is an\n         * sv_op */\n        o->op_private |= OPpTRANS_USE_SVOP;\n\n        if (can_force_utf8) {\n            o->op_private |= OPpTRANS_CAN_FORCE_UTF8;\n        }\n\n        /* The inversion map is pushed; first the list. */\n        invmap = MUTABLE_AV(newAV());\n\n        SvREADONLY_on(t_invlist);\n        av_push(invmap, t_invlist);\n\n        /* 2nd is the mapping */\n        r_map_sv = newSVpvn((char *) r_map, len * sizeof(UV));\n        SvREADONLY_on(r_map_sv);\n        av_push(invmap, r_map_sv);\n\n        /* 3rd is the max possible expansion factor */\n        temp_sv = newSVnv(max_expansion);\n        SvREADONLY_on(temp_sv);\n        av_push(invmap, temp_sv);\n\n        /* Characters that are in the search list, but not in the replacement\n         * list are mapped to the final character in the replacement list */\n        if (! del && r_count < t_count) {\n            temp_sv = newSVuv(final_map);\n            SvREADONLY_on(temp_sv);\n            av_push(invmap, temp_sv);\n        }\n\n#ifdef USE_ITHREADS\n        cPADOPo->op_padix = pad_alloc(OP_TRANS, SVf_READONLY);\n        SvREFCNT_dec(PAD_SVl(cPADOPo->op_padix));\n        PAD_SETSV(cPADOPo->op_padix, (SV *) invmap);\n        SvPADTMP_on(invmap);\n        SvREADONLY_on(invmap);\n#else\n        cSVOPo->op_sv = (SV *) invmap;\n#endif\n\n    }\n    else {\n        OPtrans_map *tbl;\n        unsigned short i;\n\n        /* The OPtrans_map struct already contains one slot; hence the -1. */\n        SSize_t struct_size = sizeof(OPtrans_map)\n                            + (256 - 1 + 1)*sizeof(short);\n\n        /* Non-utf8 case: set o->op_pv to point to a simple 256+ entry lookup\n         * table. Entries with the value TR_UNMAPPED indicate chars not to be\n         * translated, while TR_DELETE indicates a search char without a\n         * corresponding replacement char under /d.\n         *\n         * In addition, an extra slot at the end is used to store the final\n         * repeating char, or TR_R_EMPTY under an empty replacement list, or\n         * TR_DELETE under /d; which makes the runtime code easier. */\n\n        /* Indicate this is an op_pv */\n        o->op_private &= ~OPpTRANS_USE_SVOP;\n\n        /* Indicate if no variants, but complementing means the runtime has to\n         * consider variants anyway */\n        if (! complement && ! has_utf8_variant) {\n            o->op_private |= OPpTRANS_ONLY_UTF8_INVARIANTS;\n        }\n\n        tbl = (OPtrans_map*)PerlMemShared_calloc(struct_size, 1);\n        tbl->size = 256;\n        cPVOPo->op_pv = (char*)tbl;\n\n        for (i = 0; i < len; i++) {\n            STATIC_ASSERT_DECL(TR_SPECIAL_HANDLING == TR_DELETE);\n            short upper = i >= len - 1 ? 256 : (short) t_array[i+1];\n            short to = (short) r_map[i];\n            short j;\n            bool do_increment = TRUE;\n\n            /* Any code points above our limit should be irrelevant */\n            if (t_array[i] >= tbl->size) break;\n\n            /* Set up the map */\n            if (to == (short) TR_SPECIAL_HANDLING && ! del) {\n                to = (short) final_map;\n                do_increment = FALSE;\n            }\n            else if (to < 0) {\n                do_increment = FALSE;\n            }\n\n            /* Create a map for everything in this range.  The value increases\n             * except for the special cases */\n            for (j = (short) t_array[i]; j < upper; j++) {\n                tbl->map[j] = to;\n                if (do_increment) to++;\n            }\n        }\n\n        tbl->map[tbl->size] = del\n                              ? (short) TR_DELETE\n                              : (short) rlen\n                                ? (short) final_map\n                                : (short) TR_R_EMPTY;\n#ifdef DEBUGGING\n        if (DEBUG_y_TEST) {\n            PerlIO_printf(Perl_debug_log,\"%s: %d\\n\", __FILE__, __LINE__);\n            for (i = 0; i < tbl->size; i++) {\n                if (tbl->map[i] < 0) {\n                    PerlIO_printf(Perl_debug_log,\" %02x=>%d\",\n                                                    (unsigned) i, tbl->map[i]);\n                }\n                else {\n                    PerlIO_printf(Perl_debug_log,\" %02x=>%02x\",\n                                                    (unsigned) i, tbl->map[i]);\n                }\n                if ((i+1) % 8 == 0 || i + 1 == (short) tbl->size) {\n                    PerlIO_printf(Perl_debug_log,\"\\n\");\n                }\n            }\n            PerlIO_printf(Perl_debug_log,\"Final map 0x%x=>%02x\\n\",\n                                    (unsigned) tbl->size, tbl->map[tbl->size]);\n        };\n#endif\n\n        SvREFCNT_dec(t_invlist);\n\n#if 0   /* code that added excess above-255 chars at the end of the table, in\n           case we ever want to not use the inversion map implementation for\n           this */\n\n        ASSUME(j <= rlen);\n        excess = rlen - j;\n\n        if (excess) {\n            /* More replacement chars than search chars:\n             * store excess replacement chars at end of main table.\n             */\n\n            struct_size += excess;\n            tbl = (OPtrans_map*)PerlMemShared_realloc(tbl,\n                        struct_size + excess * sizeof(short));\n            tbl->size += excess;\n            cPVOPo->op_pv = (char*)tbl;\n\n            for (i = 0; i < excess; i++)\n                tbl->map[i + 256] = r[j+i];\n        }\n        else {\n            /* no more replacement chars than search chars */\n        }\n#endif\n\n    }\n\n    DEBUG_y(PerlIO_printf(Perl_debug_log,\n            \"/d=%d, /s=%d, /c=%d, identical=%d, grows=%d,\"\n            \" use_svop=%d, can_force_utf8=%d,\\nexpansion=%\" NVgf \"\\n\",\n            del, squash, complement,\n            cBOOL(o->op_private & OPpTRANS_IDENTICAL),\n            cBOOL(o->op_private & OPpTRANS_USE_SVOP),\n            (o->op_private & OPpTRANS_MASK) == OPpTRANS_GROWS,\n            (o->op_private & OPpTRANS_MASK) == OPpTRANS_CAN_FORCE_UTF8,\n            max_expansion));\n\n    Safefree(r_map);\n\n    if(del && rlen != 0 && r_count == t_count) {\n        ck_warner(packWARN(WARN_MISC), \"Useless use of /d modifier in transliteration operator\");\n    } else if(r_count > t_count) {\n        ck_warner(packWARN(WARN_MISC), \"Replacement list is longer than search list\");\n    }\n\n    op_free(expr);\n    op_free(repl);\n\n    return o;\n}\n\n\n/*\n=for apidoc newPMOP\n\nConstructs, checks, and returns an op of any pattern matching type.\nC<type> is the opcode.  C<flags> gives the eight bits of C<op_flags>\nand, shifted up eight bits, the eight bits of C<op_private>.\n\n=cut\n*/\n\nOP *", "target": 0}
{"idx": 118, "func": "int handle__suback(struct mosquitto *mosq)\n{\n\tuint16_t mid;\n\tuint8_t qos;\n\tint *granted_qos;\n\tint qos_count;\n\tint i = 0;\n\tint rc;\n\tmosquitto_property *properties = NULL;\n\n\tassert(mosq);\n\n\tif(mosquitto__get_state(mosq) != mosq_cs_active){\n\t\treturn MOSQ_ERR_PROTOCOL;\n\t}\n\tif(mosq->in_packet.command != CMD_SUBACK){\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n#ifdef WITH_BROKER\n\tif(mosq->bridge == NULL){\n\t\t/* Client is not a bridge, so shouldn't be sending SUBACK */\n\t\treturn MOSQ_ERR_PROTOCOL;\n\t}\n\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received SUBACK from %s\", SAFE_PRINT(mosq->id));\n#else\n\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Client %s received SUBACK\", SAFE_PRINT(mosq->id));\n#endif\n\trc = packet__read_uint16(&mosq->in_packet, &mid);\n\tif(rc) return rc;\n\tif(mid == 0) return MOSQ_ERR_PROTOCOL;\n\n\tif(mosq->protocol == mosq_p_mqtt5){\n\t\trc = property__read_all(CMD_SUBACK, &mosq->in_packet, &properties);\n\t\tif(rc) return rc;\n\t}\n\n\tqos_count = (int)(mosq->in_packet.remaining_length - mosq->in_packet.pos);\n\tgranted_qos = mosquitto__malloc((size_t)qos_count*sizeof(int));\n\tif(!granted_qos){\n#ifdef WITH_BROKER\n\t\tmosquitto_property_free_all(&properties);\n#endif\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\twhile(mosq->in_packet.pos < mosq->in_packet.remaining_length){\n\t\trc = packet__read_byte(&mosq->in_packet, &qos);\n\t\tif(rc){\n\t\t\tmosquitto__free(granted_qos);\n#ifdef WITH_BROKER\n\t\t\tmosquitto_property_free_all(&properties);\n#endif\n\t\t\treturn rc;\n\t\t}\n\t\tgranted_qos[i] = (int)qos;\n\t\ti++;\n\t}\n#ifdef WITH_BROKER\n\t/* Immediately free, we don't do anything with Reason String or User Property at the moment */\n\tmosquitto_property_free_all(&properties);\n#else\n\tpthread_mutex_lock(&mosq->callback_mutex);\n\tif(mosq->on_subscribe){\n\t\tmosq->in_callback = true;\n\t\tmosq->on_subscribe(mosq, mosq->userdata, mid, qos_count, granted_qos);\n\t\tmosq->in_callback = false;\n\t}\n\tif(mosq->on_subscribe_v5){\n\t\tmosq->in_callback = true;\n\t\tmosq->on_subscribe_v5(mosq, mosq->userdata, mid, qos_count, granted_qos, properties);\n\t\tmosq->in_callback = false;\n\t}\n\tpthread_mutex_unlock(&mosq->callback_mutex);\n\tmosquitto_property_free_all(&properties);\n#endif\n\tmosquitto__free(granted_qos);\n\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"idx": 119, "func": "int handle__suback(struct mosquitto *mosq)\n{\n\tuint16_t mid;\n\tuint8_t qos;\n\tint *granted_qos;\n\tint qos_count;\n\tint i = 0;\n\tint rc;\n\tmosquitto_property *properties = NULL;\n\n\tassert(mosq);\n\n\tif(mosquitto__get_state(mosq) != mosq_cs_active){\n\t\treturn MOSQ_ERR_PROTOCOL;\n\t}\n\tif(mosq->in_packet.command != CMD_SUBACK){\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n#ifdef WITH_BROKER\n\tif(mosq->bridge == NULL){\n\t\t/* Client is not a bridge, so shouldn't be sending SUBACK */\n\t\treturn MOSQ_ERR_PROTOCOL;\n\t}\n\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received SUBACK from %s\", SAFE_PRINT(mosq->id));\n#else\n\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Client %s received SUBACK\", SAFE_PRINT(mosq->id));\n#endif\n\trc = packet__read_uint16(&mosq->in_packet, &mid);\n\tif(rc) return rc;\n\tif(mid == 0) return MOSQ_ERR_PROTOCOL;\n\n\tif(mosq->protocol == mosq_p_mqtt5){\n\t\trc = property__read_all(CMD_SUBACK, &mosq->in_packet, &properties);\n\t\tif(rc) return rc;\n\t}\n\n\tqos_count = (int)(mosq->in_packet.remaining_length - mosq->in_packet.pos);\n\tif(qos_count == 0) return MOSQ_ERR_PROTOCOL;\n\tgranted_qos = mosquitto__malloc((size_t)qos_count*sizeof(int));\n\tif(!granted_qos){\n#ifdef WITH_BROKER\n\t\tmosquitto_property_free_all(&properties);\n#endif\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\twhile(mosq->in_packet.pos < mosq->in_packet.remaining_length){\n\t\trc = packet__read_byte(&mosq->in_packet, &qos);\n\t\tif(rc){\n\t\t\tmosquitto__free(granted_qos);\n#ifdef WITH_BROKER\n\t\t\tmosquitto_property_free_all(&properties);\n#endif\n\t\t\treturn rc;\n\t\t}\n\t\tgranted_qos[i] = (int)qos;\n\t\ti++;\n\t}\n#ifdef WITH_BROKER\n\t/* Immediately free, we don't do anything with Reason String or User Property at the moment */\n\tmosquitto_property_free_all(&properties);\n#else\n\tpthread_mutex_lock(&mosq->callback_mutex);\n\tif(mosq->on_subscribe){\n\t\tmosq->in_callback = true;\n\t\tmosq->on_subscribe(mosq, mosq->userdata, mid, qos_count, granted_qos);\n\t\tmosq->in_callback = false;\n\t}\n\tif(mosq->on_subscribe_v5){\n\t\tmosq->in_callback = true;\n\t\tmosq->on_subscribe_v5(mosq, mosq->userdata, mid, qos_count, granted_qos, properties);\n\t\tmosq->in_callback = false;\n\t}\n\tpthread_mutex_unlock(&mosq->callback_mutex);\n\tmosquitto_property_free_all(&properties);\n#endif\n\tmosquitto__free(granted_qos);\n\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 0}
{"idx": 120, "func": "int LibRaw::phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, sum;\n#if 0\n  int val[4], dev[4], max;\n#endif\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {\n      {-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n      {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n  std::vector<unsigned> badCols;\n\n  if (!meta_length)\n    return 0;\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n  try\n  {\n    while (entries--)\n    {\n      checkCancel();\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n#if 1\n\t  if (ifp->eof())\n\t  {\n\t\t  // skip bad or unknown tag\n\t\t  fseek(ifp, save, SEEK_SET);\n\t\t  continue;\n\t  }\n#endif\n      if (tag == 0x0400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n#if 0\n            // Original code by Dave Coffin - it works better by\n            // not employing special logic for G1 channel below.\n            // Alternatively this column remap (including G1 channel\n            // logic) should be called prior to black subtraction\n            // unlike other corrections\n            for (row = 0; row < raw_height; row++)\n            {\n              if (FC(row - top_margin, col - left_margin)==1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = p1raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += p1raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) =\n                  0.5 + sum * 0.0732233 +\n                  (p1raw(row, col - 2) + p1raw(row, col + 2)) * 0.3535534;\n              }\n            }\n#else\n            // accumulae bad columns to be sorted later\n            badCols.push_back(col);\n#endif\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            unsigned count = 0;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += p1rawc(row + dir[i][0], col + dir[i][1], count);\n            if (count)\n              RAW(row, col) = (sum + (count >> 1)) / count;\n          }\n        }\n      }\n      else if (tag == 0x0419)\n      { /* Polynomial curve - output calibraion */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x041a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x0401)\n      { /* All-color flat fields - luma calibration*/\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x0416 || tag == 0x0410)\n      {\n        // 0x410 - luma calibration\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x040b)\n      { /* Red+blue flat field - croma calibration */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x0412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x041f && !qlin_applied)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n\t\tbool baddiv = false;\n        for (qr = 0; qr < 2; qr++)\n\t\t\tfor (qc = 0; qc < 2; qc++)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\t\tlc[qr][qc][i] = get4();\n\t\t\t\tif (lc[qr][qc][15] == 0)\n\t\t\t\t\tbaddiv = true;\n\t\t\t}\n\t\tif(baddiv)\n\t\t\tcontinue;\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x041e && !qmult_applied)\n      { /* Quadrant multipliers - output calibraion */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= (unsigned)ph1.split_row][col >= (unsigned)ph1.split_col] *\n                RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x0431 && !qmult_applied)\n      { /* Quadrant combined - four tile gain calibration */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (!badCols.empty())\n    {\n      qsort(badCols.data(), badCols.size(), sizeof(unsigned), unsigned_cmp);\n      bool prevIsolated = true;\n      for (i = 0; i < (int)badCols.size(); ++i)\n      {\n        bool nextIsolated = i == ((int)(badCols.size()-1)) || badCols[i+1]>badCols[i]+4;\n        for (row = 0; row < raw_height; ++row)\n          if (prevIsolated && nextIsolated)\n            phase_one_fix_pixel_grad(row,badCols[i]);\n          else\n            phase_one_fix_col_pixel_avg(row,badCols[i]);\n        prevIsolated = nextIsolated;\n      }\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n        checkCancel();\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n            frac = (j == 0 || j == head[1])\n                       ? 0\n                       : (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]);\n            mult[i - cip] = yval[0][k - 1] * frac + yval[0][k] * (1 - frac);\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n  return 0;\n}", "target": 1}
{"idx": 121, "func": "int LibRaw::phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, sum;\n#if 0\n  int val[4], dev[4], max;\n#endif\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {\n      {-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n      {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n  std::vector<unsigned> badCols;\n\n  if (!meta_length)\n    return 0;\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n  try\n  {\n    while (entries--)\n    {\n      checkCancel();\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n#if 1\n\t  if (ifp->eof())\n\t  {\n\t\t  // skip bad or unknown tag\n\t\t  fseek(ifp, save, SEEK_SET);\n\t\t  continue;\n\t  }\n#endif\n      if (tag == 0x0400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n#if 0\n            // Original code by Dave Coffin - it works better by\n            // not employing special logic for G1 channel below.\n            // Alternatively this column remap (including G1 channel\n            // logic) should be called prior to black subtraction\n            // unlike other corrections\n            for (row = 0; row < raw_height; row++)\n            {\n              if (FC(row - top_margin, col - left_margin)==1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = p1raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += p1raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) =\n                  0.5 + sum * 0.0732233 +\n                  (p1raw(row, col - 2) + p1raw(row, col + 2)) * 0.3535534;\n              }\n            }\n#else\n            // accumulae bad columns to be sorted later\n            badCols.push_back(col);\n#endif\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            unsigned count = 0;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += p1rawc(row + dir[i][0], col + dir[i][1], count);\n            if (count)\n              RAW(row, col) = (sum + (count >> 1)) / count;\n          }\n        }\n      }\n      else if (tag == 0x0419)\n      { /* Polynomial curve - output calibraion */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x041a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x0401)\n      { /* All-color flat fields - luma calibration*/\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x0416 || tag == 0x0410)\n      {\n        // 0x410 - luma calibration\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x040b)\n      { /* Red+blue flat field - croma calibration */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x0412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x041f && !qlin_applied)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n\t\tbool baddiv = false;\n        for (qr = 0; qr < 2; qr++)\n\t\t\tfor (qc = 0; qc < 2; qc++)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\t\tlc[qr][qc][i] = get4();\n\t\t\t\tif (lc[qr][qc][15] == 0)\n\t\t\t\t\tbaddiv = true;\n\t\t\t}\n\t\tif(baddiv)\n\t\t\tcontinue;\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x041e && !qmult_applied)\n      { /* Quadrant multipliers - output calibraion */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= (unsigned)ph1.split_row][col >= (unsigned)ph1.split_col] *\n                RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x0431 && !qmult_applied)\n      { /* Quadrant combined - four tile gain calibration */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (!badCols.empty())\n    {\n      qsort(badCols.data(), badCols.size(), sizeof(unsigned), unsigned_cmp);\n      bool prevIsolated = true;\n      for (i = 0; i < (int)badCols.size(); ++i)\n      {\n        bool nextIsolated = i == ((int)(badCols.size()-1)) || badCols[i+1]>badCols[i]+4;\n        for (row = 0; row < raw_height; ++row)\n          if (prevIsolated && nextIsolated)\n            phase_one_fix_pixel_grad(row,badCols[i]);\n          else\n            phase_one_fix_col_pixel_avg(row,badCols[i]);\n        prevIsolated = nextIsolated;\n      }\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n\t  unsigned w0 = head[1] * head[3], w1 = head[2] * head[4];\n\t  if (w0 > 10240000 || w1 > 10240000)\n\t\t  throw LIBRAW_EXCEPTION_ALLOC;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n        checkCancel();\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n\t\t\tif (j == 0 || j == head[1] || k < 1 || k >= w0+w1)\n\t\t\t\tfrac = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint xdiv = (xval[0][k] - xval[0][k - 1]);\n\t\t\t\tfrac = xdiv ? (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]) : 0;\n\t\t\t}\n\t\t\tif (k < w0 + w1)\n\t\t\t\tmult[i - cip] = yval[0][k > 0 ? k - 1 : 0] * frac + yval[0][k] * (1 - frac);\n\t\t\telse\n\t\t\t\tmult[i - cip] = 0;\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n  return 0;\n}", "target": 0}
{"idx": 122, "func": "int LibRaw::parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save, utmp;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n\n  ushort *rafdata;\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n\n  if (libraw_internal_data.unpacker_data.ifd0_offset == -1LL)\n    libraw_internal_data.unpacker_data.ifd0_offset = base;\n\n  entries = get2();\n  if (entries > 512)\n    return 1;\n\n  INT64 fsize = ifp->size();\n\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && savepos + len > 2 * fsize)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data,\n                        tag | (is_pana_raw ? 0x30000 : ((ifd + 1) << 20)), type,\n                        len, order, ifp, base);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n\n    if (!is_pana_raw)\n    { /* processing of EXIF tags that collide w/ PanasonicRaw tags */\n      switch (tag)\n      {\n      case 0x0001:\n        if (len == 4)\n          is_pana_raw = get4();\n        break;\n      case 0x000b: /* 11, Std. EXIF Software tag */\n        fgets(software, 64, ifp);\n        if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) ||\n            !strncmp(software, \"UFRaw\", 5) || !strncmp(software, \"Bibble\", 6) ||\n            !strcmp(software, \"Digital Photo Professional\"))\n          is_raw = 0;\n        break;\n      case 0x001c: /*  28, safeguard, probably not needed */\n      case 0x001d: /*  29, safeguard, probably not needed */\n      case 0x001e: /*  30, safeguard, probably not needed */\n        cblack[tag - 0x001c] = get2();\n        cblack[3] = cblack[1];\n        break;\n\n      case 0x0111: /* 273, StripOffset */\n        if (len > 1 && len < 16384)\n        {\n          off_t sav = ftell(ifp);\n          tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n          tiff_ifd[ifd].strip_offsets_count = len;\n          for (int ii = 0; ii < (int)len; ii++)\n            tiff_ifd[ifd].strip_offsets[ii] = get4() + base;\n          fseek(ifp, sav, SEEK_SET); // restore position\n        }\n        /* fallback */\n      case 0x0201: /* 513, JpegIFOffset */\n      case 0xf007: // 61447\n        tiff_ifd[ifd].offset = get4() + base;\n        if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n        {\n          fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n          if (ljpeg_start(&jh, 1))\n          {\n            if (!dng_version && !strcasecmp(make, \"SONY\") && tiff_ifd[ifd].phint == 32803 &&\n                tiff_ifd[ifd].comp == 7) // Sony/lossless compressed IFD\n            {\n              tiff_ifd[ifd].comp = 6;\n              tiff_ifd[ifd].bps = jh.bits;\n              tiff_ifd[ifd].samples = 1;\n            }\n            else\n            {\n              tiff_ifd[ifd].comp = 6;\n              tiff_ifd[ifd].bps = jh.bits;\n              tiff_ifd[ifd].t_width = jh.wide;\n              tiff_ifd[ifd].t_height = jh.high;\n              tiff_ifd[ifd].samples = jh.clrs;\n              if (!(jh.sraw || (jh.clrs & 1)))\n                tiff_ifd[ifd].t_width *= jh.clrs;\n              if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n              {\n                tiff_ifd[ifd].t_width /= 2;\n                tiff_ifd[ifd].t_height *= 2;\n              }\n              i = order;\n              parse_tiff(tiff_ifd[ifd].offset + 12);\n              order = i;\n            }\n          }\n        }\n        break;\n      }\n    }\n    else\n    { /* processing Panasonic-specific \"PanasonicRaw\" tags */\n      switch (tag)\n      {\n      case 0x0004: /*   4, SensorTopBorder */\n        imgdata.sizes.raw_inset_crops[0].ctop = get2();\n        break;\n      case 0x000a: /*  10, BitsPerSample */\n        pana_bpp = get2();\n\t\tpana_bpp = LIM(pana_bpp, 8, 16);\n        break;\n      case 0x000b: /*  11, Compression */\n        imPana.Compression = get2();\n        break;\n      case 0x000e: /*  14, LinearityLimitRed */\n      case 0x000f: /*  15, LinearityLimitGreen */\n      case 0x0010: /*  16, LinearityLimitBlue */\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (imgdata.color.linear_max[tag - 14] == 16383)\n            imgdata.color.linear_max[tag - 14] -= 64;\n        if (imgdata.color.linear_max[tag - 14] == 4095)\n          imgdata.color.linear_max[tag - 14] -= 16;\n        if (tag == 0x000f) // 15, LinearityLimitGreen\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        break;\n      case 0x0013: /*  19, WBInfo */\n        if ((i = get2()) > 0x100)\n          break;\n        for (c = 0; c < i; c++)\n        {\n          if ((j = get2()) < 0x100)\n          {\n\t\t\t  if (j >= 0) {\n\t\t\t\t  icWBC[j][0] = get2();\n\t\t\t\t  icWBC[j][2] = get2();\n\t\t\t\t  icWBC[j][1] = icWBC[j][3] =\n\t\t\t\t\t  0x100;\n\t\t\t  }\n          }\n          else // light source out of EXIF numbers range\n            get4();\n        }\n        break;\n      case 0x0018: /* 24, HighISOMultiplierRed */\n      case 0x0019: /* 25, HighISOMultiplierGreen */\n      case 0x001a: /* 26, HighISOMultiplierBlue */\n        imPana.HighISOMultiplier[tag - 0x0018] = get2();\n        break;\n      case 0x001c: /*  28, BlackLevelRed */\n      case 0x001d: /*  29, BlackLevelGreen */\n      case 0x001e: /*  30, BlackLevelBlue */\n        pana_black[tag - 0x001c] = get2();\n        break;\n      case 0x002d: /*  45, RawFormat */\n                   /* pana_encoding: tag 0x002d (45dec)\n                        not used - DMC-LX1/FZ30/FZ50/L1/LX1/LX2\n                        2 - RAW DMC-FZ8/FZ18\n                        3 - RAW DMC-L10\n                        4 - RW2 for most other models, including G9 in \"pixel shift off\"\n                      mode and YUNEEC CGO4            (must add 15 to black levels for\n                      RawFormat == 4)            5 - RW2 DC-GH5s; G9 in \"pixel shift on\"\n                      mode            6 - RW2            DC-S1, DC-S1R in \"pixel shift off\"\n                      mode            7 -            RW2 DC-S1R (probably            DC-S1 too) in\n                      \"pixel shift on\" mode\n                   */\n        pana_encoding = get2();\n        break;\n      case 0x002f: /*  47, CropTop */\n        imgdata.sizes.raw_inset_crops[0].ctop = get2();\n        break;\n      case 0x0030: /*  48, CropLeft */\n        imgdata.sizes.raw_inset_crops[0].cleft = get2();\n        break;\n      case 0x0031: /*  49, CropBottom */\n        imgdata.sizes.raw_inset_crops[0].cheight =\n            get2() - imgdata.sizes.raw_inset_crops[0].ctop;\n        break;\n      case 0x0032: /*  50, CropRight */\n        imgdata.sizes.raw_inset_crops[0].cwidth =\n            get2() - imgdata.sizes.raw_inset_crops[0].cleft;\n        break;\n      case 0x0037: /*  55, ISO if  ISO in 0x8827 & ISO in 0x0017 == 65535 */\n        if (iso_speed == 65535)\n          iso_speed = get4();\n        break;\n      case 0x011c: /* 284, Gamma */\n      {\n        int n = get2();\n        if (n >= 1024)\n          imPana.gamma = (float)n / 1024.0f;\n        else if (n >= 256)\n          imPana.gamma = (float)n / 256.0f;\n        else\n          imPana.gamma = (float)n / 100.0f;\n      }\n      break;\n      case 0x0120: /* 288, CameraIFD, contains tags 0x1xxx, 0x2xxx, 0x3xxx */\n      {\n        unsigned sorder = order;\n        unsigned long sbase = base;\n        base = ftell(ifp);\n        order = get2();\n        fseek(ifp, 2, SEEK_CUR);\n        fseek(ifp, INT64(get4()) - 8LL, SEEK_CUR);\n        parse_tiff_ifd(base);\n        base = sbase;\n        order = sorder;\n      }\n      break;\n      case 0x0121: /* 289, Multishot, 0 is Off, 65536 is Pixel Shift */\n        imPana.Multishot = get4();\n        break;\n      case 0x1001:\n      \tif (imPana.Multishot == 0) {\n      \t  imPana.Multishot = get4();\n      \t  if (imPana.Multishot)\n      \t    imPana.Multishot += 65535;\n      \t}\n        break;\n      case 0x1100:\n        imPana.FocusStepNear = get2();\n        break;\n      case 0x1101:\n        imPana.FocusStepCount = get2();\n        break;\n      case 0x1105:\n        imPana.ZoomPosition = get4();\n        break;\n      case 0x1201:\n        if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT)) {\n          imPana.LensManufacturer = fgetc(ifp);\n        } else if (type == 258) {\n          imPana.LensManufacturer = get4();\n          if (imPana.LensManufacturer >= 257) {\n            ilm.LensMount = LIBRAW_MOUNT_LPS_L;\n            ilm.LensFormat = LIBRAW_FORMAT_FF;\n          }\n        }\n        break;\n      case 0x1202:\n        if (ilm.LensMount == LIBRAW_MOUNT_LPS_L) {\n          if ((utmp = get2())) ilm.LensID = utmp;\n        } else if ((imPana.LensManufacturer != 0xff) &&\n                   (imPana.LensManufacturer != 0xffffffff)) {\n          if ((utmp = (fgetc(ifp) << 8) | fgetc(ifp)))\n            ilm.LensID = (imPana.LensManufacturer << 16) + utmp;\n        }\n        break;\n      case 0x1203: /* 4611, FocalLengthIn35mmFormat, contained in 0x0120\n                      CameraIFD */\n        if (imgdata.lens.FocalLengthIn35mmFormat < 0.65f)\n          imgdata.lens.FocalLengthIn35mmFormat = get2();\n        break;\n      case 0x2009: /* 8201, contained in 0x0120 CameraIFD */\n        if ((pana_encoding == 4) || (pana_encoding == 5))\n        {\n          i = MIN(8, len);\n          int permut[8] = {3, 2, 1, 0, 3 + 4, 2 + 4, 1 + 4, 0 + 4};\n          imPana.BlackLevelDim = len;\n          for (j = 0; j < i; j++)\n          {\n            imPana.BlackLevel[permut[j]] =\n                (float)(get2()) / (float)(powf(2.f, 14.f - pana_bpp));\n          }\n        }\n        break;\n      case 0x3420: /* 13344, WB_RedLevelAuto, contained in 0x0120 CameraIFD */\n        icWBC[LIBRAW_WBI_Auto][0] = get2();\n        icWBC[LIBRAW_WBI_Auto][1] = icWBC[LIBRAW_WBI_Auto][3] = 1024.0f;\n        break;\n      case 0x3421: /* 13345, WB_BlueLevelAuto, contained in 0x0120 CameraIFD */\n        icWBC[LIBRAW_WBI_Auto][2] = get2();\n        break;\n      case 0x0002: /*   2, ImageWidth */\n        tiff_ifd[ifd].t_width = getint(type);\n        break;\n      case 0x0003: /*   3, ImageHeight */\n        tiff_ifd[ifd].t_height = getint(type);\n        break;\n      case 0x0005: /*   5, SensorLeftBorder */\n        width = get2();\n        imgdata.sizes.raw_inset_crops[0].cleft = width;\n        break;\n      case 0x0006: /*   6, SensorBottomBorder */\n        height = get2();\n        imgdata.sizes.raw_inset_crops[0].cheight =\n            height - imgdata.sizes.raw_inset_crops[0].ctop;\n        break;\n      case 0x0007: /*   7, SensorRightBorder */\n        i = get2();\n        width += i;\n        imgdata.sizes.raw_inset_crops[0].cwidth =\n            i - imgdata.sizes.raw_inset_crops[0].cleft;\n        break;\n      case 0x0009: /*   9, CFAPattern */\n        if ((i = get2()))\n          filters = i;\n        break;\n      case 0x0011: /*  17, RedBalance */\n      case 0x0012: /*  18, BlueBalance */\n        if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT) && len == 1)\n          cam_mul[(tag - 0x0011) * 2] = get2() / 256.0;\n        break;\n      case 0x0017: /*  23, ISO */\n        if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT))\n          iso_speed = get2();\n        break;\n      case 0x0024: /*  36, WBRedLevel */\n      case 0x0025: /*  37, WBGreenLevel */\n      case 0x0026: /*  38, WBBlueLevel */\n        cam_mul[tag - 0x0024] = get2();\n        break;\n      case 0x0027: /*  39, WBInfo2 */\n        if ((i = get2()) > 0x100)\n          break;\n        for (c = 0; c < i; c++)\n        {\n          if ((j = get2()) < 0x100)\n          {\n           if(j >= 0) {\n            icWBC[j][0] = get2();\n            icWBC[j][1] = icWBC[j][3] = get2();\n            icWBC[j][2] = get2();\n            if (c == 1 && i > 6 && cam_mul[0] <= 0.001f)\n                for (int q = 0; q < 4; q++)\n                    cam_mul[q] = icWBC[j][q];\n\t   }\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n        break;\n      case 0x002e: /*  46, JpgFromRaw */\n        if ((type != LIBRAW_EXIFTAG_TYPE_UNDEFINED) || (fgetc(ifp) != 0xff) || (fgetc(ifp) != 0xd8))\n          break;\n        thumb_offset = ftell(ifp) - 2;\n        thumb_length = len;\n        break;\n\n      case 0x0118: /* 280, Panasonic RW2 offset */\n        if (type != LIBRAW_EXIFTAG_TYPE_LONG)\n          break;\n        load_raw = &LibRaw::panasonic_load_raw;\n        load_flags = 0x2008;\n      case 0x0111: /* 273, StripOffset */\n        if (len > 1 && len < 16384)\n        {\n          off_t sav = ftell(ifp);\n          tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n          tiff_ifd[ifd].strip_offsets_count = len;\n          for (int ii = 0; ii < (int)len; ii++)\n            tiff_ifd[ifd].strip_offsets[ii] = get4() + base;\n          fseek(ifp, sav, SEEK_SET); // restore position\n        }\n        /* fallthrough */\n        tiff_ifd[ifd].offset = get4() + base;\n        if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n        {\n          fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n          if (ljpeg_start(&jh, 1))\n          {\n            tiff_ifd[ifd].comp = 6;\n            tiff_ifd[ifd].t_width = jh.wide;\n            tiff_ifd[ifd].t_height = jh.high;\n            tiff_ifd[ifd].bps = jh.bits;\n            tiff_ifd[ifd].samples = jh.clrs;\n            if (!(jh.sraw || (jh.clrs & 1)))\n              tiff_ifd[ifd].t_width *= jh.clrs;\n            if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n            {\n              tiff_ifd[ifd].t_width /= 2;\n              tiff_ifd[ifd].t_height *= 2;\n            }\n            i = order;\n            parse_tiff(tiff_ifd[ifd].offset + 12);\n            order = i;\n          }\n        }\n        break;\n      }\n\n    } /* processing of Panasonic-specific tags finished */\n\n    switch (tag)\n    {            /* processing of general EXIF tags */\n    case 0xf000: /* 61440, Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 0x00fe: /* NewSubfileType */\n      tiff_ifd[ifd].newsubfiletype = getreal(type);\n      break;\n    case 0x0100: /* 256, ImageWidth */\n    case 0xf001: /* 61441, Fuji RAF RawImageFullWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 0x0101: /* 257, ImageHeight */\n    case 0xf002: /* 61442, Fuji RAF RawImageFullHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 0x0102: /* 258, BitsPerSample */\n    case 0xf003: /* 61443, Fuji RAF 0xf003 */\n      if(!tiff_ifd[ifd].samples || tag != 0x0102) // ??? already set by tag 0x115\n        tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < (unsigned)tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 0xf006: /* 61446, Fuji RAF 0xf006 */\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &LibRaw::packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 0x0103: /* 259, Compression */\n                 /*\n                    262\t = Kodak 262\n                  32767  = Sony ARW Compressed\n                  32769  = Packed RAW\n                  32770  = Samsung SRW Compressed\n                  32772  = Samsung SRW Compressed 2\n                  32867  = Kodak KDC Compressed\n                  34713  = Nikon NEF Compressed\n                  65000  = Kodak DCR Compressed\n                  65535  = Pentax PEF Compressed\n                 */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 0x0106: /* 262, PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 0x010e: /* 270, ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 0x010f: /* 271, Make */\n      fgets(make, 64, ifp);\n      break;\n    case 0x0110: /* 272, Model */\n      if (!strncmp(make, \"Hasselblad\", 10) && model[0] &&\n          (imHassy.format != LIBRAW_HF_Imacon))\n        break;\n      fgets(model, 64, ifp);\n      break;\n    case 0x0116: // 278\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n    case 0x0112: /* 274, Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 0x0115: /* 277, SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 0x0152: /* Extrasamples */\n      tiff_ifd[ifd].extrasamples = (getint(type) & 0xff) + 1024;\n      break;\n    case 0x0117: /* 279, StripByteCounts */\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int ii = 0; ii < (int)len; ii++)\n          tiff_ifd[ifd].strip_byte_counts[ii] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n      /* fallback */\n    case 0x0202: // 514\n    case 0xf008: // 61448\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 0xf00e: // 61454, FujiFilm \"As Shot\"\n      FORC3 cam_mul[GRBG_2_RGBG(c)] = getint(type);\n      break;\n    case 0x0131: /* 305, Software */\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) ||\n          !strncmp(software, \"UFRaw\", 5) || !strncmp(software, \"Bibble\", 6) ||\n          !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 0x0132: /* 306, DateTime */\n      get_timestamp(0);\n      break;\n    case 0x013b: /* 315, Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 0x013d: // 317\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 0x0142: /* 322, TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 0x0143: /* 323, TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 0x0144: /* 324, TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &LibRaw::sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 0x0145: // 325\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 0x014a: /* 330, SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &LibRaw::sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n        if (ifd >= int(sizeof tiff_ifd / sizeof tiff_ifd[0]))\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        break;\n      }\n      if (!strncmp(make, \"Hasselblad\", 10) &&\n          libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 0x0153: // 339\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 0x0190: // 400\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n    case 0x02bc: // 700\n      if ((tagtypeIs(LIBRAW_EXIFTAG_TYPE_BYTE) ||\n          tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII) ||\n          tagtypeIs(LIBRAW_EXIFTAG_TYPE_SBYTE) ||\n          tagtypeIs(LIBRAW_EXIFTOOLTAGTYPE_binary)) &&\n          (len > 1) && (len < 5100000))\n      {\n        xmpdata = (char *)calloc(xmplen = len + 1,1);\n        unsigned br = fread(xmpdata,1, len, ifp);\n        xmpdata[br] = 0;\n      }\n      break;\n    case 0x7000:\n      imSony.SonyRawFileType = get2();\n      break;\n    case 0x7010: // 28688\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= (int)sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 0x7200: // 29184, Sony SR2Private\n      sony_offset = get4();\n      break;\n    case 0x7201: // 29185, Sony SR2Private\n      sony_length = get4();\n      break;\n    case 0x7221: // 29217, Sony SR2Private\n      sony_key = get4();\n      break;\n    case 0x7250: // 29264, Sony SR2Private\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 0x7303: // 29443, Sony SR2SubIFD\n      FORC4 cam_mul[GRBG_2_RGBG(c)] = get2();\n      break;\n    case 0x7313: // 29459, Sony SR2SubIFD\n      FORC4 cam_mul[RGGB_2_RGBG(c)] = get2();\n      break;\n    case 0x7310: // 29456, Sony SR2SubIFD\n      FORC4 cblack[RGGB_2_RGBG(c)] = get2();\n      i = cblack[3];\n      FORC3 if (i > (int)cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n      break;\n    case 0x827d: /* 33405, Model2 */\n                 /*\n                  for Kodak ProBack 645 PB645x-yyyy 'x' is:\n                  'M' for Mamiya 645\n                  'C' for Contax 645\n                  'H' for Hasselblad H-series\n                 */\n      fgets(model2, 64, ifp);\n      break;\n    case 0x828d: /* 33421, CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        tiff_ifd[ifd].t_filters = filters = 9;\n      break;\n    case 0x828e: /* 33422, CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 0xfd09: /* 64777, Kodak P-series */\n      if (len == 36)\n      {\n        tiff_ifd[ifd].t_filters = filters = 9;\n        colors = 3;\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < (int)plen && colors < 4; i++)\n        {\n          if (cfa_pat[i] > 31)\n            continue; // Skip wrong data\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 0x8290: // 33424\n    case 0xfe00: // 65024\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 0x829a: /* 33434, ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 0x829d: /* 33437, FNumber */\n      aperture = getreal(type);\n      break;\n    case 0x9400:\n      imCommon.exifAmbientTemperature = getreal(type);\n      if ((imCommon.CameraTemperature > -273.15f) &&\n          ((OlyID == OlyID_TG_5) || (OlyID == OlyID_TG_6)))\n        imCommon.CameraTemperature +=\n            imCommon.exifAmbientTemperature;\n      break;\n    case 0x9401:\n      imCommon.exifHumidity = getreal(type);\n      break;\n    case 0x9402:\n      imCommon.exifPressure = getreal(type);\n      break;\n    case 0x9403:\n      imCommon.exifWaterDepth = getreal(type);\n      break;\n    case 0x9404:\n      imCommon.exifAcceleration = getreal(type);\n      break;\n    case 0x9405:\n      imCommon.exifCameraElevationAngle = getreal(type);\n      break;\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa420: /* 42016, ImageUniqueID */\n      stmread(imgdata.color.ImageUniqueID, len, ifp);\n      break;\n    case 0xc65d: /* 50781, RawDataUniqueID */\n      imgdata.color.RawDataUniqueID[16] = 0;\n      fread(imgdata.color.RawDataUniqueID, 1, 16, ifp);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      break;\n    case 0x8602: /* 34306, Leaf white balance */\n      FORC4\n      {\n        int q = get2();\n        if (q)\n          cam_mul[GRGB_2_RGBG(c)] = 4096.0 / q;\n      }\n      break;\n    case 0x8603: /* 34307, Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][GRGB_2_RGBG(c)]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 0x8606: /* 34310, Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 0x85ff: // 34303\n      strcpy(make, \"Leaf\");\n      break;\n    case 0x8769: /* 34665, EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 0x8825: /* 34853, GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n    }\n    break;\n    case 0x8773: /* 34675, InterColorProfile */\n    case 0xc68f: /* 50831, AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 0x9102: /* 37122, CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 0x920a: /* 37386, FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 0x9211: /* 37393, ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 0x9215: /* 37397, ExposureIndex */\n      imCommon.exifExposureIndex = getreal(type);\n      break;\n    case 0x9218: /* 37400, old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 0xa010: // 40976\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 0x8002: // 32770\n        load_raw = &LibRaw::samsung_load_raw;\n        break;\n      case 0x8004: // 32772\n        load_raw = &LibRaw::samsung2_load_raw;\n        break;\n      case 0x8005: // 32773\n        load_raw = &LibRaw::samsung3_load_raw;\n        break;\n      }\n      break;\n    case 0xb4c3: /* 46275, Imacon tags */\n      imHassy.format = LIBRAW_HF_Imacon;\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 0xb4c7: // 46279\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 0xb4c2: // 46274\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * (height * 6l) == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      c = unsigned(height) * unsigned(width) / 1000000;\n      if (c == 32)\n        c--;\n      sprintf(model, \"Ixpress %d-Mp\", c);\n      load_raw = &LibRaw::imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &LibRaw::unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 0xc516: /* 50454, Sinar tag */\n    case 0xc517: // 50455\n      if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n      if (fread(cbuf, 1, len, ifp) != (int)len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 0xc51a: // 50458\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 0xc51b: /* 50459, Hasselblad tag */\n      if (!libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n        i = order;\n        j = ftell(ifp);\n        c = tiff_nifds;\n        order = get2();\n        fseek(ifp, j + (get2(), get4()), SEEK_SET);\n        parse_tiff_ifd(j);\n        maximum = 0xffff;\n        tiff_nifds = c;\n        order = i;\n        break;\n      }\n    case 0xc612: /* 50706, DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 0xc614: /* 50708, UniqueCameraModel */\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      if (model[0])\n        break;\n      strncpy(make, imgdata.color.UniqueCameraModel,\n              MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 0xc616: /* 50710, CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      tiff_ifd[ifd].t_filters = filters;\n      break;\n    case 0xc617: /* 50711, CFALayout */\n      if (get2() == 2)\n        tiff_ifd[ifd].t_fuji_width = fuji_width = 1;\n      break;\n    case 0x0123: // 291\n    case 0xc618: /* 50712, LinearizationTable */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_LINTABLE;\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n      linear_table(len);\n      break;\n    case 0xc619: /* 50713, BlackLevelRepeatDim */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n      tiff_ifd[ifd].dng_levels.dng_fcblack[4] =\n          tiff_ifd[ifd].dng_levels.dng_cblack[4] = cblack[4] = get2();\n      tiff_ifd[ifd].dng_levels.dng_fcblack[5] =\n          tiff_ifd[ifd].dng_levels.dng_cblack[5] = cblack[5] = get2();\n      if (cblack[4] * cblack[5] >\n          (LIBRAW_CBLACK_SIZE -\n           7)) // Use last cblack item as DNG black level count\n        tiff_ifd[ifd].dng_levels.dng_fcblack[4] =\n            tiff_ifd[ifd].dng_levels.dng_fcblack[5] =\n                tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n                    tiff_ifd[ifd].dng_levels.dng_cblack[5] = cblack[4] =\n                        cblack[5] = 1;\n      break;\n\n    case 0xf00c:\n      if (imFuji.RAFDataGeneration != 4096)\n      {\n        unsigned fwb[4];\n        FORC4 fwb[c] = get4();\n        if (fwb[3] < 0x100)\n        {\n          FORC3 icWBC[fwb[3]][GRBG_2_RGBG(c)] = fwb[c];\n          icWBC[fwb[3]][3] = icWBC[fwb[3]][1];\n          if ((fwb[3] == 17) &&                                      // Tungsten WB\n              (libraw_internal_data.unpacker_data.lenRAFData > 3) &&\n              (libraw_internal_data.unpacker_data.lenRAFData < 10240000))\n          {\n            INT64 f_save = ftell(ifp);\n            rafdata = (ushort *)calloc(\n                sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData,1);\n            fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n            fread(rafdata, sizeof(ushort),\n                  libraw_internal_data.unpacker_data.lenRAFData, ifp);\n            fseek(ifp, f_save, SEEK_SET);\n\n            uchar *PrivateMknBuf = (uchar *)rafdata;\n            int PrivateMknLength = libraw_internal_data.unpacker_data.lenRAFData\n                                   << 1;\n            for (int pos = 0; pos < PrivateMknLength - 16; pos++)\n            {\n              if (!memcmp(PrivateMknBuf + pos, \"TSNERDTS\", 8)) // STDRENST\n              {\n                imFuji.isTSNERDTS = 1;\n                break;\n              }\n            }\n            int fj; // 31? (fj<<1)-0x3c : 34? (fj<<1)-0x4e : undef\n            int is34 = 0;\n            if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3, GFX 100S\n                (imFuji.RAFDataVersion == 0x0261) || // X100V, GFX 50S II\n                (imFuji.RAFDataVersion == 0x0262) || // X-T4\n                (imFuji.RAFDataVersion == 0x0263) || // X-H2S\n                (imFuji.RAFDataVersion == 0x0264) || // X-S10\n                (imFuji.RAFDataVersion == 0x0265) || // X-E4\n                (imFuji.RAFDataVersion == 0x0266) || // X-T30 II\n                !strcmp(model, \"X-Pro3\")     ||\n                !strcmp(model, \"GFX 100S\")   ||\n                !strcmp(model, \"GFX100S\")    ||\n                !strcmp(model, \"GFX 50S II\") ||\n                !strcmp(model, \"GFX50S II\")  ||\n                !strcmp(model, \"X100V\")      ||\n                !strcmp(model, \"X-T4\")       ||\n                !strcmp(model, \"X-H2S\")      ||\n                !strcmp(model, \"X-E4\")       ||\n                !strcmp(model, \"X-T30 II\")   ||\n                !strcmp(model, \"X-S10\"))\n// is34 cameras have 34 CCT values instead of 31, manual still claims 2500 to 10000 K\n// aligned 3000 K to Incandescent, as it is usual w/ other Fujifilm cameras\n              is34 = 1;\n\n            for (int fi = 0;\n                 fi < int(libraw_internal_data.unpacker_data.lenRAFData - 3); fi++) // looking for Tungsten WB\n            {\n              if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) &&\n                  (fwb[2] == rafdata[fi + 2])) // found Tungsten WB\n              {\n                if (rafdata[fi - 15] !=\n                    fwb[0]) // 15 is offset of Tungsten WB from the first\n                            // preset, Fine Weather WB\n                  continue;\n                for (int wb_ind = 0, ofst = fi - 15; wb_ind < (int)Fuji_wb_list1.size();\n                     wb_ind++, ofst += 3)\n                {\n                  icWBC[Fuji_wb_list1[wb_ind]][1] =\n                      icWBC[Fuji_wb_list1[wb_ind]][3] = rafdata[ofst];\n                  icWBC[Fuji_wb_list1[wb_ind]][0] = rafdata[ofst + 1];\n                  icWBC[Fuji_wb_list1[wb_ind]][2] = rafdata[ofst + 2];\n                }\n\n                if (is34)\n                  fi += 24;\n                fi += 96;\n                for (fj = fi; fj < (fi + 15); fj += 3) // looking for the end of the WB table\n                {\n                  if (rafdata[fj] != rafdata[fi])\n                  {\n                    fj -= 93;\n                    if (is34)\n                      fj -= 9;\n// printf (\"wb start in DNG: 0x%04x\\n\", fj*2-0x4e);\n                    for (int iCCT = 0, ofst = fj; iCCT < 31;\n                         iCCT++, ofst += 3)\n                    {\n                      icWBCCTC[iCCT][0] = FujiCCT_K[iCCT];\n                      icWBCCTC[iCCT][1] = rafdata[ofst + 1];\n                      icWBCCTC[iCCT][2] = icWBCCTC[iCCT][4] = rafdata[ofst];\n                      icWBCCTC[iCCT][3] = rafdata[ofst + 2];\n                    }\n                    break;\n                  }\n                }\n                free(rafdata);\n                break;\n              }\n            }\n          }\n        }\n        FORC4 fwb[c] = get4();\n        if (fwb[3] < 0x100) {\n          FORC3 icWBC[fwb[3]][GRBG_2_RGBG(c)] = fwb[c];\n          icWBC[fwb[3]][3] = icWBC[fwb[3]][1];\n        }\n      }\n      break;\n    case 0xf00d:\n      if (imFuji.RAFDataGeneration != 4096)\n      {\n        FORC3 icWBC[LIBRAW_WBI_Auto][GRBG_2_RGBG(c)] = getint(type);\n        icWBC[LIBRAW_WBI_Auto][3] = icWBC[LIBRAW_WBI_Auto][1];\n      }\n      break;\n    case 0xc615: /* 50709, LocalizedCameraModel */\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n    case 0xf00a: // 61450\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 0xc61a: /* 50714, BlackLevel */\n      if (tiff_ifd[ifd].samples > 1 &&\n          tiff_ifd[ifd].samples == (int)len) // LinearDNG, per-channel black\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        for (i = 0; i < 4 && i < (int)len; i++)\n        {\n          tiff_ifd[ifd].dng_levels.dng_fcblack[i] = getreal(type);\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] =\n              tiff_ifd[ifd].dng_levels.dng_fcblack[i] + 0.5;\n        }\n        // Record len in last cblack field\n        tiff_ifd[ifd].dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1] = len;\n\n        tiff_ifd[ifd].dng_levels.dng_fblack =\n            tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else if (tiff_ifd[ifd].samples > 1 // Linear DNG w repeat dim\n               && (tiff_ifd[ifd].samples * cblack[4] * cblack[5] == len))\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        tiff_ifd[ifd].dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1] =\n            cblack[LIBRAW_CBLACK_SIZE - 1] = len;\n        for (i = 0; i < (int)len && i < LIBRAW_CBLACK_SIZE - 7; i++)\n        {\n          tiff_ifd[ifd].dng_levels.dng_fcblack[i + 6] = getreal(type);\n          tiff_ifd[ifd].dng_levels.dng_cblack[i + 6] = cblack[i + 6] =\n              tiff_ifd[ifd].dng_levels.dng_fcblack[i + 6] + 0.5;\n        }\n      }\n      else if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        tiff_ifd[ifd].dng_levels.dng_fblack = getreal(type);\n        black = tiff_ifd[ifd].dng_levels.dng_black =\n            tiff_ifd[ifd].dng_levels.dng_fblack;\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(int(cblack[4] * cblack[5]))\n        {\n          tiff_ifd[ifd].dng_levels.dng_fcblack[6 + c] = getreal(type);\n          cblack[6 + c] = tiff_ifd[ifd].dng_levels.dng_fcblack[6 + c];\n        }\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n        if (tag == 0xc61a)\n        {\n          tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n          FORC(int(cblack[4] * cblack[5]))\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_fblack = 0;\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_fcblack[c] =\n              tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n      }\n      break;\n    case 0xc61b: /* 50715, BlackLevelDeltaH */\n    case 0xc61c: /* 50716, BlackLevelDeltaV */\n      for (num = i = 0; i < (int)len && i < 65536; i++)\n        num += getreal(type);\n      if (len > 0)\n      {\n        black += num / len + 0.5;\n        tiff_ifd[ifd].dng_levels.dng_fblack += num / float(len);\n        tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n      }\n      break;\n    case 0xc61d: /* 50717, WhiteLevel */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_WHITE;\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] = maximum = getint(type);\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < 4 && i < (int)len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n      break;\n    case 0xc61e: /* DefaultScale */\n    {\n      float q1 = getreal(type);\n      float q2 = getreal(type);\n      if (q1 > 0.00001f && q2 > 0.00001f)\n      {\n        pixel_aspect = q1 / q2;\n        if (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n          pixel_aspect = 1.0;\n      }\n    }\n    break;\n    case 0xc61f: /* 50719, DefaultCropOrigin */\n      if (len == 2)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPORIGIN;\n        tiff_ifd[ifd].dng_levels.default_crop[0] = getreal(type);\n        tiff_ifd[ifd].dng_levels.default_crop[1] = getreal(type);\n        if (!strncasecmp(make, \"SONY\", 4))\n        {\n          imgdata.sizes.raw_inset_crops[0].cleft =\n              tiff_ifd[ifd].dng_levels.default_crop[0];\n          imgdata.sizes.raw_inset_crops[0].ctop =\n              tiff_ifd[ifd].dng_levels.default_crop[1];\n        }\n      }\n      break;\n\n    case 0xc620: /* 50720, DefaultCropSize */\n      if (len == 2)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPSIZE;\n        tiff_ifd[ifd].dng_levels.default_crop[2] = getreal(type);\n        tiff_ifd[ifd].dng_levels.default_crop[3] = getreal(type);\n        if (!strncasecmp(make, \"SONY\", 4))\n        {\n          imgdata.sizes.raw_inset_crops[0].cwidth =\n              tiff_ifd[ifd].dng_levels.default_crop[2];\n          imgdata.sizes.raw_inset_crops[0].cheight =\n              tiff_ifd[ifd].dng_levels.default_crop[3];\n        }\n      }\n      break;\n\n    case 0xc7b5: /* 51125 DefaultUserCrop */\n      if (len == 4)\n      {\n          int cnt = 0;\n          FORC4\n          {\n              float v = getreal(type);\n              if (v >= 0.f && v <= 1.f)\n              {\n                  tiff_ifd[ifd].dng_levels.user_crop[c] = v;\n                  cnt++;\n              }\n          }\n          if(cnt == 4 // valid values\n              && tiff_ifd[ifd].dng_levels.user_crop[0] < tiff_ifd[ifd].dng_levels.user_crop[2] // top < bottom\n              && tiff_ifd[ifd].dng_levels.user_crop[1] < tiff_ifd[ifd].dng_levels.user_crop[3] // left < right\n              )\n            tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_USERCROP;\n      }\n      break;\n    case 0x74c7:\n      if ((len == 2) && !strncasecmp(make, \"SONY\", 4))\n      {\n        imgdata.sizes.raw_inset_crops[0].cleft = get4();\n        imgdata.sizes.raw_inset_crops[0].ctop = get4();\n      }\n      break;\n\n    case 0x74c8:\n      if ((len == 2) && !strncasecmp(make, \"SONY\", 4))\n      {\n        imgdata.sizes.raw_inset_crops[0].cwidth = get4();\n        imgdata.sizes.raw_inset_crops[0].cheight = get4();\n      }\n      break;\n\n    case 0xc65a: // 50778\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      tiff_ifd[ifd].dng_color[0].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;\n      break;\n    case 0xc65b: // 50779\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      tiff_ifd[ifd].dng_color[1].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;\n      break;\n\n    case 0xc621: /* 50721, ColorMatrix1 */\n    case 0xc622: /* 50722, ColorMatrix2 */\n    {\n      int chan = (len == 9) ? 3 : (len == 12 ? 4 : 0);\n      i = tag == 0xc621 ? 0 : 1;\n      if (chan)\n      {\n        tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_COLORMATRIX;\n        imHassy.nIFD_CM[i] = ifd;\n      }\n      FORC(chan) for (j = 0; j < 3; j++)\n      {\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] = cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n    }\n    break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n    {\n      int chan = (len == 9) ? 3 : (len == 12 ? 4 : 0);\n      i = tag == 0xc714 ? 0 : 1;\n      if (chan)\n        tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_FORWARDMATRIX;\n      for (j = 0; j < 3; j++)\n        FORC(chan)\n        {\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] = fm[j][c] =\n              getreal(type);\n        }\n    }\n    break;\n\n    case 0xc623: /* 50723, CameraCalibration1 */\n    case 0xc624: /* 50724, CameraCalibration2 */\n    {\n      int chan = (len == 9) ? 3 : (len == 16 ? 4 : 0);\n      j = tag == 0xc623 ? 0 : 1;\n      if (chan)\n        tiff_ifd[ifd].dng_color[j].parsedfields |= LIBRAW_DNGFM_CALIBRATION;\n      for (i = 0; i < chan; i++)\n        FORC(chan)\n        {\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] = cc[i][c] =\n              getreal(type);\n        }\n    }\n    break;\n    case 0xc627: /* 50727, AnalogBalance */\n      if (len >= 3)\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_ANALOGBALANCE;\n      for (c = 0; c < (int)len && c < 4; c++)\n      {\n        tiff_ifd[ifd].dng_levels.analogbalance[c] = ab[c] = getreal(type);\n      }\n      break;\n    case 0xc628: /* 50728, AsShotNeutral */\n      if (len >= 3)\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_ASSHOTNEUTRAL;\n      for (c = 0; c < (int)len && c < 4; c++)\n        tiff_ifd[ifd].dng_levels.asshotneutral[c] = asn[c] = getreal(type);\n      break;\n    case 0xc629: /* 50729, AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= LibRaw_constants::d65_white[c];\n      break;\n    case 0xc62a: /* DNG: 50730 BaselineExposure */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BASELINEEXPOSURE;\n      tiff_ifd[ifd].dng_levels.baseline_exposure = getreal(type);\n      break;\n    case 0xc62e: /* DNG: 50734 LinearResponseLimit */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_LINEARRESPONSELIMIT;\n      tiff_ifd[ifd].dng_levels.LinearResponseLimit = getreal(type);\n      break;\n\n    case 0xc634: /* 50740 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n      {\n        char mbuf[64];\n        INT64 curr_pos, start_pos = ftell(ifp);\n        unsigned MakN_order, m_sorder = order;\n        unsigned MakN_length;\n        unsigned pos_in_original_raw;\n        fread(mbuf, 1, 6, ifp);\n\n        if (!strcmp(mbuf, \"Adobe\"))\n        {\n          order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n          curr_pos = start_pos + 6;\n          while (curr_pos + 8 - start_pos <= len)\n          {\n            fread(mbuf, 1, 4, ifp);\n            curr_pos += 8;\n\n            if (!strncmp(mbuf, \"Pano\", 4))\n            { // PanasonicRaw, yes, they use \"Pano\" as signature\n              parseAdobePanoMakernote();\n            }\n\n            if (!strncmp(mbuf, \"MakN\", 4))\n            {\n              MakN_length = get4();\n              MakN_order = get2();\n              pos_in_original_raw = get4();\n              order = MakN_order;\n\n              INT64 save_pos = ifp->tell();\n              parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0,\n                                     AdobeDNG);\n\n              curr_pos = save_pos + MakN_length - 6;\n              fseek(ifp, curr_pos, SEEK_SET);\n\n              fread(mbuf, 1, 4, ifp);\n              curr_pos += 8;\n\n              if (!strncmp(mbuf, \"Pano \", 4))\n              {\n                parseAdobePanoMakernote();\n              }\n\n              if (!strncmp(mbuf, \"RAF \", 4))\n              { // Fujifilm Raw, AdobeRAF\n                parseAdobeRAFMakernote();\n              }\n\n              if (!strncmp(mbuf, \"SR2 \", 4))\n              {\n                order = 0x4d4d;\n                MakN_length = get4();\n                MakN_order = get2();\n                pos_in_original_raw = get4();\n                order = MakN_order;\n\n                unsigned *buf_SR2;\n                unsigned SR2SubIFDOffset = 0;\n                unsigned SR2SubIFDLength = 0;\n                unsigned SR2SubIFDKey = 0;\n                {\n                  int _base = curr_pos + 6 - pos_in_original_raw;\n                  unsigned _entries, _tag, _type, _len, _save;\n                  _entries = get2();\n                  while (_entries--)\n                  {\n                    tiff_get(_base, &_tag, &_type, &_len, &_save);\n\n                    if (_tag == 0x7200)\n                    {\n                      SR2SubIFDOffset = get4();\n                    }\n                    else if (_tag == 0x7201)\n                    {\n                      SR2SubIFDLength = get4();\n                    }\n                    else if (_tag == 0x7221)\n                    {\n                      SR2SubIFDKey = get4();\n                    }\n                    fseek(ifp, _save, SEEK_SET);\n                  }\n                }\n\n                if (SR2SubIFDLength && (SR2SubIFDLength < 10240000) &&\n                    (buf_SR2 = (unsigned *)calloc(SR2SubIFDLength + 1024,1)))\n                { // 1024b for safety\n                  fseek(ifp, SR2SubIFDOffset + base, SEEK_SET);\n                  fread(buf_SR2, SR2SubIFDLength, 1, ifp);\n                  sony_decrypt(buf_SR2, SR2SubIFDLength / 4, 1, SR2SubIFDKey);\n                  parseSonySR2((uchar *)buf_SR2, SR2SubIFDOffset,\n                               SR2SubIFDLength, AdobeDNG);\n\n                  free(buf_SR2);\n                }\n\n              } /* SR2 processed */\n              break;\n            }\n          }\n        }\n        else\n        {\n          fread(mbuf + 6, 1, 2, ifp);\n          if (!strcmp(mbuf, \"RICOH\") && ((sget2((uchar *)mbuf + 6) == 0x4949) ||\n                                         (sget2((uchar *)mbuf + 6) == 0x4d4d)))\n          {\n            is_PentaxRicohMakernotes = 1;\n          }\n          if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\") ||\n              is_PentaxRicohMakernotes)\n          {\n            fseek(ifp, start_pos, SEEK_SET);\n            parse_makernote_0xc634(base, 0, CameraDNG);\n          }\n        }\n        fseek(ifp, start_pos, SEEK_SET);\n        order = m_sorder;\n      }\n      if (dng_version)\n      {\n        break;\n      }\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 0xc640: // 50752\n      read_shorts(cr2_slice, 3);\n      break;\n    case 0xc68b: /* 50827, OriginalRawFileName */\n      stmread(imgdata.color.OriginalRawFileName, len, ifp);\n      break;\n    case 0xc68d: /* 50829 ActiveArea */\n      tiff_ifd[ifd].t_tm = top_margin = getint(type);\n      tiff_ifd[ifd].t_lm = left_margin = getint(type);\n      tiff_ifd[ifd].t_vheight = height = getint(type) - top_margin;\n      tiff_ifd[ifd].t_vwidth = width = getint(type) - left_margin;\n      break;\n    case 0xc68e: /* 50830 MaskedAreas */\n      for (i = 0; i < (int)len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 0xc71a: /* 50970, PreviewColorSpace */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_PREVIEWCS;\n      tiff_ifd[ifd].dng_levels.preview_colorspace = getint(type);\n      break;\n    case 0xc740: /* 51008, OpcodeList1 */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE1;\n      break;\n    case 0xc741: /* 51009, OpcodeList2 */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE2;\n      tiff_ifd[ifd].opcode2_offset = meta_offset = ftell(ifp);\n      break;\n    case 0xc74e: /* 51022, OpcodeList3 */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE3;\n      break;\n    case 0xfd04: /* 64772, Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &LibRaw::packed_load_raw;\n      break;\n    case 0xfe02: // 65026\n      if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII))\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 &&\n      (buf = (unsigned *)calloc(sony_length, 1)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n    parseSonySR2((uchar *)buf, sony_offset, sony_length, nonDNG);\n    free(buf);\n  }\n  for (i = 0; i < colors && i < 4; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++)\n        cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC\n    if (fabs(asn[c]) > 0.0001)\n      cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC if (fabs(cc[c][c]) > 0.0001) pre_mul[c] /= cc[c][c];\n  return 0;\n}", "target": 1}
{"idx": 123, "func": "int LibRaw::parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save, utmp;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n\n  ushort *rafdata;\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n\n  if (libraw_internal_data.unpacker_data.ifd0_offset == -1LL)\n    libraw_internal_data.unpacker_data.ifd0_offset = base;\n\n  entries = get2();\n  if (entries > 512)\n    return 1;\n\n  INT64 fsize = ifp->size();\n\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && savepos + len > 2 * fsize)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data,\n                        tag | (is_pana_raw ? 0x30000 : ((ifd + 1) << 20)), type,\n                        len, order, ifp, base);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n\n    if (!is_pana_raw)\n    { /* processing of EXIF tags that collide w/ PanasonicRaw tags */\n      switch (tag)\n      {\n      case 0x0001:\n        if (len == 4)\n          is_pana_raw = get4();\n        break;\n      case 0x000b: /* 11, Std. EXIF Software tag */\n        fgets(software, 64, ifp);\n        if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) ||\n            !strncmp(software, \"UFRaw\", 5) || !strncmp(software, \"Bibble\", 6) ||\n            !strcmp(software, \"Digital Photo Professional\"))\n          is_raw = 0;\n        break;\n      case 0x001c: /*  28, safeguard, probably not needed */\n      case 0x001d: /*  29, safeguard, probably not needed */\n      case 0x001e: /*  30, safeguard, probably not needed */\n        cblack[tag - 0x001c] = get2();\n        cblack[3] = cblack[1];\n        break;\n\n      case 0x0111: /* 273, StripOffset */\n        if (len > 1 && len < 16384)\n        {\n          off_t sav = ftell(ifp);\n          tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n          tiff_ifd[ifd].strip_offsets_count = len;\n          for (int ii = 0; ii < (int)len; ii++)\n            tiff_ifd[ifd].strip_offsets[ii] = get4() + base;\n          fseek(ifp, sav, SEEK_SET); // restore position\n        }\n        /* fallback */\n      case 0x0201: /* 513, JpegIFOffset */\n      case 0xf007: // 61447\n        tiff_ifd[ifd].offset = get4() + base;\n        if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n        {\n          fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n          if (ljpeg_start(&jh, 1))\n          {\n            if (!dng_version && !strcasecmp(make, \"SONY\") && tiff_ifd[ifd].phint == 32803 &&\n                tiff_ifd[ifd].comp == 7) // Sony/lossless compressed IFD\n            {\n              tiff_ifd[ifd].comp = 6;\n              tiff_ifd[ifd].bps = jh.bits;\n              tiff_ifd[ifd].samples = 1;\n            }\n            else\n            {\n              tiff_ifd[ifd].comp = 6;\n              tiff_ifd[ifd].bps = jh.bits;\n              tiff_ifd[ifd].t_width = jh.wide;\n              tiff_ifd[ifd].t_height = jh.high;\n              tiff_ifd[ifd].samples = jh.clrs;\n              if (!(jh.sraw || (jh.clrs & 1)))\n                tiff_ifd[ifd].t_width *= jh.clrs;\n              if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n              {\n                tiff_ifd[ifd].t_width /= 2;\n                tiff_ifd[ifd].t_height *= 2;\n              }\n              i = order;\n              parse_tiff(tiff_ifd[ifd].offset + 12);\n              order = i;\n            }\n          }\n        }\n        break;\n      }\n    }\n    else\n    { /* processing Panasonic-specific \"PanasonicRaw\" tags */\n      switch (tag)\n      {\n      case 0x0004: /*   4, SensorTopBorder */\n        imgdata.sizes.raw_inset_crops[0].ctop = get2();\n        break;\n      case 0x000a: /*  10, BitsPerSample */\n        pana_bpp = get2();\n\t\tpana_bpp = LIM(pana_bpp, 8, 16);\n        break;\n      case 0x000b: /*  11, Compression */\n        imPana.Compression = get2();\n        break;\n      case 0x000e: /*  14, LinearityLimitRed */\n      case 0x000f: /*  15, LinearityLimitGreen */\n      case 0x0010: /*  16, LinearityLimitBlue */\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (imgdata.color.linear_max[tag - 14] == 16383)\n            imgdata.color.linear_max[tag - 14] -= 64;\n        if (imgdata.color.linear_max[tag - 14] == 4095)\n          imgdata.color.linear_max[tag - 14] -= 16;\n        if (tag == 0x000f) // 15, LinearityLimitGreen\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        break;\n      case 0x0013: /*  19, WBInfo */\n        if ((i = get2()) > 0x100)\n          break;\n        for (c = 0; c < i; c++)\n        {\n          if ((j = get2()) < 0x100)\n          {\n\t\t\t  if (j >= 0) {\n\t\t\t\t  icWBC[j][0] = get2();\n\t\t\t\t  icWBC[j][2] = get2();\n\t\t\t\t  icWBC[j][1] = icWBC[j][3] =\n\t\t\t\t\t  0x100;\n\t\t\t  }\n          }\n          else // light source out of EXIF numbers range\n            get4();\n        }\n        break;\n      case 0x0018: /* 24, HighISOMultiplierRed */\n      case 0x0019: /* 25, HighISOMultiplierGreen */\n      case 0x001a: /* 26, HighISOMultiplierBlue */\n        imPana.HighISOMultiplier[tag - 0x0018] = get2();\n        break;\n      case 0x001c: /*  28, BlackLevelRed */\n      case 0x001d: /*  29, BlackLevelGreen */\n      case 0x001e: /*  30, BlackLevelBlue */\n        pana_black[tag - 0x001c] = get2();\n        break;\n      case 0x002d: /*  45, RawFormat */\n                   /* pana_encoding: tag 0x002d (45dec)\n                        not used - DMC-LX1/FZ30/FZ50/L1/LX1/LX2\n                        2 - RAW DMC-FZ8/FZ18\n                        3 - RAW DMC-L10\n                        4 - RW2 for most other models, including G9 in \"pixel shift off\"\n                      mode and YUNEEC CGO4            (must add 15 to black levels for\n                      RawFormat == 4)            5 - RW2 DC-GH5s; G9 in \"pixel shift on\"\n                      mode            6 - RW2            DC-S1, DC-S1R in \"pixel shift off\"\n                      mode            7 -            RW2 DC-S1R (probably            DC-S1 too) in\n                      \"pixel shift on\" mode\n                   */\n        pana_encoding = get2();\n        break;\n      case 0x002f: /*  47, CropTop */\n        imgdata.sizes.raw_inset_crops[0].ctop = get2();\n        break;\n      case 0x0030: /*  48, CropLeft */\n        imgdata.sizes.raw_inset_crops[0].cleft = get2();\n        break;\n      case 0x0031: /*  49, CropBottom */\n        imgdata.sizes.raw_inset_crops[0].cheight =\n            get2() - imgdata.sizes.raw_inset_crops[0].ctop;\n        break;\n      case 0x0032: /*  50, CropRight */\n        imgdata.sizes.raw_inset_crops[0].cwidth =\n            get2() - imgdata.sizes.raw_inset_crops[0].cleft;\n        break;\n      case 0x0037: /*  55, ISO if  ISO in 0x8827 & ISO in 0x0017 == 65535 */\n        if (iso_speed == 65535)\n          iso_speed = get4();\n        break;\n      case 0x011c: /* 284, Gamma */\n      {\n        int n = get2();\n        if (n >= 1024)\n          imPana.gamma = (float)n / 1024.0f;\n        else if (n >= 256)\n          imPana.gamma = (float)n / 256.0f;\n        else\n          imPana.gamma = (float)n / 100.0f;\n      }\n      break;\n      case 0x0120: /* 288, CameraIFD, contains tags 0x1xxx, 0x2xxx, 0x3xxx */\n      {\n        unsigned sorder = order;\n        unsigned long sbase = base;\n        base = ftell(ifp);\n        order = get2();\n        fseek(ifp, 2, SEEK_CUR);\n        fseek(ifp, INT64(get4()) - 8LL, SEEK_CUR);\n        parse_tiff_ifd(base);\n        base = sbase;\n        order = sorder;\n      }\n      break;\n      case 0x0121: /* 289, Multishot, 0 is Off, 65536 is Pixel Shift */\n        imPana.Multishot = get4();\n        break;\n      case 0x1001:\n      \tif (imPana.Multishot == 0) {\n      \t  imPana.Multishot = get4();\n      \t  if (imPana.Multishot)\n      \t    imPana.Multishot += 65535;\n      \t}\n        break;\n      case 0x1100:\n        imPana.FocusStepNear = get2();\n        break;\n      case 0x1101:\n        imPana.FocusStepCount = get2();\n        break;\n      case 0x1105:\n        imPana.ZoomPosition = get4();\n        break;\n      case 0x1201:\n        if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT)) {\n          imPana.LensManufacturer = fgetc(ifp);\n        } else if (type == 258) {\n          imPana.LensManufacturer = get4();\n          if (imPana.LensManufacturer >= 257) {\n            ilm.LensMount = LIBRAW_MOUNT_LPS_L;\n            ilm.LensFormat = LIBRAW_FORMAT_FF;\n          }\n        }\n        break;\n      case 0x1202:\n        if (ilm.LensMount == LIBRAW_MOUNT_LPS_L) {\n          if ((utmp = get2())) ilm.LensID = utmp;\n        } else if ((imPana.LensManufacturer != 0xff) &&\n                   (imPana.LensManufacturer != 0xffffffff)) {\n          if ((utmp = (fgetc(ifp) << 8) | fgetc(ifp)))\n            ilm.LensID = (imPana.LensManufacturer << 16) + utmp;\n        }\n        break;\n      case 0x1203: /* 4611, FocalLengthIn35mmFormat, contained in 0x0120\n                      CameraIFD */\n        if (imgdata.lens.FocalLengthIn35mmFormat < 0.65f)\n          imgdata.lens.FocalLengthIn35mmFormat = get2();\n        break;\n      case 0x2009: /* 8201, contained in 0x0120 CameraIFD */\n        if ((pana_encoding == 4) || (pana_encoding == 5))\n        {\n          i = MIN(8, len);\n          int permut[8] = {3, 2, 1, 0, 3 + 4, 2 + 4, 1 + 4, 0 + 4};\n          imPana.BlackLevelDim = len;\n          for (j = 0; j < i; j++)\n          {\n            imPana.BlackLevel[permut[j]] =\n                (float)(get2()) / (float)(powf(2.f, 14.f - pana_bpp));\n          }\n        }\n        break;\n      case 0x3420: /* 13344, WB_RedLevelAuto, contained in 0x0120 CameraIFD */\n        icWBC[LIBRAW_WBI_Auto][0] = get2();\n        icWBC[LIBRAW_WBI_Auto][1] = icWBC[LIBRAW_WBI_Auto][3] = 1024.0f;\n        break;\n      case 0x3421: /* 13345, WB_BlueLevelAuto, contained in 0x0120 CameraIFD */\n        icWBC[LIBRAW_WBI_Auto][2] = get2();\n        break;\n      case 0x0002: /*   2, ImageWidth */\n        tiff_ifd[ifd].t_width = getint(type);\n        break;\n      case 0x0003: /*   3, ImageHeight */\n        tiff_ifd[ifd].t_height = getint(type);\n        break;\n      case 0x0005: /*   5, SensorLeftBorder */\n        width = get2();\n        imgdata.sizes.raw_inset_crops[0].cleft = width;\n        break;\n      case 0x0006: /*   6, SensorBottomBorder */\n        height = get2();\n        imgdata.sizes.raw_inset_crops[0].cheight =\n            height - imgdata.sizes.raw_inset_crops[0].ctop;\n        break;\n      case 0x0007: /*   7, SensorRightBorder */\n        i = get2();\n        width += i;\n        imgdata.sizes.raw_inset_crops[0].cwidth =\n            i - imgdata.sizes.raw_inset_crops[0].cleft;\n        break;\n      case 0x0009: /*   9, CFAPattern */\n        if ((i = get2()))\n          filters = i;\n        break;\n      case 0x0011: /*  17, RedBalance */\n      case 0x0012: /*  18, BlueBalance */\n        if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT) && len == 1)\n          cam_mul[(tag - 0x0011) * 2] = get2() / 256.0;\n        break;\n      case 0x0017: /*  23, ISO */\n        if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT))\n          iso_speed = get2();\n        break;\n      case 0x0024: /*  36, WBRedLevel */\n      case 0x0025: /*  37, WBGreenLevel */\n      case 0x0026: /*  38, WBBlueLevel */\n        cam_mul[tag - 0x0024] = get2();\n        break;\n      case 0x0027: /*  39, WBInfo2 */\n        if ((i = get2()) > 0x100)\n          break;\n        for (c = 0; c < i; c++)\n        {\n          if ((j = get2()) < 0x100)\n          {\n           if(j >= 0) {\n            icWBC[j][0] = get2();\n            icWBC[j][1] = icWBC[j][3] = get2();\n            icWBC[j][2] = get2();\n            if (c == 1 && i > 6 && cam_mul[0] <= 0.001f)\n                for (int q = 0; q < 4; q++)\n                    cam_mul[q] = icWBC[j][q];\n\t   }\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n        break;\n      case 0x002e: /*  46, JpgFromRaw */\n        if ((type != LIBRAW_EXIFTAG_TYPE_UNDEFINED) || (fgetc(ifp) != 0xff) || (fgetc(ifp) != 0xd8))\n          break;\n        thumb_offset = ftell(ifp) - 2;\n        thumb_length = len;\n        break;\n\n      case 0x0118: /* 280, Panasonic RW2 offset */\n        if (type != LIBRAW_EXIFTAG_TYPE_LONG)\n          break;\n        load_raw = &LibRaw::panasonic_load_raw;\n        load_flags = 0x2008;\n      case 0x0111: /* 273, StripOffset */\n        if (len > 1 && len < 16384)\n        {\n          off_t sav = ftell(ifp);\n          tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n          tiff_ifd[ifd].strip_offsets_count = len;\n          for (int ii = 0; ii < (int)len; ii++)\n            tiff_ifd[ifd].strip_offsets[ii] = get4() + base;\n          fseek(ifp, sav, SEEK_SET); // restore position\n        }\n        /* fallthrough */\n        tiff_ifd[ifd].offset = get4() + base;\n        if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n        {\n          fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n          if (ljpeg_start(&jh, 1))\n          {\n            tiff_ifd[ifd].comp = 6;\n            tiff_ifd[ifd].t_width = jh.wide;\n            tiff_ifd[ifd].t_height = jh.high;\n            tiff_ifd[ifd].bps = jh.bits;\n            tiff_ifd[ifd].samples = jh.clrs;\n            if (!(jh.sraw || (jh.clrs & 1)))\n              tiff_ifd[ifd].t_width *= jh.clrs;\n            if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n            {\n              tiff_ifd[ifd].t_width /= 2;\n              tiff_ifd[ifd].t_height *= 2;\n            }\n            i = order;\n            parse_tiff(tiff_ifd[ifd].offset + 12);\n            order = i;\n          }\n        }\n        break;\n      }\n\n    } /* processing of Panasonic-specific tags finished */\n\n    switch (tag)\n    {            /* processing of general EXIF tags */\n    case 0xf000: /* 61440, Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 0x00fe: /* NewSubfileType */\n      tiff_ifd[ifd].newsubfiletype = getreal(type);\n      break;\n    case 0x0100: /* 256, ImageWidth */\n    case 0xf001: /* 61441, Fuji RAF RawImageFullWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 0x0101: /* 257, ImageHeight */\n    case 0xf002: /* 61442, Fuji RAF RawImageFullHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 0x0102: /* 258, BitsPerSample */\n    case 0xf003: /* 61443, Fuji RAF 0xf003 */\n      if(!tiff_ifd[ifd].samples || tag != 0x0102) // ??? already set by tag 0x115\n        tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < (unsigned)tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 0xf006: /* 61446, Fuji RAF 0xf006 */\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &LibRaw::packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 0x0103: /* 259, Compression */\n                 /*\n                    262\t = Kodak 262\n                  32767  = Sony ARW Compressed\n                  32769  = Packed RAW\n                  32770  = Samsung SRW Compressed\n                  32772  = Samsung SRW Compressed 2\n                  32867  = Kodak KDC Compressed\n                  34713  = Nikon NEF Compressed\n                  65000  = Kodak DCR Compressed\n                  65535  = Pentax PEF Compressed\n                 */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 0x0106: /* 262, PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 0x010e: /* 270, ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 0x010f: /* 271, Make */\n      fgets(make, 64, ifp);\n      break;\n    case 0x0110: /* 272, Model */\n      if (!strncmp(make, \"Hasselblad\", 10) && model[0] &&\n          (imHassy.format != LIBRAW_HF_Imacon))\n        break;\n      fgets(model, 64, ifp);\n      break;\n    case 0x0116: // 278\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n    case 0x0112: /* 274, Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 0x0115: /* 277, SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 0x0152: /* Extrasamples */\n      tiff_ifd[ifd].extrasamples = (getint(type) & 0xff) + 1024;\n      break;\n    case 0x0117: /* 279, StripByteCounts */\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int ii = 0; ii < (int)len; ii++)\n          tiff_ifd[ifd].strip_byte_counts[ii] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n      /* fallback */\n    case 0x0202: // 514\n    case 0xf008: // 61448\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 0xf00e: // 61454, FujiFilm \"As Shot\"\n      FORC3 cam_mul[GRBG_2_RGBG(c)] = getint(type);\n      break;\n    case 0x0131: /* 305, Software */\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) ||\n          !strncmp(software, \"UFRaw\", 5) || !strncmp(software, \"Bibble\", 6) ||\n          !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 0x0132: /* 306, DateTime */\n      get_timestamp(0);\n      break;\n    case 0x013b: /* 315, Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 0x013d: // 317\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 0x0142: /* 322, TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 0x0143: /* 323, TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 0x0144: /* 324, TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &LibRaw::sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 0x0145: // 325\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 0x014a: /* 330, SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &LibRaw::sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n        if (ifd >= int(sizeof tiff_ifd / sizeof tiff_ifd[0]))\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        break;\n      }\n      if (!strncmp(make, \"Hasselblad\", 10) &&\n          libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 0x0153: // 339\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 0x0190: // 400\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n    case 0x02bc: // 700\n      if ((tagtypeIs(LIBRAW_EXIFTAG_TYPE_BYTE) ||\n          tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII) ||\n          tagtypeIs(LIBRAW_EXIFTAG_TYPE_SBYTE) ||\n          tagtypeIs(LIBRAW_EXIFTOOLTAGTYPE_binary)) &&\n          (len > 1) && (len < 5100000))\n      {\n        xmpdata = (char *)calloc(xmplen = len + 1,1);\n        unsigned br = fread(xmpdata,1, len, ifp);\n        xmpdata[br] = 0;\n      }\n      break;\n    case 0x7000:\n      imSony.SonyRawFileType = get2();\n      break;\n    case 0x7010: // 28688\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= (int)sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 0x7200: // 29184, Sony SR2Private\n      sony_offset = get4();\n      break;\n    case 0x7201: // 29185, Sony SR2Private\n      sony_length = get4();\n      break;\n    case 0x7221: // 29217, Sony SR2Private\n      sony_key = get4();\n      break;\n    case 0x7250: // 29264, Sony SR2Private\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 0x7303: // 29443, Sony SR2SubIFD\n      FORC4 cam_mul[GRBG_2_RGBG(c)] = get2();\n      break;\n    case 0x7313: // 29459, Sony SR2SubIFD\n      FORC4 cam_mul[RGGB_2_RGBG(c)] = get2();\n      break;\n    case 0x7310: // 29456, Sony SR2SubIFD\n      FORC4 cblack[RGGB_2_RGBG(c)] = get2();\n      i = cblack[3];\n      FORC3 if (i > (int)cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n      break;\n    case 0x827d: /* 33405, Model2 */\n                 /*\n                  for Kodak ProBack 645 PB645x-yyyy 'x' is:\n                  'M' for Mamiya 645\n                  'C' for Contax 645\n                  'H' for Hasselblad H-series\n                 */\n      fgets(model2, 64, ifp);\n      break;\n    case 0x828d: /* 33421, CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        tiff_ifd[ifd].t_filters = filters = 9;\n      break;\n    case 0x828e: /* 33422, CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 0xfd09: /* 64777, Kodak P-series */\n      if (len == 36)\n      {\n        tiff_ifd[ifd].t_filters = filters = 9;\n        colors = 3;\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < (int)plen && colors < 4; i++)\n        {\n          if (cfa_pat[i] > 31)\n            continue; // Skip wrong data\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 0x8290: // 33424\n    case 0xfe00: // 65024\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 0x829a: /* 33434, ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 0x829d: /* 33437, FNumber */\n      aperture = getreal(type);\n      break;\n    case 0x9400:\n      imCommon.exifAmbientTemperature = getreal(type);\n      if ((imCommon.CameraTemperature > -273.15f) &&\n          ((OlyID == OlyID_TG_5) || (OlyID == OlyID_TG_6)))\n        imCommon.CameraTemperature +=\n            imCommon.exifAmbientTemperature;\n      break;\n    case 0x9401:\n      imCommon.exifHumidity = getreal(type);\n      break;\n    case 0x9402:\n      imCommon.exifPressure = getreal(type);\n      break;\n    case 0x9403:\n      imCommon.exifWaterDepth = getreal(type);\n      break;\n    case 0x9404:\n      imCommon.exifAcceleration = getreal(type);\n      break;\n    case 0x9405:\n      imCommon.exifCameraElevationAngle = getreal(type);\n      break;\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa420: /* 42016, ImageUniqueID */\n      stmread(imgdata.color.ImageUniqueID, len, ifp);\n      break;\n    case 0xc65d: /* 50781, RawDataUniqueID */\n      imgdata.color.RawDataUniqueID[16] = 0;\n      fread(imgdata.color.RawDataUniqueID, 1, 16, ifp);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      break;\n    case 0x8602: /* 34306, Leaf white balance */\n      FORC4\n      {\n        int q = get2();\n        if (q)\n          cam_mul[GRGB_2_RGBG(c)] = 4096.0 / q;\n      }\n      break;\n    case 0x8603: /* 34307, Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][GRGB_2_RGBG(c)]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 0x8606: /* 34310, Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 0x85ff: // 34303\n      strcpy(make, \"Leaf\");\n      break;\n    case 0x8769: /* 34665, EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 0x8825: /* 34853, GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n    }\n    break;\n    case 0x8773: /* 34675, InterColorProfile */\n    case 0xc68f: /* 50831, AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 0x9102: /* 37122, CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 0x920a: /* 37386, FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 0x9211: /* 37393, ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 0x9215: /* 37397, ExposureIndex */\n      imCommon.exifExposureIndex = getreal(type);\n      break;\n    case 0x9218: /* 37400, old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 0xa010: // 40976\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 0x8002: // 32770\n        load_raw = &LibRaw::samsung_load_raw;\n        break;\n      case 0x8004: // 32772\n        load_raw = &LibRaw::samsung2_load_raw;\n        break;\n      case 0x8005: // 32773\n        load_raw = &LibRaw::samsung3_load_raw;\n        break;\n      }\n      break;\n    case 0xb4c3: /* 46275, Imacon tags */\n      imHassy.format = LIBRAW_HF_Imacon;\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 0xb4c7: // 46279\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 0xb4c2: // 46274\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * (height * 6l) == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      c = unsigned(height) * unsigned(width) / 1000000;\n      if (c == 32)\n        c--;\n      sprintf(model, \"Ixpress %d-Mp\", c);\n      load_raw = &LibRaw::imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &LibRaw::unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 0xc516: /* 50454, Sinar tag */\n    case 0xc517: // 50455\n      if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n      if (fread(cbuf, 1, len, ifp) != (int)len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 0xc51a: // 50458\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 0xc51b: /* 50459, Hasselblad tag */\n      if (!libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n        i = order;\n        j = ftell(ifp);\n        c = tiff_nifds;\n        order = get2();\n        fseek(ifp, j + (get2(), get4()), SEEK_SET);\n        parse_tiff_ifd(j);\n        maximum = 0xffff;\n        tiff_nifds = c;\n        order = i;\n        break;\n      }\n    case 0xc612: /* 50706, DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 0xc614: /* 50708, UniqueCameraModel */\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      if (model[0])\n        break;\n      strncpy(make, imgdata.color.UniqueCameraModel,\n              MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 0xc616: /* 50710, CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      tiff_ifd[ifd].t_filters = filters;\n      break;\n    case 0xc617: /* 50711, CFALayout */\n      if (get2() == 2)\n        tiff_ifd[ifd].t_fuji_width = fuji_width = 1;\n      break;\n    case 0x0123: // 291\n    case 0xc618: /* 50712, LinearizationTable */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_LINTABLE;\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n      linear_table(len);\n      break;\n    case 0xc619: /* 50713, BlackLevelRepeatDim */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n      tiff_ifd[ifd].dng_levels.dng_fcblack[4] =\n          tiff_ifd[ifd].dng_levels.dng_cblack[4] = cblack[4] = get2();\n      tiff_ifd[ifd].dng_levels.dng_fcblack[5] =\n          tiff_ifd[ifd].dng_levels.dng_cblack[5] = cblack[5] = get2();\n      if (cblack[4] * cblack[5] >\n          (LIBRAW_CBLACK_SIZE -\n           7)) // Use last cblack item as DNG black level count\n        tiff_ifd[ifd].dng_levels.dng_fcblack[4] =\n            tiff_ifd[ifd].dng_levels.dng_fcblack[5] =\n                tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n                    tiff_ifd[ifd].dng_levels.dng_cblack[5] = cblack[4] =\n                        cblack[5] = 1;\n      break;\n\n    case 0xf00c:\n      if (imFuji.RAFDataGeneration != 4096)\n      {\n        unsigned fwb[4];\n        FORC4 fwb[c] = get4();\n        if (fwb[3] < 0x100)\n        {\n          FORC3 icWBC[fwb[3]][GRBG_2_RGBG(c)] = fwb[c];\n          icWBC[fwb[3]][3] = icWBC[fwb[3]][1];\n          if ((fwb[3] == 17) &&                                      // Tungsten WB\n              (libraw_internal_data.unpacker_data.lenRAFData > 3) &&\n              (libraw_internal_data.unpacker_data.lenRAFData < 10240000))\n          {\n            INT64 f_save = ftell(ifp);\n            rafdata = (ushort *)calloc(\n                sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData,1);\n            fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n            fread(rafdata, sizeof(ushort),\n                  libraw_internal_data.unpacker_data.lenRAFData, ifp);\n            fseek(ifp, f_save, SEEK_SET);\n\n            uchar *PrivateMknBuf = (uchar *)rafdata;\n            int PrivateMknLength = libraw_internal_data.unpacker_data.lenRAFData\n                                   << 1;\n            for (int pos = 0; pos < PrivateMknLength - 16; pos++)\n            {\n              if (!memcmp(PrivateMknBuf + pos, \"TSNERDTS\", 8)) // STDRENST\n              {\n                imFuji.isTSNERDTS = 1;\n                break;\n              }\n            }\n            int fj; // 31? (fj<<1)-0x3c : 34? (fj<<1)-0x4e : undef\n            int is34 = 0;\n            if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3, GFX 100S\n                (imFuji.RAFDataVersion == 0x0261) || // X100V, GFX 50S II\n                (imFuji.RAFDataVersion == 0x0262) || // X-T4\n                (imFuji.RAFDataVersion == 0x0263) || // X-H2S\n                (imFuji.RAFDataVersion == 0x0264) || // X-S10\n                (imFuji.RAFDataVersion == 0x0265) || // X-E4\n                (imFuji.RAFDataVersion == 0x0266) || // X-T30 II\n                !strcmp(model, \"X-Pro3\")     ||\n                !strcmp(model, \"GFX 100S\")   ||\n                !strcmp(model, \"GFX100S\")    ||\n                !strcmp(model, \"GFX 50S II\") ||\n                !strcmp(model, \"GFX50S II\")  ||\n                !strcmp(model, \"X100V\")      ||\n                !strcmp(model, \"X-T4\")       ||\n                !strcmp(model, \"X-H2S\")      ||\n                !strcmp(model, \"X-E4\")       ||\n                !strcmp(model, \"X-T30 II\")   ||\n                !strcmp(model, \"X-S10\"))\n// is34 cameras have 34 CCT values instead of 31, manual still claims 2500 to 10000 K\n// aligned 3000 K to Incandescent, as it is usual w/ other Fujifilm cameras\n              is34 = 1;\n\n            for (int fi = 0;\n                 fi < int(libraw_internal_data.unpacker_data.lenRAFData - 3); fi++) // looking for Tungsten WB\n            {\n              if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) &&\n                  (fwb[2] == rafdata[fi + 2])) // found Tungsten WB\n              {\n                if (fi > 14 && rafdata[fi - 15] !=\n                    fwb[0]) // 15 is offset of Tungsten WB from the first\n                            // preset, Fine Weather WB\n                  continue;\n\t\t\t\tif (fi >= 15)\n\t\t\t\t{\n\t\t\t\t\tfor (int wb_ind = 0, ofst = fi - 15; wb_ind < (int)Fuji_wb_list1.size();\n\t\t\t\t\t\twb_ind++, ofst += 3)\n\t\t\t\t\t{\n\t\t\t\t\t\ticWBC[Fuji_wb_list1[wb_ind]][1] =\n\t\t\t\t\t\t\ticWBC[Fuji_wb_list1[wb_ind]][3] = rafdata[ofst];\n\t\t\t\t\t\ticWBC[Fuji_wb_list1[wb_ind]][0] = rafdata[ofst + 1];\n\t\t\t\t\t\ticWBC[Fuji_wb_list1[wb_ind]][2] = rafdata[ofst + 2];\n\t\t\t\t\t}\n\t\t\t\t}\n\n                if (is34)\n                  fi += 24;\n                fi += 96;\n                for (fj = fi; fj < (fi + 15); fj += 3) // looking for the end of the WB table\n                {\n\t\t\t\t\tif (fj > libraw_internal_data.unpacker_data.lenRAFData - 3)\n\t\t\t\t\t\tbreak;\n                  if (rafdata[fj] != rafdata[fi])\n                  {\n                    fj -= 93;\n                    if (is34)\n                      fj -= 9;\n//printf (\"wb start in DNG: 0x%04x\\n\", fj*2-0x4e);\n                    for (int iCCT = 0, ofst = fj; iCCT < 31 \n\t\t\t\t\t\t&& ofst < libraw_internal_data.unpacker_data.lenRAFData - 3;\n                         iCCT++, ofst += 3)\n                    {\n                      icWBCCTC[iCCT][0] = FujiCCT_K[iCCT];\n                      icWBCCTC[iCCT][1] = rafdata[ofst + 1];\n                      icWBCCTC[iCCT][2] = icWBCCTC[iCCT][4] = rafdata[ofst];\n                      icWBCCTC[iCCT][3] = rafdata[ofst + 2];\n                    }\n                    break;\n                  }\n                }\n                free(rafdata);\n                break;\n              }\n            }\n          }\n        }\n        FORC4 fwb[c] = get4();\n        if (fwb[3] < 0x100) {\n          FORC3 icWBC[fwb[3]][GRBG_2_RGBG(c)] = fwb[c];\n          icWBC[fwb[3]][3] = icWBC[fwb[3]][1];\n        }\n      }\n      break;\n    case 0xf00d:\n      if (imFuji.RAFDataGeneration != 4096)\n      {\n        FORC3 icWBC[LIBRAW_WBI_Auto][GRBG_2_RGBG(c)] = getint(type);\n        icWBC[LIBRAW_WBI_Auto][3] = icWBC[LIBRAW_WBI_Auto][1];\n      }\n      break;\n    case 0xc615: /* 50709, LocalizedCameraModel */\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n    case 0xf00a: // 61450\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 0xc61a: /* 50714, BlackLevel */\n      if (tiff_ifd[ifd].samples > 1 &&\n          tiff_ifd[ifd].samples == (int)len) // LinearDNG, per-channel black\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        for (i = 0; i < 4 && i < (int)len; i++)\n        {\n          tiff_ifd[ifd].dng_levels.dng_fcblack[i] = getreal(type);\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] =\n              tiff_ifd[ifd].dng_levels.dng_fcblack[i] + 0.5;\n        }\n        // Record len in last cblack field\n        tiff_ifd[ifd].dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1] = len;\n\n        tiff_ifd[ifd].dng_levels.dng_fblack =\n            tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else if (tiff_ifd[ifd].samples > 1 // Linear DNG w repeat dim\n               && (tiff_ifd[ifd].samples * cblack[4] * cblack[5] == len))\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        tiff_ifd[ifd].dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1] =\n            cblack[LIBRAW_CBLACK_SIZE - 1] = len;\n        for (i = 0; i < (int)len && i < LIBRAW_CBLACK_SIZE - 7; i++)\n        {\n          tiff_ifd[ifd].dng_levels.dng_fcblack[i + 6] = getreal(type);\n          tiff_ifd[ifd].dng_levels.dng_cblack[i + 6] = cblack[i + 6] =\n              tiff_ifd[ifd].dng_levels.dng_fcblack[i + 6] + 0.5;\n        }\n      }\n      else if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        tiff_ifd[ifd].dng_levels.dng_fblack = getreal(type);\n        black = tiff_ifd[ifd].dng_levels.dng_black =\n            tiff_ifd[ifd].dng_levels.dng_fblack;\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(int(cblack[4] * cblack[5]))\n        {\n          tiff_ifd[ifd].dng_levels.dng_fcblack[6 + c] = getreal(type);\n          cblack[6 + c] = tiff_ifd[ifd].dng_levels.dng_fcblack[6 + c];\n        }\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n        if (tag == 0xc61a)\n        {\n          tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n          FORC(int(cblack[4] * cblack[5]))\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_fblack = 0;\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_fcblack[c] =\n              tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n      }\n      break;\n    case 0xc61b: /* 50715, BlackLevelDeltaH */\n    case 0xc61c: /* 50716, BlackLevelDeltaV */\n      for (num = i = 0; i < (int)len && i < 65536; i++)\n        num += getreal(type);\n      if (len > 0)\n      {\n        black += num / len + 0.5;\n        tiff_ifd[ifd].dng_levels.dng_fblack += num / float(len);\n        tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n      }\n      break;\n    case 0xc61d: /* 50717, WhiteLevel */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_WHITE;\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] = maximum = getint(type);\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < 4 && i < (int)len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n      break;\n    case 0xc61e: /* DefaultScale */\n    {\n      float q1 = getreal(type);\n      float q2 = getreal(type);\n      if (q1 > 0.00001f && q2 > 0.00001f)\n      {\n        pixel_aspect = q1 / q2;\n        if (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n          pixel_aspect = 1.0;\n      }\n    }\n    break;\n    case 0xc61f: /* 50719, DefaultCropOrigin */\n      if (len == 2)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPORIGIN;\n        tiff_ifd[ifd].dng_levels.default_crop[0] = getreal(type);\n        tiff_ifd[ifd].dng_levels.default_crop[1] = getreal(type);\n        if (!strncasecmp(make, \"SONY\", 4))\n        {\n          imgdata.sizes.raw_inset_crops[0].cleft =\n              tiff_ifd[ifd].dng_levels.default_crop[0];\n          imgdata.sizes.raw_inset_crops[0].ctop =\n              tiff_ifd[ifd].dng_levels.default_crop[1];\n        }\n      }\n      break;\n\n    case 0xc620: /* 50720, DefaultCropSize */\n      if (len == 2)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPSIZE;\n        tiff_ifd[ifd].dng_levels.default_crop[2] = getreal(type);\n        tiff_ifd[ifd].dng_levels.default_crop[3] = getreal(type);\n        if (!strncasecmp(make, \"SONY\", 4))\n        {\n          imgdata.sizes.raw_inset_crops[0].cwidth =\n              tiff_ifd[ifd].dng_levels.default_crop[2];\n          imgdata.sizes.raw_inset_crops[0].cheight =\n              tiff_ifd[ifd].dng_levels.default_crop[3];\n        }\n      }\n      break;\n\n    case 0xc7b5: /* 51125 DefaultUserCrop */\n      if (len == 4)\n      {\n          int cnt = 0;\n          FORC4\n          {\n              float v = getreal(type);\n              if (v >= 0.f && v <= 1.f)\n              {\n                  tiff_ifd[ifd].dng_levels.user_crop[c] = v;\n                  cnt++;\n              }\n          }\n          if(cnt == 4 // valid values\n              && tiff_ifd[ifd].dng_levels.user_crop[0] < tiff_ifd[ifd].dng_levels.user_crop[2] // top < bottom\n              && tiff_ifd[ifd].dng_levels.user_crop[1] < tiff_ifd[ifd].dng_levels.user_crop[3] // left < right\n              )\n            tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_USERCROP;\n      }\n      break;\n    case 0x74c7:\n      if ((len == 2) && !strncasecmp(make, \"SONY\", 4))\n      {\n        imgdata.sizes.raw_inset_crops[0].cleft = get4();\n        imgdata.sizes.raw_inset_crops[0].ctop = get4();\n      }\n      break;\n\n    case 0x74c8:\n      if ((len == 2) && !strncasecmp(make, \"SONY\", 4))\n      {\n        imgdata.sizes.raw_inset_crops[0].cwidth = get4();\n        imgdata.sizes.raw_inset_crops[0].cheight = get4();\n      }\n      break;\n\n    case 0xc65a: // 50778\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      tiff_ifd[ifd].dng_color[0].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;\n      break;\n    case 0xc65b: // 50779\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      tiff_ifd[ifd].dng_color[1].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;\n      break;\n\n    case 0xc621: /* 50721, ColorMatrix1 */\n    case 0xc622: /* 50722, ColorMatrix2 */\n    {\n      int chan = (len == 9) ? 3 : (len == 12 ? 4 : 0);\n      i = tag == 0xc621 ? 0 : 1;\n      if (chan)\n      {\n        tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_COLORMATRIX;\n        imHassy.nIFD_CM[i] = ifd;\n      }\n      FORC(chan) for (j = 0; j < 3; j++)\n      {\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] = cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n    }\n    break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n    {\n      int chan = (len == 9) ? 3 : (len == 12 ? 4 : 0);\n      i = tag == 0xc714 ? 0 : 1;\n      if (chan)\n        tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_FORWARDMATRIX;\n      for (j = 0; j < 3; j++)\n        FORC(chan)\n        {\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] = fm[j][c] =\n              getreal(type);\n        }\n    }\n    break;\n\n    case 0xc623: /* 50723, CameraCalibration1 */\n    case 0xc624: /* 50724, CameraCalibration2 */\n    {\n      int chan = (len == 9) ? 3 : (len == 16 ? 4 : 0);\n      j = tag == 0xc623 ? 0 : 1;\n      if (chan)\n        tiff_ifd[ifd].dng_color[j].parsedfields |= LIBRAW_DNGFM_CALIBRATION;\n      for (i = 0; i < chan; i++)\n        FORC(chan)\n        {\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] = cc[i][c] =\n              getreal(type);\n        }\n    }\n    break;\n    case 0xc627: /* 50727, AnalogBalance */\n      if (len >= 3)\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_ANALOGBALANCE;\n      for (c = 0; c < (int)len && c < 4; c++)\n      {\n        tiff_ifd[ifd].dng_levels.analogbalance[c] = ab[c] = getreal(type);\n      }\n      break;\n    case 0xc628: /* 50728, AsShotNeutral */\n      if (len >= 3)\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_ASSHOTNEUTRAL;\n      for (c = 0; c < (int)len && c < 4; c++)\n        tiff_ifd[ifd].dng_levels.asshotneutral[c] = asn[c] = getreal(type);\n      break;\n    case 0xc629: /* 50729, AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= LibRaw_constants::d65_white[c];\n      break;\n    case 0xc62a: /* DNG: 50730 BaselineExposure */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BASELINEEXPOSURE;\n      tiff_ifd[ifd].dng_levels.baseline_exposure = getreal(type);\n      break;\n    case 0xc62e: /* DNG: 50734 LinearResponseLimit */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_LINEARRESPONSELIMIT;\n      tiff_ifd[ifd].dng_levels.LinearResponseLimit = getreal(type);\n      break;\n\n    case 0xc634: /* 50740 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n      {\n        char mbuf[64];\n        INT64 curr_pos, start_pos = ftell(ifp);\n        unsigned MakN_order, m_sorder = order;\n        unsigned MakN_length;\n        unsigned pos_in_original_raw;\n        fread(mbuf, 1, 6, ifp);\n\n        if (!strcmp(mbuf, \"Adobe\"))\n        {\n          order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n          curr_pos = start_pos + 6;\n          while (curr_pos + 8 - start_pos <= len)\n          {\n            fread(mbuf, 1, 4, ifp);\n            curr_pos += 8;\n\n            if (!strncmp(mbuf, \"Pano\", 4))\n            { // PanasonicRaw, yes, they use \"Pano\" as signature\n              parseAdobePanoMakernote();\n            }\n\n            if (!strncmp(mbuf, \"MakN\", 4))\n            {\n              MakN_length = get4();\n              MakN_order = get2();\n              pos_in_original_raw = get4();\n              order = MakN_order;\n\n              INT64 save_pos = ifp->tell();\n              parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0,\n                                     AdobeDNG);\n\n              curr_pos = save_pos + MakN_length - 6;\n              fseek(ifp, curr_pos, SEEK_SET);\n\n              fread(mbuf, 1, 4, ifp);\n              curr_pos += 8;\n\n              if (!strncmp(mbuf, \"Pano \", 4))\n              {\n                parseAdobePanoMakernote();\n              }\n\n              if (!strncmp(mbuf, \"RAF \", 4))\n              { // Fujifilm Raw, AdobeRAF\n                parseAdobeRAFMakernote();\n              }\n\n              if (!strncmp(mbuf, \"SR2 \", 4))\n              {\n                order = 0x4d4d;\n                MakN_length = get4();\n                MakN_order = get2();\n                pos_in_original_raw = get4();\n                order = MakN_order;\n\n                unsigned *buf_SR2;\n                unsigned SR2SubIFDOffset = 0;\n                unsigned SR2SubIFDLength = 0;\n                unsigned SR2SubIFDKey = 0;\n                {\n                  int _base = curr_pos + 6 - pos_in_original_raw;\n                  unsigned _entries, _tag, _type, _len, _save;\n                  _entries = get2();\n                  while (_entries--)\n                  {\n                    tiff_get(_base, &_tag, &_type, &_len, &_save);\n\n                    if (_tag == 0x7200)\n                    {\n                      SR2SubIFDOffset = get4();\n                    }\n                    else if (_tag == 0x7201)\n                    {\n                      SR2SubIFDLength = get4();\n                    }\n                    else if (_tag == 0x7221)\n                    {\n                      SR2SubIFDKey = get4();\n                    }\n                    fseek(ifp, _save, SEEK_SET);\n                  }\n                }\n\n                if (SR2SubIFDLength && (SR2SubIFDLength < 10240000) &&\n                    (buf_SR2 = (unsigned *)calloc(SR2SubIFDLength + 1024,1)))\n                { // 1024b for safety\n                  fseek(ifp, SR2SubIFDOffset + base, SEEK_SET);\n                  fread(buf_SR2, SR2SubIFDLength, 1, ifp);\n                  sony_decrypt(buf_SR2, SR2SubIFDLength / 4, 1, SR2SubIFDKey);\n                  parseSonySR2((uchar *)buf_SR2, SR2SubIFDOffset,\n                               SR2SubIFDLength, AdobeDNG);\n\n                  free(buf_SR2);\n                }\n\n              } /* SR2 processed */\n              break;\n            }\n          }\n        }\n        else\n        {\n          fread(mbuf + 6, 1, 2, ifp);\n          if (!strcmp(mbuf, \"RICOH\") && ((sget2((uchar *)mbuf + 6) == 0x4949) ||\n                                         (sget2((uchar *)mbuf + 6) == 0x4d4d)))\n          {\n            is_PentaxRicohMakernotes = 1;\n          }\n          if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\") ||\n              is_PentaxRicohMakernotes)\n          {\n            fseek(ifp, start_pos, SEEK_SET);\n            parse_makernote_0xc634(base, 0, CameraDNG);\n          }\n        }\n        fseek(ifp, start_pos, SEEK_SET);\n        order = m_sorder;\n      }\n      if (dng_version)\n      {\n        break;\n      }\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 0xc640: // 50752\n      read_shorts(cr2_slice, 3);\n      break;\n    case 0xc68b: /* 50827, OriginalRawFileName */\n      stmread(imgdata.color.OriginalRawFileName, len, ifp);\n      break;\n    case 0xc68d: /* 50829 ActiveArea */\n      tiff_ifd[ifd].t_tm = top_margin = getint(type);\n      tiff_ifd[ifd].t_lm = left_margin = getint(type);\n      tiff_ifd[ifd].t_vheight = height = getint(type) - top_margin;\n      tiff_ifd[ifd].t_vwidth = width = getint(type) - left_margin;\n      break;\n    case 0xc68e: /* 50830 MaskedAreas */\n      for (i = 0; i < (int)len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 0xc71a: /* 50970, PreviewColorSpace */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_PREVIEWCS;\n      tiff_ifd[ifd].dng_levels.preview_colorspace = getint(type);\n      break;\n    case 0xc740: /* 51008, OpcodeList1 */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE1;\n      break;\n    case 0xc741: /* 51009, OpcodeList2 */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE2;\n      tiff_ifd[ifd].opcode2_offset = meta_offset = ftell(ifp);\n      break;\n    case 0xc74e: /* 51022, OpcodeList3 */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE3;\n      break;\n    case 0xfd04: /* 64772, Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &LibRaw::packed_load_raw;\n      break;\n    case 0xfe02: // 65026\n      if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII))\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 &&\n      (buf = (unsigned *)calloc(sony_length, 1)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n    parseSonySR2((uchar *)buf, sony_offset, sony_length, nonDNG);\n    free(buf);\n  }\n  for (i = 0; i < colors && i < 4; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++)\n        cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC\n    if (fabs(asn[c]) > 0.0001)\n      cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC if (fabs(cc[c][c]) > 0.0001) pre_mul[c] /= cc[c][c];\n  return 0;\n}", "target": 0}
{"idx": 124, "func": "static void SetBpfStringFromFile(char *filename)\n{\n    char *bpf_filter = NULL;\n    char *bpf_comment_tmp = NULL;\n    char *bpf_comment_start =  NULL;\n    uint32_t bpf_len = 0;\n    SCStat st;\n    FILE *fp = NULL;\n    size_t nm = 0;\n\n    fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        SCLogError(\"Failed to open file %s\", filename);\n        exit(EXIT_FAILURE);\n    }\n\n    if (SCFstatFn(fileno(fp), &st) != 0) {\n        SCLogError(\"Failed to stat file %s\", filename);\n        exit(EXIT_FAILURE);\n    }\n    bpf_len = st.st_size + 1;\n\n    bpf_filter = SCCalloc(1, bpf_len);\n    if (unlikely(bpf_filter == NULL)) {\n        SCLogError(\"Failed to allocate buffer for bpf filter in file %s\", filename);\n        exit(EXIT_FAILURE);\n    }\n\n    nm = fread(bpf_filter, 1, bpf_len - 1, fp);\n    if ((ferror(fp) != 0) || (nm != (bpf_len - 1))) {\n        SCLogError(\"Failed to read complete BPF file %s\", filename);\n        SCFree(bpf_filter);\n        fclose(fp);\n        exit(EXIT_FAILURE);\n    }\n    fclose(fp);\n    bpf_filter[nm] = '\\0';\n\n    if(strlen(bpf_filter) > 0) {\n        /*replace comments with space*/\n        bpf_comment_start = bpf_filter;\n        while((bpf_comment_tmp = strchr(bpf_comment_start, '#')) != NULL) {\n            while((*bpf_comment_tmp !='\\0') &&\n                (*bpf_comment_tmp != '\\r') && (*bpf_comment_tmp != '\\n'))\n            {\n                *bpf_comment_tmp++ = ' ';\n            }\n            bpf_comment_start = bpf_comment_tmp;\n        }\n        /*remove remaining '\\r' and '\\n' */\n        while((bpf_comment_tmp = strchr(bpf_filter, '\\r')) != NULL) {\n            *bpf_comment_tmp = ' ';\n        }\n        while((bpf_comment_tmp = strchr(bpf_filter, '\\n')) != NULL) {\n            *bpf_comment_tmp = ' ';\n        }\n        /* cut trailing spaces */\n        while (strlen(bpf_filter) > 0 &&\n                bpf_filter[strlen(bpf_filter)-1] == ' ')\n        {\n            bpf_filter[strlen(bpf_filter)-1] = '\\0';\n        }\n        if (strlen(bpf_filter) > 0) {\n            if (ConfSetFinal(\"bpf-filter\", bpf_filter) != 1) {\n                SCFree(bpf_filter);\n                FatalError(\"failed to set bpf filter\");\n            }\n        }\n    }\n    SCFree(bpf_filter);\n}", "target": 1}
{"idx": 125, "func": "static void SetBpfStringFromFile(char *filename)\n{\n    char *bpf_filter = NULL;\n    char *bpf_comment_tmp = NULL;\n    char *bpf_comment_start =  NULL;\n    size_t bpf_len = 0;\n    SCStat st;\n    FILE *fp = NULL;\n    size_t nm = 0;\n\n    fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        SCLogError(\"Failed to open file %s\", filename);\n        exit(EXIT_FAILURE);\n    }\n\n    if (SCFstatFn(fileno(fp), &st) != 0) {\n        SCLogError(\"Failed to stat file %s\", filename);\n        exit(EXIT_FAILURE);\n    }\n    // st.st_size is signed on Windows\n    bpf_len = ((size_t)(st.st_size)) + 1;\n\n    bpf_filter = SCCalloc(1, bpf_len);\n    if (unlikely(bpf_filter == NULL)) {\n        SCLogError(\"Failed to allocate buffer for bpf filter in file %s\", filename);\n        exit(EXIT_FAILURE);\n    }\n\n    nm = fread(bpf_filter, 1, bpf_len - 1, fp);\n    if ((ferror(fp) != 0) || (nm != (bpf_len - 1))) {\n        SCLogError(\"Failed to read complete BPF file %s\", filename);\n        SCFree(bpf_filter);\n        fclose(fp);\n        exit(EXIT_FAILURE);\n    }\n    fclose(fp);\n    bpf_filter[nm] = '\\0';\n\n    if(strlen(bpf_filter) > 0) {\n        /*replace comments with space*/\n        bpf_comment_start = bpf_filter;\n        while((bpf_comment_tmp = strchr(bpf_comment_start, '#')) != NULL) {\n            while((*bpf_comment_tmp !='\\0') &&\n                (*bpf_comment_tmp != '\\r') && (*bpf_comment_tmp != '\\n'))\n            {\n                *bpf_comment_tmp++ = ' ';\n            }\n            bpf_comment_start = bpf_comment_tmp;\n        }\n        /*remove remaining '\\r' and '\\n' */\n        while((bpf_comment_tmp = strchr(bpf_filter, '\\r')) != NULL) {\n            *bpf_comment_tmp = ' ';\n        }\n        while((bpf_comment_tmp = strchr(bpf_filter, '\\n')) != NULL) {\n            *bpf_comment_tmp = ' ';\n        }\n        /* cut trailing spaces */\n        while (strlen(bpf_filter) > 0 &&\n                bpf_filter[strlen(bpf_filter)-1] == ' ')\n        {\n            bpf_filter[strlen(bpf_filter)-1] = '\\0';\n        }\n        if (strlen(bpf_filter) > 0) {\n            if (ConfSetFinal(\"bpf-filter\", bpf_filter) != 1) {\n                SCFree(bpf_filter);\n                FatalError(\"failed to set bpf filter\");\n            }\n        }\n    }\n    SCFree(bpf_filter);\n}", "target": 0}
{"idx": 126, "func": "string readResponseHeader() {\n\t\t\tstring result;\n\t\t\tstring line;\n\t\t\tdo {\n\t\t\t\tline = io.readLine();\n\t\t\t\tif (line.empty()) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tresult.append(line);\n\t\t\t\t\tif (line == \"\\r\\n\") {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (true);\n\t\t\treturn result;\n\t\t}\n\t};\n\n\tDEFINE_TEST_GROUP_WITH_LIMIT(ServerKit_HttpServerTest, 120);\n\n\n\t/***** Valid HTTP header parsing *****/\n\n\tTEST_METHOD(1) {\n\t\tset_test_name(\"A complete header in one part\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024 * 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hello /\");\n\t}\n\n\tTEST_METHOD(2) {\n\t\tset_test_name(\"A complete header in multiple random-sized parts\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connect\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequestAndWait(\n\t\t\t\"ion: close\\r\\n\"\n\t\t\t\"Host: fo\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequest(\n\t\t\t\"o\\r\\n\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hello /\");\n\t}\n\n\tTEST_METHOD(3) {\n\t\tset_test_name(\"A complete header in multiple complete lines\");\n\n\t\tconnectToServer();\n\n\t\tsendRequestAndWait(\"GET / HTTP/1.1\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequestAndWait(\"Connection: close\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequestAndWait(\"Host: foo\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequest(\"\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hello /\");\n\t}\n\n\tTEST_METHOD(4) {\n\t\tset_test_name(\"The request path is stored in req->path, \"\n\t\t\t\"and headers are stored in req->headers\");\n\n\t\tconnectToServer();\n\n\t\tsendRequestAndWait(\"GET /\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"jo\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"o HTTP/1.1\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequestAndWait(\"Connection: close\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequestAndWait(\"Host: foo\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequestAndWait(\"F\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"oo: \");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"b\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"ar\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequest(\"\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 19\\r\\n\\r\\n\"\n\t\t\t\"hello /joo\\n\"\n\t\t\t\"Foo: bar\");\n\t}\n\n\tTEST_METHOD(5) {\n\t\tset_test_name(\"It ensures that req->path is contiguous\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\"GET /p\");\n\t\tsendRequestAndWait(\n\t\t\t\"ath_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(containsSubstring(response, \"Contiguous: 1\"));\n\t}\n\n\n\t/***** Invalid HTTP header parsing *****/\n\n\tTEST_METHOD(7) {\n\t\tset_test_name(\"Incomplete header, without closing connection\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\"GET / HTT\");\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\t}\n\n\tTEST_METHOD(8) {\n\t\tset_test_name(\"Incomplete header, half-closing connection\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\"GET / HTT\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response, \"\");\n\t}\n\n\tTEST_METHOD(9) {\n\t\tset_test_name(\"Invalid header data\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\"whatever\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(containsSubstring(response,\n\t\t\t\"HTTP/1.0 400 Bad Request\\r\\n\"\n\t\t\t\"Status: 400 Bad Request\\r\\n\"\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\"));\n\t\tensure(containsSubstring(response,\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 19\\r\\n\"\n\t\t\t\"cache-control: no-cache, no-store, must-revalidate\\r\\n\\r\\n\"\n\t\t\t\"invalid HTTP method\"));\n\t}\n\n\n\t/***** Invalid request *****/\n\n\tTEST_METHOD(14) {\n\t\tset_test_name(\"HTTP > 1.1\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.2\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(containsSubstring(response,\n\t\t\t\"HTTP/1.0 505 HTTP Version Not Supported\\r\\n\"\n\t\t\t\"Status: 505 HTTP Version Not Supported\\r\\n\"\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\"));\n\t\tensure(containsSubstring(response,\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 27\\r\\n\"\n\t\t\t\"cache-control: no-cache, no-store, must-revalidate\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"HTTP version not supported\"));\n\t}\n\n\tTEST_METHOD(15) {\n\t\tset_test_name(\"Transfer-Encoding and Content-Length given simultaneously\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 3\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(containsSubstring(response,\n\t\t\t\"HTTP/1.0 400 Bad Request\\r\\n\"\n\t\t\t\"Status: 400 Bad Request\\r\\n\"\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\"));\n\t\tensure(containsSubstring(response,\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 79\\r\\n\"\n\t\t\t\"cache-control: no-cache, no-store, must-revalidate\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"Bad request (request may not contain both Content-Length and Transfer-Encoding)\"));\n\t}\n\n\tTEST_METHOD(16) {\n\t\tset_test_name(\"Request Smuggling type: 1\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"POST / HTTP/1.1\\r\\n\"\n\t\t\t\"Host: whatever\\r\\n\"\n\t\t\t\"Transfer-Encoding: ,chunked\\r\\n\"\n\t\t\t\"Content-Length: 5\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"0\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"Response starts with error\",\n\t\t\tstartsWith(response,\n\t\t\t\"HTTP/1.0 400 Bad Request\\r\\n\"\n\t\t\t\"Status: 400 Bad Request\\r\\n\"\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\"));\n\t\t// Not sure why the error is HPE_INVALID_CONTENT_LENGTH\n\t\t// instead of HPE_UNEXPECTED_CONTENT_LENGTH. But we already have\n\t\t// a different test that tests Transfer-Encoding and Content-Length\n\t\t// simultaneously are not allowed, so this is not a big deal.\n\t\tensure(\"Response ends with error\",\n\t\t\tendsWith(response,\n\t\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\t\"Content-Length: 42\\r\\n\"\n\t\t\t\t\"cache-control: no-cache, no-store, must-revalidate\\r\\n\"\n\t\t\t\t\"\\r\\n\"\n\t\t\t\t\"invalid character in content-length header\"));\n\t\tensure_equals(\"Response size is correct\", response.size(), 265u);\n\t}\n\n\tTEST_METHOD(17) {\n\t\tset_test_name(\"Request Smuggling type: 2\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"POST / HTTP/1.1\\r\\n\"\n\t\t\t\"Host: whatever\\r\\n\"\n\t\t\t\"Transfer-\\r\\n\"\n\t\t\t\"Encoding: chunked\\r\\n\"\n\t\t\t\"Content-Length: 5\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"0\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"Response starts with error\",\n\t\t\tstartsWith(response,\n\t\t\t\"HTTP/1.0 400 Bad Request\\r\\n\"\n\t\t\t\"Status: 400 Bad Request\\r\\n\"\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\"));\n\t\tensure(\"Response ends with error\",\n\t\t\tendsWith(response,\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 27\\r\\n\"\n\t\t\t\"cache-control: no-cache, no-store, must-revalidate\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"invalid character in header\"));\n\t\tensure_equals(\"Response size is correct\", response.size(), 250u);\n\t}\n\n\tTEST_METHOD(18) {\n\t\tset_test_name(\"Request Smuggling type: 3\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"POST / HTTP/1.1\\r\\n\"\n\t\t\t\"Host: whatever\\r\\n\"\n\t\t\t\"Transfer-Encoding: ,chunked\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"0\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t);\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(\"Response is ok\",\n\t\t\tresponse,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"hello /\");\n\t}\n\n\t/***** Fixed body handling *****/\n\n\tTEST_METHOD(20) {\n\t\tset_test_name(\"An empty body is treated the same as no body\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 0\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"Body required\"));\n\t}\n\n\tTEST_METHOD(21) {\n\t\tset_test_name(\"Non-empty body in one part\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 2\\r\\n\\r\\n\"\n\t\t\t\"ok\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"2 bytes: ok\"));\n\t}\n\n\tTEST_METHOD(22) {\n\t\tset_test_name(\"Non-empty body in multiple parts\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hm\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"ok\");\n\t\tensure(!hasResponseData());\n\t\tsendRequest(\"!!!\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"7 bytes: hmok!!!\"));\n\t}\n\n\tTEST_METHOD(23) {\n\t\tset_test_name(\"req->bodyChannel is stopped before request body data is received\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_stop_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hmok!!!\");\n\t\tEVENTUALLY(5,\n\t\t\tresult = getNumRequestsWaitingToStartAcceptingBody() == 1;\n\t\t);\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstartAcceptingBody();\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"7 bytes: hmok!!!\"));\n\t}\n\n\tTEST_METHOD(24) {\n\t\tset_test_name(\"req->bodyChannel is stopped before unexpected request body EOF is encountered\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_stop_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 3\\r\\n\\r\\n\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\t\tEVENTUALLY(5,\n\t\t\tresult = getNumRequestsWaitingToStartAcceptingBody() == 1;\n\t\t);\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstartAcceptingBody();\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"Request body error: Unexpected end-of-stream\"));\n\t}\n\n\tTEST_METHOD(25) {\n\t\tset_test_name(\"Premature body termination\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hm\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"ok\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"!\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Request body error: Unexpected end-of-stream\\n\"\n\t\t\t\"5 bytes: hmok!\"));\n\t}\n\n\tTEST_METHOD(26) {\n\t\tset_test_name(\"Trailing data after body\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 2\\r\\n\\r\\n\"\n\t\t\t\"hmok\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"2 bytes: hm\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"ok\"));\n\t\tEVENTUALLY(5,\n\t\t\tresult = getTotalBytesConsumed() == strlen(\n\t\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\t\"Content-Length: 2\\r\\n\\r\\n\"\n\t\t\t\t\"hm\");\n\t\t);\n\t}\n\n\n\t/***** Chunked body handling: auto-dechunking on *****/\n\n\tTEST_METHOD(30) {\n\t\tset_test_name(\"Empty body\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"0 bytes: \"));\n\t}\n\n\tTEST_METHOD(31) {\n\t\tset_test_name(\"Non-empty body in one part\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"ok\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"2 bytes: ok\"));\n\t}\n\n\tTEST_METHOD(32) {\n\t\tset_test_name(\"Non-empty body in multiple parts\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"h\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"m\\r\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"\\n2\\r\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"\\no\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"k\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"\\r\\n3\\r\\n\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"!\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"!!\\r\\n0\");\n\t\tensure(!hasResponseData());\n\t\tsendRequest(\"\\r\\n\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"7 bytes: hmok!!!\"));\n\t}\n\n\tTEST_METHOD(33) {\n\t\tset_test_name(\"Premature body termination\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"7\\r\\nhmok!\");\n\t\tensure(!hasResponseData());\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Request body error: Unexpected end-of-stream\\n\"\n\t\t\t\"5 bytes: hmok!\"));\n\t}\n\n\tTEST_METHOD(34) {\n\t\tset_test_name(\"req->bodyChannel is stopped before request body data is received\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_stop_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"3\\r\\n\"\n\t\t\t\"abc\\r\\n\"\n\t\t\t\"0\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tEVENTUALLY(5,\n\t\t\tresult = getNumRequestsWaitingToStartAcceptingBody() == 1;\n\t\t);\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstartAcceptingBody();\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"3 bytes: abc\"));\n\t}\n\n\tTEST_METHOD(35) {\n\t\tset_test_name(\"Trailing data after body\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"hm\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\"\n\t\t\t\"ok\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"2 bytes: hm\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"ok\"));\n\t\tEVENTUALLY(5,\n\t\t\tresult = getTotalBytesConsumed() == P_STATIC_STRING(\n\t\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\t\"2\\r\\n\"\n\t\t\t\t\"hm\\r\\n\"\n\t\t\t\t\"0\\r\\n\\r\\n\").size();\n\t\t);\n\t}\n\n\tTEST_METHOD(36) {\n\t\tset_test_name(\"Unterminated final chunk\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"7\\r\\nhmok!!!\\r\\n0\\r\\n\\r\");\n\t\tensure(!hasResponseData());\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Request body error: Unexpected end-of-stream\\n\"\n\t\t\t\"7 bytes: hmok!!!\"));\n\t}\n\n\tTEST_METHOD(37) {\n\t\tset_test_name(\"Invalid chunk header\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"!\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"0 bytes: \"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"!\"));\n\t}\n\n\tTEST_METHOD(38) {\n\t\tset_test_name(\"Invalid chunk footer\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\nok!\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"2 bytes: ok\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"!\"));\n\t}\n\n\tTEST_METHOD(39) {\n\t\tset_test_name(\"Chunk larger than MAX_CHUNK_SIZE bytes\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t+ toString(ServerKit::HttpChunkedBodyParserState::MAX_CHUNK_SIZE + 1) + \"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\tP_STATIC_STRING(\"Request body error: \")\n\t\t\t+ ServerKit::getErrorDesc(ServerKit::CHUNK_SIZE_TOO_LARGE)\n\t\t\t+ \"\\n\"));\n\t}\n\n\n\t/***** Chunked body handling: auto-dechunking off *****/\n\n\tTEST_METHOD(40) {\n\t\tset_test_name(\"Empty body\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"5 bytes: 0\\r\\n\\r\\n\"));\n\t}\n\n\tTEST_METHOD(41) {\n\t\tset_test_name(\"Non-empty body in one part\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"ok\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"12 bytes: 2\\r\\nok\\r\\n0\\r\\n\\r\\n\"));\n\t}\n\n\tTEST_METHOD(42) {\n\t\tset_test_name(\"Non-empty body in multiple parts\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"h\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"m\\r\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"\\n2\\r\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"\\no\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"k\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"\\r\\n3\\r\\n\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"!\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"!!\\r\\n0\");\n\t\tensure(!hasResponseData());\n\t\tsendRequest(\"\\r\\n\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"27 bytes: 2\\r\\nhm\\r\\n2\\r\\nok\\r\\n3\\r\\n!!!\\r\\n0\\r\\n\\r\\n\"));\n\t}\n\n\tTEST_METHOD(43) {\n\t\tset_test_name(\"Premature body termination\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"7\\r\\nhmok!\");\n\t\tensure(!hasResponseData());\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Request body error: Unexpected end-of-stream\\n\"\n\t\t\t\"8 bytes: 7\\r\\nhmok!\"));\n\t}\n\n\tTEST_METHOD(44) {\n\t\tset_test_name(\"req->bodyChannel is stopped before request body data is received\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_stop_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"3\\r\\n\"\n\t\t\t\"abc\\r\\n\"\n\t\t\t\"0\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tEVENTUALLY(5,\n\t\t\tresult = getNumRequestsWaitingToStartAcceptingBody() == 1;\n\t\t);\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstartAcceptingBody();\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"13 bytes: 3\\r\\nabc\\r\\n0\\r\\n\\r\\n\"));\n\t}\n\n\tTEST_METHOD(45) {\n\t\tset_test_name(\"Trailing data after body\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"hm\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\"\n\t\t\t\"ok\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"12 bytes: 2\\r\\nhm\\r\\n0\\r\\n\\r\\n\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"ok\"));\n\t\tEVENTUALLY(5,\n\t\t\tresult = getTotalBytesConsumed() == P_STATIC_STRING(\n\t\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\t\"2\\r\\n\"\n\t\t\t\t\"hm\\r\\n\"\n\t\t\t\t\"0\\r\\n\\r\\n\").size();\n\t\t);\n\t}\n\n\tTEST_METHOD(46) {\n\t\tset_test_name(\"Unterminated final chunk\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"7\\r\\nhmok!!!\\r\\n0\\r\\n\\r\");\n\t\tensure(!hasResponseData());\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Request body error: Unexpected end-of-stream\\n\"\n\t\t\t\"16 bytes: 7\\r\\nhmok!!!\\r\\n0\\r\\n\\r\"));\n\t}\n\n\tTEST_METHOD(47) {\n\t\tset_test_name(\"Invalid chunk header\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"!\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"0 bytes: \"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"!\"));\n\t}\n\n\tTEST_METHOD(48) {\n\t\tset_test_name(\"Invalid chunk footer\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\nok!\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"5 bytes: 2\\r\\nok\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"!\"));\n\t}\n\n\n\t/***** Upgrade handling *****/\n\n\tTEST_METHOD(50) {\n\t\tset_test_name(\"Empty body\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"0 bytes: \"));\n\t}\n\n\tTEST_METHOD(51) {\n\t\tset_test_name(\"Non-empty data in one part\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\"\n\t\t\t\"ok\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"2 bytes: ok\"));\n\t}\n\n\tTEST_METHOD(52) {\n\t\tset_test_name(\"Non-empty body in multiple parts\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\"\n\t\t\t\"hm\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"ok\");\n\t\tensure(!hasResponseData());\n\t\tsendRequest(\"!!!\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"7 bytes: hmok!!!\"));\n\t}\n\n\tTEST_METHOD(53) {\n\t\tset_test_name(\"req->bodyChannel is stopped before request body data is received\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_stop_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\"\n\t\t\t\"hmok!!!\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\t\tEVENTUALLY(5,\n\t\t\tresult = getNumRequestsWaitingToStartAcceptingBody() == 1;\n\t\t);\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstartAcceptingBody();\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"7 bytes: hmok!!!\"));\n\t}\n\n\tTEST_METHOD(54) {\n\t\tset_test_name(\"req->bodyChannel is stopped before request body EOF is encountered\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_stop_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\t\tEVENTUALLY(5,\n\t\t\tresult = getNumRequestsWaitingToStartAcceptingBody() == 1;\n\t\t);\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstartAcceptingBody();\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"0 bytes: \"));\n\t}\n\n\tTEST_METHOD(55) {\n\t\tset_test_name(\"It rejects the upgrade if supportsUpgrade() returns false\");\n\n\t\tserver->allowUpgrades = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"Connection upgrading not allowed for this request\"));\n\t}\n\n\tTEST_METHOD(56) {\n\t\tset_test_name(\"It rejects the upgrade if the request contains a request body\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\"\n\t\t\t\"Content-Length: 3\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 400 Bad Request\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Connection upgrading is only allowed for requests without request body\"));\n\t}\n\n\tTEST_METHOD(57) {\n\t\tset_test_name(\"It rejects the upgrade if the request is HEAD\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"HEAD /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 400 Bad Request\\r\\n\"));\n\t}\n\n\n\t/***** Secure headers handling *****/\n\n\tTEST_METHOD(60) {\n\t\tset_test_name(\"It stores secure headers in req->secureHeaders\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /joo HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"!~: x\\r\\n\"\n\t\t\t\"!~Secure: secret\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 25\\r\\n\\r\\n\"\n\t\t\t\"hello /joo\\n\"\n\t\t\t\"Secure: secret\");\n\t}\n\n\tTEST_METHOD(61) {\n\t\tset_test_name(\"It rejects normal headers while in secure mode\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"!~: x\\r\\n\"\n\t\t\t\"!~Secure: secret\\r\\n\"\n\t\t\t\"Foo: bar\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.0 400 Bad Request\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"A normal header was encountered after the security password header\"));\n\t}\n\n\tTEST_METHOD(62) {\n\t\tset_test_name(\"It rejects secure headers while in normal mode\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"!~Secure: secret\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.0 400 Bad Request\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"A secure header was provided, but no security password was provided\"));\n\t}\n\n\tTEST_METHOD(63) {\n\t\tset_test_name(\"If no secure mode password is given in the context, \"\n\t\t\t\"switching to secure mode is always possible\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"!~: anything\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t}\n\n\tTEST_METHOD(64) {\n\t\tset_test_name(\"If a secure mode password is given in the context, \"\n\t\t\t\"it rejects requests that specify the wrong secure mode password\");\n\n\t\tJson::Value config;\n\t\tvector<ConfigKit::Error> errors;\n\t\tconfig[\"secure_mode_password\"] = \"secret\";\n\t\tensure(context.configure(config, errors));\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"!~: wrong\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.0 400 Bad Request\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Security password mismatch\"));\n\t}\n\n\tTEST_METHOD(65) {\n\t\tset_test_name(\"If a secure mode password is given in the context, \"\n\t\t\t\"it accepts requests that specify the correct secure mode password\");\n\n\t\tJson::Value config;\n\t\tvector<ConfigKit::Error> errors;\n\t\tconfig[\"secure_mode_password\"] = \"secret\";\n\t\tensure(context.configure(config, errors));\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"!~: secret\\r\\n\"\n\t\t\t\"!~Foo: bar\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t}\n\n\n\t/***** Request ending *****/\n\n\tTEST_METHOD(70) {\n\t\tset_test_name(\"If all output data is flushed, and keep-alive is not possible, \"\n\t\t\t\"it disconnects the client immediately\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\treadAll(fd, std::numeric_limits<size_t>::max()); // Does not block\n\t}\n\n\tTEST_METHOD(71) {\n\t\tset_test_name(\"If all output data is flushed, and keep-alive is possible, \"\n\t\t\t\"it handles the next request immediately\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\"\n\t\t\t\"GET /foo HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hello /\"\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 10\\r\\n\\r\\n\"\n\t\t\t\"hello /foo\");\n\t}\n\n\tTEST_METHOD(72) {\n\t\tset_test_name(\"If there is unflushed output data, and keep-alive is not possible, \"\n\t\t\t\"it disconnects the client after all output data is flushed\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /large_response HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"Size: 1000000\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024 * 1024).first;\n\t\tstring body = stripHeaders(response);\n\t\tensure(startsWith(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure_equals(body.size(), 1000000u);\n\t}\n\n\tTEST_METHOD(73) {\n\t\tset_test_name(\"If there is unflushed output data, and keep-alive is possible, \"\n\t\t\t\"it handles the next request after all output data is flushed\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /large_response HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"Size: 1000000\\r\\n\\r\\n\"\n\t\t\t\"GET /foo HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = getTotalRequestsBegun() > 1;\n\t\t);\n\n\t\tstring data = readAll(fd, 1024 * 1024).first;\n\t\tstring response2 =\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 10\\r\\n\\r\\n\"\n\t\t\t\"hello /foo\";\n\n\t\tstring body = stripHeaders(data);\n\t\tensure(startsWith(data, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure_equals(body.size(), 1000000u + response2.size());\n\t\tensure_equals(body.substr(1000000), response2);\n\t}\n\n\tTEST_METHOD(74) {\n\t\tset_test_name(\"If a request with body is ended but output is being flushed, \"\n\t\t\t\"then any received request body data will be discard\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /large_response HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"Size: 1000000\\r\\n\"\n\t\t\t\"Content-Length: 4\\r\\n\\r\\n\");\n\t\tEVENTUALLY(1,\n\t\t\tresult = getTotalRequestsBegun() == 1;\n\t\t);\n\n\t\tunsigned long long previouslyBytesConsumed;\n\t\tpreviouslyBytesConsumed = getTotalBytesConsumed();\n\n\t\twriteExact(fd, \"abcd\");\n\t\tstring response = readAll(fd, 1024 * 1024).first;\n\t\tstring body = stripHeaders(response);\n\t\tensure(startsWith(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure_equals(body.size(), 1000000u);\n\t\tEVENTUALLY(1,\n\t\t\tresult = getTotalBytesConsumed() > previouslyBytesConsumed;\n\t\t);\n\t\tensure_equals(getBodyBytesRead(), 0u);\n\t}\n\n\tTEST_METHOD(75) {\n\t\tset_test_name(\"If a request with body is ended but output is being flushed, \"\n\t\t\t\"then it won't attempt to keep-alive the connection after the output is flushed\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /large_response HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"Size: 1000000\\r\\n\"\n\t\t\t\"Content-Length: 4\\r\\n\\r\\n\");\n\t\tEVENTUALLY(1,\n\t\t\tresult = getTotalRequestsBegun() == 1;\n\t\t);\n\n\t\tunsigned long long previouslyBytesConsumed;\n\t\tpreviouslyBytesConsumed = getTotalBytesConsumed();\n\n\t\twriteExact(fd,\n\t\t\t\"abcd\"\n\t\t\t\"GET /foo HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024 * 1024).first;\n\t\tstring body = stripHeaders(response);\n\t\tensure(startsWith(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure_equals(body.size(), 1000000u);\n\t\tEVENTUALLY(1,\n\t\t\tresult = getTotalBytesConsumed() > previouslyBytesConsumed;\n\t\t);\n\t\tensure_equals(getBodyBytesRead(), 0u);\n\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = getTotalRequestsBegun() > 1;\n\t\t);\n\t}\n\n\n\t/***** Early half-close detection *****/\n\n\tTEST_METHOD(80) {\n\t\tset_test_name(\"Detection of half-close after non-empty body fully received\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /half_close_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Content-Length: 2\\r\\n\\r\\n\"\n\t\t\t\"hm\");\n\t\tshutdown(fd, SHUT_WR);\n\t\tEVENTUALLY(5,\n\t\t\tresult = getHalfCloseDetected() == 1;\n\t\t);\n\t}\n\n\tTEST_METHOD(81) {\n\t\tset_test_name(\"Detection of half-close when body is empty\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /half_close_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\\r\\n\");\n\t\tshutdown(fd, SHUT_WR);\n\t\tEVENTUALLY(5,\n\t\t\tresult = getHalfCloseDetected() == 1;\n\t\t);\n\t}\n\n\tTEST_METHOD(82) {\n\t\tset_test_name(\"Detection of half-close after body fully received\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /half_close_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"hm\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\");\n\t\tshutdown(fd, SHUT_WR);\n\t\tEVENTUALLY(5,\n\t\t\tresult = getHalfCloseDetected() == 1;\n\t\t);\n\t}\n\n\tTEST_METHOD(83) {\n\t\tset_test_name(\"Normal data is not detected as early half close\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /half_close_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\\r\\n\"\n\t\t\t\"hm\");\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = getHalfCloseDetected() > 0;\n\t\t);\n\t}\n\n\tTEST_METHOD(84) {\n\t\tset_test_name(\"Request body socket errors that occur after the body\"\n\t\t\t\" is fully received are processed at the next request\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /early_read_error_detection_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\\r\\n\"\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\\r\\n\");\n\t\tEVENTUALLY(5,\n\t\t\tresult = getClientDataErrors() == 1;\n\t\t);\n\t\tensure_equals(getTotalRequestsBegun(), 1u);\n\t}\n\n\n\t/***** Shutdown *****/\n\n\tTEST_METHOD(90) {\n\t\tset_test_name(\"Upon shutting down the server, no requests will be \"\n\t\t\t\"eligible for keep-alive\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Content-Length: 3\\r\\n\\r\\n\");\n\t\tshutdownServer();\n\n\t\tsendRequest(\"ab\\n\"\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"Connection: close\"));\n\t\tensure(\"(2)\", !containsSubstring(response, \"Connection: keep-alive\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"hello /\"));\n\t}\n\n\tTEST_METHOD(91) {\n\t\tset_test_name(\"Upon shutting down the server, requests for which the \"\n\t\t\t\"headers are being parsed are not disconnected\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET / HTTP/1.1\\r\\n\");\n\t\tshutdownServer();\n\t\tEVENTUALLY(100,\n\t\t\tresult = !hasResponseData();\n\t\t);\n\n\t\tsendRequest(\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"Connection: close\"));\n\t\tensure(\"(2)\", !containsSubstring(response, \"Connection: keep-alive\"));\n\t\tensure(\"(3)\", containsSubstring(response, \"hello /\"));\n\t}\n\n\tTEST_METHOD(92) {\n\t\tset_test_name(\"Upon shutting down the server, requests for which the \"\n\t\t\t\"headers are being parsed are disconnected when they've been \"\n\t\t\t\"identified as upgraded requests\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: tcp\\r\\n\");\n\t\tshutdownServer();\n\t\tEVENTUALLY(100,\n\t\t\tresult = !hasResponseData();\n\t\t);\n\n\t\tsendRequest(\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"503 Service Unavailable\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"Connection: close\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"Connection: keep-alive\"));\n\t}\n\n\tTEST_METHOD(93) {\n\t\tset_test_name(\"Upon shutting down the server, normal requests which \"\n\t\t\t\"are being processed are not disconnected\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Content-Length: 2\\r\\n\\r\\n\");\n\t\tshutdownServer();\n\t\tEVENTUALLY(100,\n\t\t\tresult = !hasResponseData();\n\t\t);\n\n\t\tsendRequest(\"ab\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"Connection: close\"));\n\t\tensure(\"(2)\", !containsSubstring(response, \"Connection: keep-alive\"));\n\t\tensure(\"(3)\", containsSubstring(response, \"2 bytes: ab\"));\n\t}\n\n\tTEST_METHOD(94) {\n\t\tset_test_name(\"Upon shutting down the server, upgraded requests which \"\n\t\t\t\"are being processed are disconnected\");\n\n\t\tif (defaultLogLevel == (LoggingKit::Level) DEFAULT_LOG_LEVEL) {\n\t\t\t// If the user did not customize the test's log level,\n\t\t\t// then we'll want to tone down the noise.\n\t\t\tLoggingKit::setLevel(LoggingKit::CRIT);\n\t\t}\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: tcp\\r\\n\\r\\n\");\n\t\tshutdownServer();\n\t\tEVENTUALLY(5,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response, \"\");\n\t}\n\n\n\t/***** Miscellaneous *****/\n\n\tTEST_METHOD(100) {\n\t\tset_test_name(\"It responds with the same HTTP version as the request\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.0\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hello /\");\n\t}\n\n\tTEST_METHOD(101) {\n\t\tset_test_name(\"For requests without body, keep-alive is possible\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring header = readResponseHeader();\n\t\tensure(containsSubstring(header, \"Connection: keep-alive\"));\n\t}\n\n\tTEST_METHOD(102) {\n\t\tset_test_name(\"If the request body is fully read, keep-alive is possible\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"Content-Length: 2\\r\\n\\r\\n\"\n\t\t\t\"ok\");\n\t\tstring header = readResponseHeader();\n\t\tensure(containsSubstring(header, \"Connection: keep-alive\"));\n\t}\n\n\tTEST_METHOD(103) {\n\t\tset_test_name(\"If the request body is not fully read, keep-alive is not possible\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"Content-Length: 2\\r\\n\\r\\n\");\n\t\tstring header = readResponseHeader();\n\t\tensure(containsSubstring(header, \"Connection: close\"));\n\t}\n\n\tTEST_METHOD(104) {\n\t\tset_test_name(\"It defaults to not using keep-alive for HTTP <= 1.0 requests\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.0\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring header = readResponseHeader();\n\t\tensure(containsSubstring(header, \"Connection: close\"));\n\t}\n\n\tTEST_METHOD(105) {\n\t\tset_test_name(\"It defaults to using keep-alive for HTTP >= 1.1 requests\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring header = readResponseHeader();\n\t\tensure(containsSubstring(header, \"Connection: keep-alive\"));\n\t}\n\n\tTEST_METHOD(106) {\n\t\tset_test_name(\"writeSimpleResponse() doesn't output the body for HEAD requests\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"HEAD / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\");\n\t}\n\n\tTEST_METHOD(107) {\n\t\tset_test_name(\"Client socket write error handling\");\n\n\t\tif (defaultLogLevel == (LoggingKit::Level) DEFAULT_LOG_LEVEL) {\n\t\t\t// If the user did not customize the test's log level,\n\t\t\t// then we'll want to tone down the noise.\n\t\t\tLoggingKit::setLevel(LoggingKit::CRIT);\n\t\t}\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /large_response HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Size: 1000000\\r\\n\\r\\n\");\n\t\tfd.close();\n\n\t\tEVENTUALLY(5,\n\t\t\tresult = getActiveClientCount() == 0;\n\t\t);\n\t}\n}", "target": 1}
{"idx": 127, "func": "string readResponseHeader() {\n\t\t\tstring result;\n\t\t\tstring line;\n\t\t\tdo {\n\t\t\t\tline = io.readLine();\n\t\t\t\tif (line.empty()) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tresult.append(line);\n\t\t\t\t\tif (line == \"\\r\\n\") {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (true);\n\t\t\treturn result;\n\t\t}\n\t};\n\n\tDEFINE_TEST_GROUP_WITH_LIMIT(ServerKit_HttpServerTest, 120);\n\n\n\t/***** Valid HTTP header parsing *****/\n\n\tTEST_METHOD(1) {\n\t\tset_test_name(\"A complete header in one part\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024 * 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hello /\");\n\t}\n\n\tTEST_METHOD(2) {\n\t\tset_test_name(\"A complete header in multiple random-sized parts\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connect\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequestAndWait(\n\t\t\t\"ion: close\\r\\n\"\n\t\t\t\"Host: fo\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequest(\n\t\t\t\"o\\r\\n\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hello /\");\n\t}\n\n\tTEST_METHOD(3) {\n\t\tset_test_name(\"A complete header in multiple complete lines\");\n\n\t\tconnectToServer();\n\n\t\tsendRequestAndWait(\"GET / HTTP/1.1\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequestAndWait(\"Connection: close\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequestAndWait(\"Host: foo\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequest(\"\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hello /\");\n\t}\n\n\tTEST_METHOD(4) {\n\t\tset_test_name(\"The request path is stored in req->path, \"\n\t\t\t\"and headers are stored in req->headers\");\n\n\t\tconnectToServer();\n\n\t\tsendRequestAndWait(\"GET /\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"jo\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"o HTTP/1.1\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequestAndWait(\"Connection: close\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequestAndWait(\"Host: foo\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequestAndWait(\"F\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"oo: \");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"b\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"ar\\r\\n\");\n\t\tensure(!hasResponseData());\n\n\t\tsendRequest(\"\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 19\\r\\n\\r\\n\"\n\t\t\t\"hello /joo\\n\"\n\t\t\t\"Foo: bar\");\n\t}\n\n\tTEST_METHOD(5) {\n\t\tset_test_name(\"It ensures that req->path is contiguous\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\"GET /p\");\n\t\tsendRequestAndWait(\n\t\t\t\"ath_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(containsSubstring(response, \"Contiguous: 1\"));\n\t}\n\n\n\t/***** Invalid HTTP header parsing *****/\n\n\tTEST_METHOD(7) {\n\t\tset_test_name(\"Incomplete header, without closing connection\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\"GET / HTT\");\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\t}\n\n\tTEST_METHOD(8) {\n\t\tset_test_name(\"Incomplete header, half-closing connection\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\"GET / HTT\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response, \"\");\n\t}\n\n\tTEST_METHOD(9) {\n\t\tset_test_name(\"Invalid header data\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\"whatever\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(containsSubstring(response,\n\t\t\t\"HTTP/1.0 400 Bad Request\\r\\n\"\n\t\t\t\"Status: 400 Bad Request\\r\\n\"\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\"));\n\t\tensure(containsSubstring(response,\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 19\\r\\n\"\n\t\t\t\"cache-control: no-cache, no-store, must-revalidate\\r\\n\\r\\n\"\n\t\t\t\"invalid HTTP method\"));\n\t}\n\n\n\t/***** Invalid request *****/\n\n\tTEST_METHOD(14) {\n\t\tset_test_name(\"HTTP > 1.1\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.2\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(containsSubstring(response,\n\t\t\t\"HTTP/1.0 505 HTTP Version Not Supported\\r\\n\"\n\t\t\t\"Status: 505 HTTP Version Not Supported\\r\\n\"\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\"));\n\t\tensure(containsSubstring(response,\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 27\\r\\n\"\n\t\t\t\"cache-control: no-cache, no-store, must-revalidate\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"HTTP version not supported\"));\n\t}\n\n\tTEST_METHOD(15) {\n\t\tset_test_name(\"Transfer-Encoding and Content-Length given simultaneously\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 3\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(containsSubstring(response,\n\t\t\t\"HTTP/1.0 400 Bad Request\\r\\n\"\n\t\t\t\"Status: 400 Bad Request\\r\\n\"\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\"));\n\t\tensure(containsSubstring(response,\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 79\\r\\n\"\n\t\t\t\"cache-control: no-cache, no-store, must-revalidate\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"Bad request (request may not contain both Content-Length and Transfer-Encoding)\"));\n\t}\n\n\tTEST_METHOD(16) {\n\t\tset_test_name(\"Request Smuggling type: 1\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"POST / HTTP/1.1\\r\\n\"\n\t\t\t\"Host: whatever\\r\\n\"\n\t\t\t\"Transfer-Encoding: ,chunked\\r\\n\"\n\t\t\t\"Content-Length: 5\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"0\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"Response starts with error\",\n\t\t\tstartsWith(response,\n\t\t\t\"HTTP/1.0 400 Bad Request\\r\\n\"\n\t\t\t\"Status: 400 Bad Request\\r\\n\"\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\"));\n\t\t// Not sure why the error is HPE_INVALID_CONTENT_LENGTH\n\t\t// instead of HPE_UNEXPECTED_CONTENT_LENGTH. But we already have\n\t\t// a different test that tests Transfer-Encoding and Content-Length\n\t\t// simultaneously are not allowed, so this is not a big deal.\n\t\tensure(\"Response ends with error\",\n\t\t\tendsWith(response,\n\t\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\t\"Content-Length: 42\\r\\n\"\n\t\t\t\t\"cache-control: no-cache, no-store, must-revalidate\\r\\n\"\n\t\t\t\t\"\\r\\n\"\n\t\t\t\t\"invalid character in content-length header\"));\n\t\tensure_equals(\"Response size is correct\", response.size(), 265u);\n\t}\n\n\tTEST_METHOD(17) {\n\t\tset_test_name(\"Request Smuggling type: 2\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"POST / HTTP/1.1\\r\\n\"\n\t\t\t\"Host: whatever\\r\\n\"\n\t\t\t\"Transfer-\\r\\n\"\n\t\t\t\"Encoding: chunked\\r\\n\"\n\t\t\t\"Content-Length: 5\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"0\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"Response starts with error\",\n\t\t\tstartsWith(response,\n\t\t\t\"HTTP/1.0 400 Bad Request\\r\\n\"\n\t\t\t\"Status: 400 Bad Request\\r\\n\"\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\"));\n\t\tensure(\"Response ends with error\",\n\t\t\tendsWith(response,\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 27\\r\\n\"\n\t\t\t\"cache-control: no-cache, no-store, must-revalidate\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"invalid character in header\"));\n\t\tensure_equals(\"Response size is correct\", response.size(), 250u);\n\t}\n\n\tTEST_METHOD(18) {\n\t\tset_test_name(\"Request Smuggling type: 3\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"POST / HTTP/1.1\\r\\n\"\n\t\t\t\"Host: whatever\\r\\n\"\n\t\t\t\"Transfer-Encoding: ,chunked\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"0\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t);\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(\"Response is ok\",\n\t\t\tresponse,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\"\n\t\t\t\"\\r\\n\"\n\t\t\t\"hello /\");\n\t}\n\n\tTEST_METHOD(19) {\n\t\tset_test_name(\"It responds with correct error if http method is not recognized\");\n\n\t\t// send invalid request\n\t\tconnectToServer();\n\t\tsendRequest(\"BAD_METHOD / HTTP/1.1\\r\\n\"\n\t\t\t\t\t\"Connection: close\\r\\n\" \n\t\t\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\n\t\tensure(\"Response starts with error\",\n\t\t\t   startsWith(response,\n\t\t\t\t\t\t  \"HTTP/1.0 400 Bad Request\\r\\n\"\n\t\t\t\t\t\t  \"Status: 400 Bad Request\\r\\n\"\n\t\t\t\t\t\t  \"Content-Type: text/html; charset=UTF-8\\r\\n\"));\n\n\t\tensure(\"Response ends with error\",\n\t\t\t   endsWith(response,\n\t\t\t\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\t\t\t\"Content-Length: 19\\r\\n\"\n\t\t\t\t\t\t\"cache-control: no-cache, no-store, must-revalidate\\r\\n\"\n\t\t\t\t\t\t\"\\r\\n\"\n\t\t\t\t\t\t\"invalid HTTP method\"));\n\t\tensure_equals(\"Response size is correct\", response.size(), 242u);\n\t}\n\n\t/***** Fixed body handling *****/\n\n\tTEST_METHOD(20) {\n\t\tset_test_name(\"An empty body is treated the same as no body\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 0\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"Body required\"));\n\t}\n\n\tTEST_METHOD(21) {\n\t\tset_test_name(\"Non-empty body in one part\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 2\\r\\n\\r\\n\"\n\t\t\t\"ok\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"2 bytes: ok\"));\n\t}\n\n\tTEST_METHOD(22) {\n\t\tset_test_name(\"Non-empty body in multiple parts\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hm\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"ok\");\n\t\tensure(!hasResponseData());\n\t\tsendRequest(\"!!!\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"7 bytes: hmok!!!\"));\n\t}\n\n\tTEST_METHOD(23) {\n\t\tset_test_name(\"req->bodyChannel is stopped before request body data is received\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_stop_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hmok!!!\");\n\t\tEVENTUALLY(5,\n\t\t\tresult = getNumRequestsWaitingToStartAcceptingBody() == 1;\n\t\t);\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstartAcceptingBody();\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"7 bytes: hmok!!!\"));\n\t}\n\n\tTEST_METHOD(24) {\n\t\tset_test_name(\"req->bodyChannel is stopped before unexpected request body EOF is encountered\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_stop_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 3\\r\\n\\r\\n\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\t\tEVENTUALLY(5,\n\t\t\tresult = getNumRequestsWaitingToStartAcceptingBody() == 1;\n\t\t);\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstartAcceptingBody();\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"Request body error: Unexpected end-of-stream\"));\n\t}\n\n\tTEST_METHOD(25) {\n\t\tset_test_name(\"Premature body termination\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hm\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"ok\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"!\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Request body error: Unexpected end-of-stream\\n\"\n\t\t\t\"5 bytes: hmok!\"));\n\t}\n\n\tTEST_METHOD(26) {\n\t\tset_test_name(\"Trailing data after body\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 2\\r\\n\\r\\n\"\n\t\t\t\"hmok\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"2 bytes: hm\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"ok\"));\n\t\tEVENTUALLY(5,\n\t\t\tresult = getTotalBytesConsumed() == strlen(\n\t\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\t\"Content-Length: 2\\r\\n\\r\\n\"\n\t\t\t\t\"hm\");\n\t\t);\n\t}\n\n\n\t/***** Chunked body handling: auto-dechunking on *****/\n\n\tTEST_METHOD(30) {\n\t\tset_test_name(\"Empty body\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"0 bytes: \"));\n\t}\n\n\tTEST_METHOD(31) {\n\t\tset_test_name(\"Non-empty body in one part\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"ok\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"2 bytes: ok\"));\n\t}\n\n\tTEST_METHOD(32) {\n\t\tset_test_name(\"Non-empty body in multiple parts\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"h\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"m\\r\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"\\n2\\r\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"\\no\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"k\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"\\r\\n3\\r\\n\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"!\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"!!\\r\\n0\");\n\t\tensure(!hasResponseData());\n\t\tsendRequest(\"\\r\\n\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"7 bytes: hmok!!!\"));\n\t}\n\n\tTEST_METHOD(33) {\n\t\tset_test_name(\"Premature body termination\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"7\\r\\nhmok!\");\n\t\tensure(!hasResponseData());\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Request body error: Unexpected end-of-stream\\n\"\n\t\t\t\"5 bytes: hmok!\"));\n\t}\n\n\tTEST_METHOD(34) {\n\t\tset_test_name(\"req->bodyChannel is stopped before request body data is received\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_stop_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"3\\r\\n\"\n\t\t\t\"abc\\r\\n\"\n\t\t\t\"0\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tEVENTUALLY(5,\n\t\t\tresult = getNumRequestsWaitingToStartAcceptingBody() == 1;\n\t\t);\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstartAcceptingBody();\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"3 bytes: abc\"));\n\t}\n\n\tTEST_METHOD(35) {\n\t\tset_test_name(\"Trailing data after body\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"hm\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\"\n\t\t\t\"ok\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"2 bytes: hm\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"ok\"));\n\t\tEVENTUALLY(5,\n\t\t\tresult = getTotalBytesConsumed() == P_STATIC_STRING(\n\t\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\t\"2\\r\\n\"\n\t\t\t\t\"hm\\r\\n\"\n\t\t\t\t\"0\\r\\n\\r\\n\").size();\n\t\t);\n\t}\n\n\tTEST_METHOD(36) {\n\t\tset_test_name(\"Unterminated final chunk\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"7\\r\\nhmok!!!\\r\\n0\\r\\n\\r\");\n\t\tensure(!hasResponseData());\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Request body error: Unexpected end-of-stream\\n\"\n\t\t\t\"7 bytes: hmok!!!\"));\n\t}\n\n\tTEST_METHOD(37) {\n\t\tset_test_name(\"Invalid chunk header\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"!\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"0 bytes: \"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"!\"));\n\t}\n\n\tTEST_METHOD(38) {\n\t\tset_test_name(\"Invalid chunk footer\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\nok!\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"2 bytes: ok\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"!\"));\n\t}\n\n\tTEST_METHOD(39) {\n\t\tset_test_name(\"Chunk larger than MAX_CHUNK_SIZE bytes\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t+ toString(ServerKit::HttpChunkedBodyParserState::MAX_CHUNK_SIZE + 1) + \"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\tP_STATIC_STRING(\"Request body error: \")\n\t\t\t+ ServerKit::getErrorDesc(ServerKit::CHUNK_SIZE_TOO_LARGE)\n\t\t\t+ \"\\n\"));\n\t}\n\n\n\t/***** Chunked body handling: auto-dechunking off *****/\n\n\tTEST_METHOD(40) {\n\t\tset_test_name(\"Empty body\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"5 bytes: 0\\r\\n\\r\\n\"));\n\t}\n\n\tTEST_METHOD(41) {\n\t\tset_test_name(\"Non-empty body in one part\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"ok\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"12 bytes: 2\\r\\nok\\r\\n0\\r\\n\\r\\n\"));\n\t}\n\n\tTEST_METHOD(42) {\n\t\tset_test_name(\"Non-empty body in multiple parts\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"h\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"m\\r\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"\\n2\\r\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"\\no\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"k\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"\\r\\n3\\r\\n\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"!\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"!!\\r\\n0\");\n\t\tensure(!hasResponseData());\n\t\tsendRequest(\"\\r\\n\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"27 bytes: 2\\r\\nhm\\r\\n2\\r\\nok\\r\\n3\\r\\n!!!\\r\\n0\\r\\n\\r\\n\"));\n\t}\n\n\tTEST_METHOD(43) {\n\t\tset_test_name(\"Premature body termination\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"7\\r\\nhmok!\");\n\t\tensure(!hasResponseData());\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Request body error: Unexpected end-of-stream\\n\"\n\t\t\t\"8 bytes: 7\\r\\nhmok!\"));\n\t}\n\n\tTEST_METHOD(44) {\n\t\tset_test_name(\"req->bodyChannel is stopped before request body data is received\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_stop_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"3\\r\\n\"\n\t\t\t\"abc\\r\\n\"\n\t\t\t\"0\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tEVENTUALLY(5,\n\t\t\tresult = getNumRequestsWaitingToStartAcceptingBody() == 1;\n\t\t);\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstartAcceptingBody();\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"13 bytes: 3\\r\\nabc\\r\\n0\\r\\n\\r\\n\"));\n\t}\n\n\tTEST_METHOD(45) {\n\t\tset_test_name(\"Trailing data after body\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"hm\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\"\n\t\t\t\"ok\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"12 bytes: 2\\r\\nhm\\r\\n0\\r\\n\\r\\n\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"ok\"));\n\t\tEVENTUALLY(5,\n\t\t\tresult = getTotalBytesConsumed() == P_STATIC_STRING(\n\t\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\t\"2\\r\\n\"\n\t\t\t\t\"hm\\r\\n\"\n\t\t\t\t\"0\\r\\n\\r\\n\").size();\n\t\t);\n\t}\n\n\tTEST_METHOD(46) {\n\t\tset_test_name(\"Unterminated final chunk\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"7\\r\\nhmok!!!\\r\\n0\\r\\n\\r\");\n\t\tensure(!hasResponseData());\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Request body error: Unexpected end-of-stream\\n\"\n\t\t\t\"16 bytes: 7\\r\\nhmok!!!\\r\\n0\\r\\n\\r\"));\n\t}\n\n\tTEST_METHOD(47) {\n\t\tset_test_name(\"Invalid chunk header\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"!\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"0 bytes: \"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"!\"));\n\t}\n\n\tTEST_METHOD(48) {\n\t\tset_test_name(\"Invalid chunk footer\");\n\n\t\tserver->enableAutoDechunkBody = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\nok!\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"5 bytes: 2\\r\\nok\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"!\"));\n\t}\n\n\n\t/***** Upgrade handling *****/\n\n\tTEST_METHOD(50) {\n\t\tset_test_name(\"Empty body\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"0 bytes: \"));\n\t}\n\n\tTEST_METHOD(51) {\n\t\tset_test_name(\"Non-empty data in one part\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\"\n\t\t\t\"ok\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"2 bytes: ok\"));\n\t}\n\n\tTEST_METHOD(52) {\n\t\tset_test_name(\"Non-empty body in multiple parts\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\"\n\t\t\t\"hm\");\n\t\tensure(!hasResponseData());\n\t\tsendRequestAndWait(\"ok\");\n\t\tensure(!hasResponseData());\n\t\tsendRequest(\"!!!\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"7 bytes: hmok!!!\"));\n\t}\n\n\tTEST_METHOD(53) {\n\t\tset_test_name(\"req->bodyChannel is stopped before request body data is received\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_stop_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\"\n\t\t\t\"hmok!!!\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\t\tEVENTUALLY(5,\n\t\t\tresult = getNumRequestsWaitingToStartAcceptingBody() == 1;\n\t\t);\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstartAcceptingBody();\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"7 bytes: hmok!!!\"));\n\t}\n\n\tTEST_METHOD(54) {\n\t\tset_test_name(\"req->bodyChannel is stopped before request body EOF is encountered\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_stop_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\");\n\t\tsyscalls::shutdown(fd, SHUT_WR);\n\t\tEVENTUALLY(5,\n\t\t\tresult = getNumRequestsWaitingToStartAcceptingBody() == 1;\n\t\t);\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstartAcceptingBody();\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"0 bytes: \"));\n\t}\n\n\tTEST_METHOD(55) {\n\t\tset_test_name(\"It rejects the upgrade if supportsUpgrade() returns false\");\n\n\t\tserver->allowUpgrades = false;\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 422 Unprocessable Entity\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"Connection upgrading not allowed for this request\"));\n\t}\n\n\tTEST_METHOD(56) {\n\t\tset_test_name(\"It rejects the upgrade if the request contains a request body\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\"\n\t\t\t\"Content-Length: 3\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 400 Bad Request\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Connection upgrading is only allowed for requests without request body\"));\n\t}\n\n\tTEST_METHOD(57) {\n\t\tset_test_name(\"It rejects the upgrade if the request is HEAD\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"HEAD /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: raw\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 400 Bad Request\\r\\n\"));\n\t}\n\n\t/***** Secure headers handling *****/\n\n\tTEST_METHOD(60) {\n\t\tset_test_name(\"It stores secure headers in req->secureHeaders\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /joo HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"!~: x\\r\\n\"\n\t\t\t\"!~Secure: secret\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 25\\r\\n\\r\\n\"\n\t\t\t\"hello /joo\\n\"\n\t\t\t\"Secure: secret\");\n\t}\n\n\tTEST_METHOD(61) {\n\t\tset_test_name(\"It rejects normal headers while in secure mode\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"!~: x\\r\\n\"\n\t\t\t\"!~Secure: secret\\r\\n\"\n\t\t\t\"Foo: bar\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.0 400 Bad Request\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"A normal header was encountered after the security password header\"));\n\t}\n\n\tTEST_METHOD(62) {\n\t\tset_test_name(\"It rejects secure headers while in normal mode\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"!~Secure: secret\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.0 400 Bad Request\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"A secure header was provided, but no security password was provided\"));\n\t}\n\n\tTEST_METHOD(63) {\n\t\tset_test_name(\"If no secure mode password is given in the context, \"\n\t\t\t\"switching to secure mode is always possible\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"!~: anything\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t}\n\n\tTEST_METHOD(64) {\n\t\tset_test_name(\"If a secure mode password is given in the context, \"\n\t\t\t\"it rejects requests that specify the wrong secure mode password\");\n\n\t\tJson::Value config;\n\t\tvector<ConfigKit::Error> errors;\n\t\tconfig[\"secure_mode_password\"] = \"secret\";\n\t\tensure(context.configure(config, errors));\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"!~: wrong\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.0 400 Bad Request\\r\\n\"));\n\t\tensure(\"(2)\", containsSubstring(response,\n\t\t\t\"Security password mismatch\"));\n\t}\n\n\tTEST_METHOD(65) {\n\t\tset_test_name(\"If a secure mode password is given in the context, \"\n\t\t\t\"it accepts requests that specify the correct secure mode password\");\n\n\t\tJson::Value config;\n\t\tvector<ConfigKit::Error> errors;\n\t\tconfig[\"secure_mode_password\"] = \"secret\";\n\t\tensure(context.configure(config, errors));\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"!~: secret\\r\\n\"\n\t\t\t\"!~Foo: bar\\r\\n\"\n\t\t\t\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t}\n\n\n\t/***** Request ending *****/\n\n\tTEST_METHOD(70) {\n\t\tset_test_name(\"If all output data is flushed, and keep-alive is not possible, \"\n\t\t\t\"it disconnects the client immediately\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\treadAll(fd, std::numeric_limits<size_t>::max()); // Does not block\n\t}\n\n\tTEST_METHOD(71) {\n\t\tset_test_name(\"If all output data is flushed, and keep-alive is possible, \"\n\t\t\t\"it handles the next request immediately\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\"\n\t\t\t\"GET /foo HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hello /\"\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 10\\r\\n\\r\\n\"\n\t\t\t\"hello /foo\");\n\t}\n\n\tTEST_METHOD(72) {\n\t\tset_test_name(\"If there is unflushed output data, and keep-alive is not possible, \"\n\t\t\t\"it disconnects the client after all output data is flushed\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /large_response HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"Size: 1000000\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024 * 1024).first;\n\t\tstring body = stripHeaders(response);\n\t\tensure(startsWith(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure_equals(body.size(), 1000000u);\n\t}\n\n\tTEST_METHOD(73) {\n\t\tset_test_name(\"If there is unflushed output data, and keep-alive is possible, \"\n\t\t\t\"it handles the next request after all output data is flushed\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /large_response HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"Size: 1000000\\r\\n\\r\\n\"\n\t\t\t\"GET /foo HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = getTotalRequestsBegun() > 1;\n\t\t);\n\n\t\tstring data = readAll(fd, 1024 * 1024).first;\n\t\tstring response2 =\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 10\\r\\n\\r\\n\"\n\t\t\t\"hello /foo\";\n\n\t\tstring body = stripHeaders(data);\n\t\tensure(startsWith(data, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure_equals(body.size(), 1000000u + response2.size());\n\t\tensure_equals(body.substr(1000000), response2);\n\t}\n\n\tTEST_METHOD(74) {\n\t\tset_test_name(\"If a request with body is ended but output is being flushed, \"\n\t\t\t\"then any received request body data will be discard\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /large_response HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"Size: 1000000\\r\\n\"\n\t\t\t\"Content-Length: 4\\r\\n\\r\\n\");\n\t\tEVENTUALLY(1,\n\t\t\tresult = getTotalRequestsBegun() == 1;\n\t\t);\n\n\t\tunsigned long long previouslyBytesConsumed;\n\t\tpreviouslyBytesConsumed = getTotalBytesConsumed();\n\n\t\twriteExact(fd, \"abcd\");\n\t\tstring response = readAll(fd, 1024 * 1024).first;\n\t\tstring body = stripHeaders(response);\n\t\tensure(startsWith(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure_equals(body.size(), 1000000u);\n\t\tEVENTUALLY(1,\n\t\t\tresult = getTotalBytesConsumed() > previouslyBytesConsumed;\n\t\t);\n\t\tensure_equals(getBodyBytesRead(), 0u);\n\t}\n\n\tTEST_METHOD(75) {\n\t\tset_test_name(\"If a request with body is ended but output is being flushed, \"\n\t\t\t\"then it won't attempt to keep-alive the connection after the output is flushed\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /large_response HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"Size: 1000000\\r\\n\"\n\t\t\t\"Content-Length: 4\\r\\n\\r\\n\");\n\t\tEVENTUALLY(1,\n\t\t\tresult = getTotalRequestsBegun() == 1;\n\t\t);\n\n\t\tunsigned long long previouslyBytesConsumed;\n\t\tpreviouslyBytesConsumed = getTotalBytesConsumed();\n\n\t\twriteExact(fd,\n\t\t\t\"abcd\"\n\t\t\t\"GET /foo HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024 * 1024).first;\n\t\tstring body = stripHeaders(response);\n\t\tensure(startsWith(response, \"HTTP/1.1 200 OK\\r\\n\"));\n\t\tensure_equals(body.size(), 1000000u);\n\t\tEVENTUALLY(1,\n\t\t\tresult = getTotalBytesConsumed() > previouslyBytesConsumed;\n\t\t);\n\t\tensure_equals(getBodyBytesRead(), 0u);\n\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = getTotalRequestsBegun() > 1;\n\t\t);\n\t}\n\n\n\t/***** Early half-close detection *****/\n\n\tTEST_METHOD(80) {\n\t\tset_test_name(\"Detection of half-close after non-empty body fully received\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /half_close_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Content-Length: 2\\r\\n\\r\\n\"\n\t\t\t\"hm\");\n\t\tshutdown(fd, SHUT_WR);\n\t\tEVENTUALLY(5,\n\t\t\tresult = getHalfCloseDetected() == 1;\n\t\t);\n\t}\n\n\tTEST_METHOD(81) {\n\t\tset_test_name(\"Detection of half-close when body is empty\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /half_close_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\\r\\n\");\n\t\tshutdown(fd, SHUT_WR);\n\t\tEVENTUALLY(5,\n\t\t\tresult = getHalfCloseDetected() == 1;\n\t\t);\n\t}\n\n\tTEST_METHOD(82) {\n\t\tset_test_name(\"Detection of half-close after body fully received\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /half_close_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n\t\t\t\"2\\r\\n\"\n\t\t\t\"hm\\r\\n\"\n\t\t\t\"0\\r\\n\\r\\n\");\n\t\tshutdown(fd, SHUT_WR);\n\t\tEVENTUALLY(5,\n\t\t\tresult = getHalfCloseDetected() == 1;\n\t\t);\n\t}\n\n\tTEST_METHOD(83) {\n\t\tset_test_name(\"Normal data is not detected as early half close\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /half_close_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\\r\\n\"\n\t\t\t\"hm\");\n\t\tSHOULD_NEVER_HAPPEN(100,\n\t\t\tresult = getHalfCloseDetected() > 0;\n\t\t);\n\t}\n\n\tTEST_METHOD(84) {\n\t\tset_test_name(\"Request body socket errors that occur after the body\"\n\t\t\t\" is fully received are processed at the next request\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /early_read_error_detection_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\\r\\n\"\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\\r\\n\");\n\t\tEVENTUALLY(5,\n\t\t\tresult = getClientDataErrors() == 1;\n\t\t);\n\t\tensure_equals(getTotalRequestsBegun(), 1u);\n\t}\n\n\n\t/***** Shutdown *****/\n\n\tTEST_METHOD(90) {\n\t\tset_test_name(\"Upon shutting down the server, no requests will be \"\n\t\t\t\"eligible for keep-alive\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Content-Length: 3\\r\\n\\r\\n\");\n\t\tshutdownServer();\n\n\t\tsendRequest(\"ab\\n\"\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"Connection: close\"));\n\t\tensure(\"(2)\", !containsSubstring(response, \"Connection: keep-alive\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"hello /\"));\n\t}\n\n\tTEST_METHOD(91) {\n\t\tset_test_name(\"Upon shutting down the server, requests for which the \"\n\t\t\t\"headers are being parsed are not disconnected\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET / HTTP/1.1\\r\\n\");\n\t\tshutdownServer();\n\t\tEVENTUALLY(100,\n\t\t\tresult = !hasResponseData();\n\t\t);\n\n\t\tsendRequest(\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"Connection: close\"));\n\t\tensure(\"(2)\", !containsSubstring(response, \"Connection: keep-alive\"));\n\t\tensure(\"(3)\", containsSubstring(response, \"hello /\"));\n\t}\n\n\tTEST_METHOD(92) {\n\t\tset_test_name(\"Upon shutting down the server, requests for which the \"\n\t\t\t\"headers are being parsed are disconnected when they've been \"\n\t\t\t\"identified as upgraded requests\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: tcp\\r\\n\");\n\t\tshutdownServer();\n\t\tEVENTUALLY(100,\n\t\t\tresult = !hasResponseData();\n\t\t);\n\n\t\tsendRequest(\"\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"503 Service Unavailable\"));\n\t\tensure(\"(2)\", containsSubstring(response, \"Connection: close\"));\n\t\tensure(\"(3)\", !containsSubstring(response, \"Connection: keep-alive\"));\n\t}\n\n\tTEST_METHOD(93) {\n\t\tset_test_name(\"Upon shutting down the server, normal requests which \"\n\t\t\t\"are being processed are not disconnected\");\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Content-Length: 2\\r\\n\\r\\n\");\n\t\tshutdownServer();\n\t\tEVENTUALLY(100,\n\t\t\tresult = !hasResponseData();\n\t\t);\n\n\t\tsendRequest(\"ab\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure(\"(1)\", containsSubstring(response, \"Connection: close\"));\n\t\tensure(\"(2)\", !containsSubstring(response, \"Connection: keep-alive\"));\n\t\tensure(\"(3)\", containsSubstring(response, \"2 bytes: ab\"));\n\t}\n\n\tTEST_METHOD(94) {\n\t\tset_test_name(\"Upon shutting down the server, upgraded requests which \"\n\t\t\t\"are being processed are disconnected\");\n\n\t\tif (defaultLogLevel == (LoggingKit::Level) DEFAULT_LOG_LEVEL) {\n\t\t\t// If the user did not customize the test's log level,\n\t\t\t// then we'll want to tone down the noise.\n\t\t\tLoggingKit::setLevel(LoggingKit::CRIT);\n\t\t}\n\n\t\tconnectToServer();\n\t\tsendRequestAndWait(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: upgrade\\r\\n\"\n\t\t\t\"Upgrade: tcp\\r\\n\\r\\n\");\n\t\tshutdownServer();\n\t\tEVENTUALLY(5,\n\t\t\tresult = hasResponseData();\n\t\t);\n\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response, \"\");\n\t}\n\n\n\t/***** Miscellaneous *****/\n\n\tTEST_METHOD(100) {\n\t\tset_test_name(\"It responds with the same HTTP version as the request\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.0\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\"\n\t\t\t\"hello /\");\n\t}\n\n\tTEST_METHOD(101) {\n\t\tset_test_name(\"For requests without body, keep-alive is possible\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring header = readResponseHeader();\n\t\tensure(containsSubstring(header, \"Connection: keep-alive\"));\n\t}\n\n\tTEST_METHOD(102) {\n\t\tset_test_name(\"If the request body is fully read, keep-alive is possible\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /body_test HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"Content-Length: 2\\r\\n\\r\\n\"\n\t\t\t\"ok\");\n\t\tstring header = readResponseHeader();\n\t\tensure(containsSubstring(header, \"Connection: keep-alive\"));\n\t}\n\n\tTEST_METHOD(103) {\n\t\tset_test_name(\"If the request body is not fully read, keep-alive is not possible\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: keep-alive\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\"\n\t\t\t\"Content-Length: 2\\r\\n\\r\\n\");\n\t\tstring header = readResponseHeader();\n\t\tensure(containsSubstring(header, \"Connection: close\"));\n\t}\n\n\tTEST_METHOD(104) {\n\t\tset_test_name(\"It defaults to not using keep-alive for HTTP <= 1.0 requests\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.0\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring header = readResponseHeader();\n\t\tensure(containsSubstring(header, \"Connection: close\"));\n\t}\n\n\tTEST_METHOD(105) {\n\t\tset_test_name(\"It defaults to using keep-alive for HTTP >= 1.1 requests\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET / HTTP/1.1\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring header = readResponseHeader();\n\t\tensure(containsSubstring(header, \"Connection: keep-alive\"));\n\t}\n\n\tTEST_METHOD(106) {\n\t\tset_test_name(\"writeSimpleResponse() doesn't output the body for HEAD requests\");\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"HEAD / HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Host: foo\\r\\n\\r\\n\");\n\t\tstring response = readAll(fd, 1024).first;\n\t\tensure_equals(response,\n\t\t\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\"Status: 200 OK\\r\\n\"\n\t\t\t\"Content-Type: text/plain\\r\\n\"\n\t\t\t\"Date: Thu, 11 Sep 2014 12:54:09 GMT\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Content-Length: 7\\r\\n\\r\\n\");\n\t}\n\n\tTEST_METHOD(107) {\n\t\tset_test_name(\"Client socket write error handling\");\n\n\t\tif (defaultLogLevel == (LoggingKit::Level) DEFAULT_LOG_LEVEL) {\n\t\t\t// If the user did not customize the test's log level,\n\t\t\t// then we'll want to tone down the noise.\n\t\t\tLoggingKit::setLevel(LoggingKit::CRIT);\n\t\t}\n\n\t\tconnectToServer();\n\t\tsendRequest(\n\t\t\t\"GET /large_response HTTP/1.1\\r\\n\"\n\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\"Size: 1000000\\r\\n\\r\\n\");\n\t\tfd.close();\n\n\t\tEVENTUALLY(5,\n\t\t\tresult = getActiveClientCount() == 0;\n\t\t);\n\t}\n}", "target": 0}
{"idx": 128, "func": "int32_t Crypto_TC_ProcessSecurity_Cam(uint8_t *ingest, int *len_ingest, TC_t *tc_sdls_processed_frame,\n                                      char *cam_cookies)\n// Loads the ingest frame into the global tc_frame while performing decryption\n{\n    // Local Variables\n    cam_cookies                            = cam_cookies;\n    int32_t                status          = CRYPTO_LIB_SUCCESS;\n    SecurityAssociation_t *sa_ptr          = NULL;\n    uint8_t                sa_service_type = -1;\n    uint8_t               *aad             = NULL;\n    uint16_t               aad_len;\n    uint32_t               encryption_cipher;\n    uint8_t                ecs_is_aead_algorithm = -1;\n    crypto_key_t          *ekp                   = NULL;\n    crypto_key_t          *akp                   = NULL;\n    int byte_idx                                 = 0;\n\n    status = Crypto_TC_Process_Sanity_Check(len_ingest);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n    // Primary Header\n    tc_sdls_processed_frame->tc_header.tfvn   = ((uint8_t)ingest[byte_idx] & 0xC0) >> 6;\n    tc_sdls_processed_frame->tc_header.bypass = ((uint8_t)ingest[byte_idx] & 0x20) >> 5;\n    tc_sdls_processed_frame->tc_header.cc     = ((uint8_t)ingest[byte_idx] & 0x10) >> 4;\n    tc_sdls_processed_frame->tc_header.spare  = ((uint8_t)ingest[byte_idx] & 0x0C) >> 2;\n    tc_sdls_processed_frame->tc_header.scid   = ((uint8_t)ingest[byte_idx] & 0x03) << 8;\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.scid = tc_sdls_processed_frame->tc_header.scid | (uint8_t)ingest[byte_idx];\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.vcid = (((uint8_t)ingest[byte_idx] & 0xFC) >> 2) & crypto_config.vcid_bitmask;\n    tc_sdls_processed_frame->tc_header.fl   = ((uint8_t)ingest[byte_idx] & 0x03) << 8;\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.fl = tc_sdls_processed_frame->tc_header.fl | (uint8_t)ingest[byte_idx];\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.fsn = (uint8_t)ingest[byte_idx];\n    byte_idx++;\n\n    if (*len_ingest < tc_sdls_processed_frame->tc_header.fl + 1) // Specified frame length larger than provided frame!\n    {\n        status = CRYPTO_LIB_ERR_INPUT_FRAME_LENGTH_SHORTER_THAN_FRAME_HEADERS_LENGTH;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Lookup-retrieve managed parameters for frame via gvcid:\n    status = Crypto_Get_Managed_Parameters_For_Gvcid(\n        tc_sdls_processed_frame->tc_header.tfvn, tc_sdls_processed_frame->tc_header.scid,\n        tc_sdls_processed_frame->tc_header.vcid, gvcid_managed_parameters_array, &current_managed_parameters_struct);\n\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    } // Unable to get necessary Managed Parameters for TC TF -- return with error.\n\n    if (*len_ingest < current_managed_parameters_struct.max_frame_size || (tc_sdls_processed_frame->tc_header.fl + 1) < *len_ingest)\n    {\n        status = CRYPTO_LIB_ERR_TC_FRAME_LENGTH_UNDERFLOW;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Segment Header\n    Crypto_TC_Set_Segment_Header(tc_sdls_processed_frame, ingest, &byte_idx);\n\n    // Security Header\n    tc_sdls_processed_frame->tc_sec_header.spi = ((uint8_t)ingest[byte_idx] << 8) | (uint8_t)ingest[byte_idx + 1];\n    byte_idx += 2;\n\n#ifdef TC_DEBUG\n    printf(\"vcid = %d \\n\", tc_sdls_processed_frame->tc_header.vcid);\n    printf(\"spi  = %d \\n\", tc_sdls_processed_frame->tc_sec_header.spi);\n#endif\n\n    status = Crypto_TC_Sanity_Validations(tc_sdls_processed_frame, &sa_ptr);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Allocate the necessary byte arrays within the security header + trailer given the SA\n    tc_sdls_processed_frame->tc_sec_header.iv_field_len  = sa_ptr->iv_len;\n    tc_sdls_processed_frame->tc_sec_header.sn_field_len  = sa_ptr->arsn_len;\n    tc_sdls_processed_frame->tc_sec_header.pad_field_len = sa_ptr->shplf_len;\n\n    tc_sdls_processed_frame->tc_sec_trailer.mac_field_len = sa_ptr->stmacf_len;\n    // Determine SA Service Type\n    Crypto_TC_Get_SA_Service_Type(&sa_service_type, sa_ptr);\n\n    // Determine Algorithm cipher & mode. // TODO - Parse authentication_cipher, and handle AEAD cases properly\n    Crypto_TC_Get_Ciper_Mode_TCP(sa_service_type, &encryption_cipher, &ecs_is_aead_algorithm, sa_ptr);\n\n#ifdef TC_DEBUG\n    switch (sa_service_type)\n    {\n        case SA_PLAINTEXT:\n            printf(KBLU \"Processing a TC - CLEAR!\\n\" RESET);\n            break;\n        case SA_AUTHENTICATION:\n            printf(KBLU \"Processing a TC - AUTHENTICATED!\\n\" RESET);\n            break;\n        case SA_ENCRYPTION:\n            printf(KBLU \"Processing a TC - ENCRYPTED!\\n\" RESET);\n            break;\n        case SA_AUTHENTICATED_ENCRYPTION:\n            printf(KBLU \"Processing a TC - AUTHENTICATED ENCRYPTION!\\n\" RESET);\n            break;\n    }\n#endif\n\n    // TODO: Calculate lengths when needed\n    uint8_t fecf_len        = FECF_SIZE;\n    uint8_t segment_hdr_len = TC_SEGMENT_HDR_SIZE;\n\n    Crypto_TC_Calc_Lengths(&fecf_len, &segment_hdr_len);\n\n    if(tc_sdls_processed_frame->tc_header.fl <= TC_FRAME_HEADER_SIZE - segment_hdr_len - fecf_len + 1)\n    {\n        status = CRYPTO_LIB_ERR_TC_FRAME_LENGTH_UNDERFLOW;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Parse & Check FECF\n    Crypto_TC_Parse_Check_FECF(ingest, len_ingest, tc_sdls_processed_frame);\n\n    // Parse transmitted portion of IV from received frame (Will be Whole IV if iv_len==shivf_len)\n    memcpy((tc_sdls_processed_frame->tc_sec_header.iv + (sa_ptr->iv_len - sa_ptr->shivf_len)),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN]), sa_ptr->shivf_len);\n\n    // Handle non-transmitted IV increment case (transmitted-portion roll-over)\n    status = Crypto_TC_Nontransmitted_IV_Increment(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(\"Full IV Value from Frame and SADB (if applicable):\\n\");\n    Crypto_hexprint(tc_sdls_processed_frame->tc_sec_header.iv, sa_ptr->iv_len);\n#endif\n\n    // Parse transmitted portion of ARSN\n    memcpy((tc_sdls_processed_frame->tc_sec_header.sn + (sa_ptr->arsn_len - sa_ptr->shsnf_len)),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len]), sa_ptr->shsnf_len);\n\n    // Handle non-transmitted SN increment case (transmitted-portion roll-over)\n    status = Crypto_TC_Nontransmitted_SN_Increment(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(\"Full ARSN Value from Frame and SADB (if applicable):\\n\");\n    Crypto_hexprint(tc_sdls_processed_frame->tc_sec_header.sn, sa_ptr->arsn_len);\n#endif\n\n    // Parse pad length\n    memcpy((tc_sdls_processed_frame->tc_sec_header.pad),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len + sa_ptr->shsnf_len]),\n           sa_ptr->shplf_len);\n\n    // Parse MAC, prepare AAD\n    status = Crypto_TC_Prep_AAD(tc_sdls_processed_frame, fecf_len, sa_service_type, ecs_is_aead_algorithm, &aad_len,\n                                sa_ptr, segment_hdr_len, ingest, &aad);\n\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    uint16_t tc_enc_payload_start_index =\n        TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len + sa_ptr->shsnf_len + sa_ptr->shplf_len;\n\n    // Todo -- if encrypt only, ignore stmacf_len entirely to avoid erroring on SA misconfiguration... Or just throw a\n    // warning/error indicating SA misconfiguration?\n    tc_sdls_processed_frame->tc_pdu_len =\n        tc_sdls_processed_frame->tc_header.fl + 1 - tc_enc_payload_start_index - sa_ptr->stmacf_len - fecf_len;\n\n    if (tc_sdls_processed_frame->tc_pdu_len >\n        tc_sdls_processed_frame->tc_header.fl) // invalid header parsed, sizes overflowed & make no sense!\n    {\n        status = CRYPTO_LIB_ERR_INVALID_HEADER;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(KYEL \"TC PDU Calculated Length: %d \\n\" RESET, tc_sdls_processed_frame->tc_pdu_len);\n#endif\n\n    /* Get Key */\n    status = Crypto_TC_Get_Keys(&ekp, &akp, sa_ptr);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    status = Crypto_TC_Do_Decrypt(sa_service_type, ecs_is_aead_algorithm, ekp, sa_ptr, aad, tc_sdls_processed_frame,\n                                  ingest, tc_enc_payload_start_index, aad_len, cam_cookies, akp, segment_hdr_len);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        Crypto_TC_Safe_Free_Ptr(aad);\n        mc_if->mc_log(status);\n        return status; // Cryptography IF call failed, return.\n    }\n\n    // Now that MAC has been verified, check IV & ARSN if applicable\n    status = Crypto_TC_Check_IV_ARSN(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        Crypto_TC_Safe_Free_Ptr(aad);\n        mc_if->mc_log(status);\n        return status; // Cryptography IF call failed, return.\n    }\n    // Extended PDU processing, if applicable\n\n    if (status == CRYPTO_LIB_SUCCESS && crypto_config.process_sdls_pdus == TC_PROCESS_SDLS_PDUS_TRUE)\n    {\n        status = Crypto_Process_Extended_Procedure_Pdu(tc_sdls_processed_frame, ingest);\n    }\n\n    Crypto_TC_Safe_Free_Ptr(aad);\n\n    mc_if->mc_log(status);\n    return status;\n}\n\n/**\n * @brief Function: Crypto_Prepare_TC_AAD\n * Callocs and returns pointer to buffer where AAD is created & bitwise-anded with bitmask!\n * Note: Function caller is responsible for freeing the returned buffer!\n * @param buffer: uint8_t*\n * @param len_aad: uint16_t\n * @param abm_buffer: uint8_t*\n **/", "target": 1}
{"idx": 129, "func": "int32_t Crypto_TC_ProcessSecurity_Cam(uint8_t *ingest, int *len_ingest, TC_t *tc_sdls_processed_frame,\n                                      char *cam_cookies)\n// Loads the ingest frame into the global tc_frame while performing decryption\n{\n    // Local Variables\n    cam_cookies                            = cam_cookies;\n    int32_t                status          = CRYPTO_LIB_SUCCESS;\n    SecurityAssociation_t *sa_ptr          = NULL;\n    uint8_t                sa_service_type = -1;\n    uint8_t               *aad             = NULL;\n    uint16_t               aad_len;\n    uint32_t               encryption_cipher;\n    uint8_t                ecs_is_aead_algorithm = -1;\n    crypto_key_t          *ekp                   = NULL;\n    crypto_key_t          *akp                   = NULL;\n    int byte_idx                                 = 0;\n\n    status = Crypto_TC_Process_Sanity_Check(len_ingest);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n    // Primary Header\n    tc_sdls_processed_frame->tc_header.tfvn   = ((uint8_t)ingest[byte_idx] & 0xC0) >> 6;\n    tc_sdls_processed_frame->tc_header.bypass = ((uint8_t)ingest[byte_idx] & 0x20) >> 5;\n    tc_sdls_processed_frame->tc_header.cc     = ((uint8_t)ingest[byte_idx] & 0x10) >> 4;\n    tc_sdls_processed_frame->tc_header.spare  = ((uint8_t)ingest[byte_idx] & 0x0C) >> 2;\n    tc_sdls_processed_frame->tc_header.scid   = ((uint8_t)ingest[byte_idx] & 0x03) << 8;\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.scid = tc_sdls_processed_frame->tc_header.scid | (uint8_t)ingest[byte_idx];\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.vcid = (((uint8_t)ingest[byte_idx] & 0xFC) >> 2) & crypto_config.vcid_bitmask;\n    tc_sdls_processed_frame->tc_header.fl   = ((uint8_t)ingest[byte_idx] & 0x03) << 8;\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.fl = tc_sdls_processed_frame->tc_header.fl | (uint8_t)ingest[byte_idx];\n    byte_idx++;\n    tc_sdls_processed_frame->tc_header.fsn = (uint8_t)ingest[byte_idx];\n    byte_idx++;\n\n    if (*len_ingest < tc_sdls_processed_frame->tc_header.fl + 1) // Specified frame length larger than provided frame!\n    {\n        status = CRYPTO_LIB_ERR_INPUT_FRAME_LENGTH_SHORTER_THAN_FRAME_HEADERS_LENGTH;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Lookup-retrieve managed parameters for frame via gvcid:\n    status = Crypto_Get_Managed_Parameters_For_Gvcid(\n        tc_sdls_processed_frame->tc_header.tfvn, tc_sdls_processed_frame->tc_header.scid,\n        tc_sdls_processed_frame->tc_header.vcid, gvcid_managed_parameters_array, &current_managed_parameters_struct);\n\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    } // Unable to get necessary Managed Parameters for TC TF -- return with error.\n\n    if ((tc_sdls_processed_frame->tc_header.fl + 1) < *len_ingest)\n    {\n        status = CRYPTO_LIB_ERR_TC_FRAME_LENGTH_UNDERFLOW;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Segment Header\n    Crypto_TC_Set_Segment_Header(tc_sdls_processed_frame, ingest, &byte_idx);\n\n    // Security Header\n    tc_sdls_processed_frame->tc_sec_header.spi = ((uint8_t)ingest[byte_idx] << 8) | (uint8_t)ingest[byte_idx + 1];\n    byte_idx += 2;\n\n#ifdef TC_DEBUG\n    printf(\"vcid = %d \\n\", tc_sdls_processed_frame->tc_header.vcid);\n    printf(\"spi  = %d \\n\", tc_sdls_processed_frame->tc_sec_header.spi);\n#endif\n\n    status = Crypto_TC_Sanity_Validations(tc_sdls_processed_frame, &sa_ptr);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Allocate the necessary byte arrays within the security header + trailer given the SA\n    tc_sdls_processed_frame->tc_sec_header.iv_field_len  = sa_ptr->iv_len;\n    tc_sdls_processed_frame->tc_sec_header.sn_field_len  = sa_ptr->arsn_len;\n    tc_sdls_processed_frame->tc_sec_header.pad_field_len = sa_ptr->shplf_len;\n\n    tc_sdls_processed_frame->tc_sec_trailer.mac_field_len = sa_ptr->stmacf_len;\n    // Determine SA Service Type\n    Crypto_TC_Get_SA_Service_Type(&sa_service_type, sa_ptr);\n\n    // Determine Algorithm cipher & mode. // TODO - Parse authentication_cipher, and handle AEAD cases properly\n    Crypto_TC_Get_Ciper_Mode_TCP(sa_service_type, &encryption_cipher, &ecs_is_aead_algorithm, sa_ptr);\n\n#ifdef TC_DEBUG\n    switch (sa_service_type)\n    {\n        case SA_PLAINTEXT:\n            printf(KBLU \"Processing a TC - CLEAR!\\n\" RESET);\n            break;\n        case SA_AUTHENTICATION:\n            printf(KBLU \"Processing a TC - AUTHENTICATED!\\n\" RESET);\n            break;\n        case SA_ENCRYPTION:\n            printf(KBLU \"Processing a TC - ENCRYPTED!\\n\" RESET);\n            break;\n        case SA_AUTHENTICATED_ENCRYPTION:\n            printf(KBLU \"Processing a TC - AUTHENTICATED ENCRYPTION!\\n\" RESET);\n            break;\n    }\n#endif\n\n    // TODO: Calculate lengths when needed\n    uint8_t fecf_len        = FECF_SIZE;\n    uint8_t segment_hdr_len = TC_SEGMENT_HDR_SIZE;\n\n    Crypto_TC_Calc_Lengths(&fecf_len, &segment_hdr_len);\n\n    if(tc_sdls_processed_frame->tc_header.fl <= TC_FRAME_HEADER_SIZE - segment_hdr_len - fecf_len + 1)\n    {\n        status = CRYPTO_LIB_ERR_TC_FRAME_LENGTH_UNDERFLOW;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    // Parse & Check FECF\n    Crypto_TC_Parse_Check_FECF(ingest, len_ingest, tc_sdls_processed_frame);\n\n    // Parse transmitted portion of IV from received frame (Will be Whole IV if iv_len==shivf_len)\n    memcpy((tc_sdls_processed_frame->tc_sec_header.iv + (sa_ptr->iv_len - sa_ptr->shivf_len)),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN]), sa_ptr->shivf_len);\n\n    // Handle non-transmitted IV increment case (transmitted-portion roll-over)\n    status = Crypto_TC_Nontransmitted_IV_Increment(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(\"Full IV Value from Frame and SADB (if applicable):\\n\");\n    Crypto_hexprint(tc_sdls_processed_frame->tc_sec_header.iv, sa_ptr->iv_len);\n#endif\n\n    // Parse transmitted portion of ARSN\n    memcpy((tc_sdls_processed_frame->tc_sec_header.sn + (sa_ptr->arsn_len - sa_ptr->shsnf_len)),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len]), sa_ptr->shsnf_len);\n\n    // Handle non-transmitted SN increment case (transmitted-portion roll-over)\n    status = Crypto_TC_Nontransmitted_SN_Increment(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(\"Full ARSN Value from Frame and SADB (if applicable):\\n\");\n    Crypto_hexprint(tc_sdls_processed_frame->tc_sec_header.sn, sa_ptr->arsn_len);\n#endif\n\n    // Parse pad length\n    memcpy((tc_sdls_processed_frame->tc_sec_header.pad),\n           &(ingest[TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len + sa_ptr->shsnf_len]),\n           sa_ptr->shplf_len);\n\n    // Parse MAC, prepare AAD\n    status = Crypto_TC_Prep_AAD(tc_sdls_processed_frame, fecf_len, sa_service_type, ecs_is_aead_algorithm, &aad_len,\n                                sa_ptr, segment_hdr_len, ingest, &aad);\n\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    uint16_t tc_enc_payload_start_index =\n        TC_FRAME_HEADER_SIZE + segment_hdr_len + SPI_LEN + sa_ptr->shivf_len + sa_ptr->shsnf_len + sa_ptr->shplf_len;\n\n    // Todo -- if encrypt only, ignore stmacf_len entirely to avoid erroring on SA misconfiguration... Or just throw a\n    // warning/error indicating SA misconfiguration?\n    tc_sdls_processed_frame->tc_pdu_len =\n        tc_sdls_processed_frame->tc_header.fl + 1 - tc_enc_payload_start_index - sa_ptr->stmacf_len - fecf_len;\n\n    if (tc_sdls_processed_frame->tc_pdu_len >\n        tc_sdls_processed_frame->tc_header.fl) // invalid header parsed, sizes overflowed & make no sense!\n    {\n        status = CRYPTO_LIB_ERR_INVALID_HEADER;\n        mc_if->mc_log(status);\n        return status;\n    }\n\n#ifdef DEBUG\n    printf(KYEL \"TC PDU Calculated Length: %d \\n\" RESET, tc_sdls_processed_frame->tc_pdu_len);\n#endif\n\n    /* Get Key */\n    status = Crypto_TC_Get_Keys(&ekp, &akp, sa_ptr);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        mc_if->mc_log(status);\n        return status;\n    }\n\n    status = Crypto_TC_Do_Decrypt(sa_service_type, ecs_is_aead_algorithm, ekp, sa_ptr, aad, tc_sdls_processed_frame,\n                                  ingest, tc_enc_payload_start_index, aad_len, cam_cookies, akp, segment_hdr_len);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        Crypto_TC_Safe_Free_Ptr(aad);\n        mc_if->mc_log(status);\n        return status; // Cryptography IF call failed, return.\n    }\n\n    // Now that MAC has been verified, check IV & ARSN if applicable\n    status = Crypto_TC_Check_IV_ARSN(sa_ptr, tc_sdls_processed_frame);\n    if (status != CRYPTO_LIB_SUCCESS)\n    {\n        Crypto_TC_Safe_Free_Ptr(aad);\n        mc_if->mc_log(status);\n        return status; // Cryptography IF call failed, return.\n    }\n    // Extended PDU processing, if applicable\n\n    if (status == CRYPTO_LIB_SUCCESS && crypto_config.process_sdls_pdus == TC_PROCESS_SDLS_PDUS_TRUE)\n    {\n        status = Crypto_Process_Extended_Procedure_Pdu(tc_sdls_processed_frame, ingest);\n    }\n\n    Crypto_TC_Safe_Free_Ptr(aad);\n\n    mc_if->mc_log(status);\n    return status;\n}\n\n/**\n * @brief Function: Crypto_Prepare_TC_AAD\n * Callocs and returns pointer to buffer where AAD is created & bitwise-anded with bitmask!\n * Note: Function caller is responsible for freeing the returned buffer!\n * @param buffer: uint8_t*\n * @param len_aad: uint16_t\n * @param abm_buffer: uint8_t*\n **/", "target": 0}
{"idx": 130, "func": "UTEST(TC_PROCESS, EXERCISE_ARSN)\n{\n    remove(\"sa_save_file.bin\");\n    uint8_t *ptr_enc_frame = NULL;\n    // Setup & Initialize CryptoLib\n    Crypto_Config_CryptoLib(KEY_TYPE_INTERNAL, MC_TYPE_INTERNAL, SA_TYPE_INMEMORY, CRYPTOGRAPHY_TYPE_LIBGCRYPT,\n                            IV_INTERNAL, CRYPTO_TC_CREATE_FECF_TRUE, TC_PROCESS_SDLS_PDUS_TRUE, TC_HAS_PUS_HDR,\n                            TC_IGNORE_SA_STATE_FALSE, TC_IGNORE_ANTI_REPLAY_FALSE, TC_UNIQUE_SA_PER_MAP_ID_FALSE,\n                            TC_CHECK_FECF_TRUE, 0x3F, SA_INCREMENT_NONTRANSMITTED_IV_TRUE);\n    // Crypto_Config_Add_Gvcid_Managed_Parameter(0, 0x0003, 0, TC_HAS_FECF, TC_HAS_SEGMENT_HDRS, TC_OCF_NA, 1024,\n    // AOS_FHEC_NA, AOS_IZ_NA, 0); Crypto_Config_Add_Gvcid_Managed_Parameter(0, 0x0003, 1, TC_HAS_FECF,\n    // TC_HAS_SEGMENT_HDRS, TC_OCF_NA, 1024, AOS_FHEC_NA, AOS_IZ_NA, 0);\n    GvcidManagedParameters_t TC_UT_Managed_Parameters = {\n        0, 0x0003, 0, TC_HAS_FECF, AOS_FHEC_NA, AOS_IZ_NA, 0, TC_HAS_SEGMENT_HDRS, 44, TC_OCF_NA, 1};\n    Crypto_Config_Add_Gvcid_Managed_Parameters(TC_UT_Managed_Parameters);\n    TC_UT_Managed_Parameters.vcid = 1;\n    Crypto_Config_Add_Gvcid_Managed_Parameters(TC_UT_Managed_Parameters);\n    Crypto_Init();\n    SaInterface   sa_if  = get_sa_interface_inmemory();\n    crypto_key_t *akp    = NULL;\n    int           status = 0;\n\n    // NIST supplied vectors\n    // NOTE: Added Transfer Frame header to the plaintext\n    char *buffer_nist_key_h = \"ef9f9284cf599eac3b119905a7d18851e7e374cf63aea04358586b0f757670f8\";\n    char *buffer_arsn_h     = \"0123\"; // The last valid ARSN that was seen by the SA\n    // For reference:        | Header  |SH SPI SN| Payload                       | MAC                           |FECF\n    char *buffer_replay_h =\n        \"2003002B00FF000901231224DFEFB72A20D49E09256908874979fd56ca1ffc2697a700dbe6292c10e9ef1B49\"; // ARSN is one less\n                                                                                                    // than library\n                                                                                                    // expects\n    char *buffer_outside_window_h =\n        \"2003002B00FF000904441224DFEFB72A20D49E09256908874979fd56ca1ffc2697a700dbe6292c10e9ef9C5C\"; // ARSN is outside\n                                                                                                    // the positive\n                                                                                                    // window\n    char *buffer_good_arsn_h =\n        \"2003002B00FF000901241224DFEFB72A20D49E09256908874979fd56ca1ffc2697a700dbe6292c10e9ef8A3E\"; // ARSN is the next\n                                                                                                    // one expected\n    char *buffer_good_arsn_with_gap_h =\n        \"2003002B00FF000901291224DFEFB72A20D49E09256908874979fd56ca1ffc2697a700dbe6292c10e9ef3EB4\"; // ARSN is valid,\n                                                                                                    // but not next one\n                                                                                                    // expected\n    uint8_t *buffer_replay_b, *buffer_outside_window_b, *buffer_good_arsn_b, *buffer_good_arsn_with_gap_b,\n        *buffer_arsn_b, *buffer_nist_key_b = NULL;\n    int buffer_replay_len, buffer_outside_window_len, buffer_good_arsn_len, buffer_good_arsn_with_gap_len,\n        buffer_arsn_len, buffer_nist_key_len = 0;\n\n    // Setup Processed Frame For Decryption\n    TC_t *tc_nist_processed_frame;\n    tc_nist_processed_frame = malloc(sizeof(uint8_t) * TC_SIZE);\n\n    // Expose/setup SAs for testing\n    SecurityAssociation_t *test_association;\n    // Deactivate SA 1\n    sa_if->sa_get_from_spi(1, &test_association);\n    test_association->sa_state = SA_NONE;\n    // Activate SA 9\n    sa_if->sa_get_from_spi(9, &test_association);\n    test_association->sa_state = SA_OPERATIONAL;\n    sa_if->sa_get_from_spi(9, &test_association);\n    test_association->ecs_len   = 1;\n    test_association->ecs       = CRYPTO_CIPHER_NONE;\n    test_association->acs_len   = 1;\n    test_association->acs       = CRYPTO_MAC_CMAC_AES256;\n    test_association->est       = 0;\n    test_association->ast       = 1;\n    test_association->shivf_len = 0;\n    test_association->iv_len    = 0;\n    test_association->shsnf_len = 2;\n    test_association->arsn_len  = 2;\n    test_association->arsnw     = 5;\n    test_association->abm_len   = 1024;\n    test_association->akid      = 136;\n    test_association->ekid      = 0;\n    // memset(test_association->abm, 0x00, (test_association->abm_len * sizeof(uint8_t)));\n    test_association->stmacf_len = 16;\n    // Insert key into keyring of SA 9\n    hex_conversion(buffer_nist_key_h, (char **)&buffer_nist_key_b, &buffer_nist_key_len);\n    akp = key_if->get_key(test_association->akid);\n    memcpy(akp->value, buffer_nist_key_b, buffer_nist_key_len);\n    akp->key_state = KEY_ACTIVE;\n    // Convert frames that will be processed\n    hex_conversion(buffer_replay_h, (char **)&buffer_replay_b, &buffer_replay_len);\n    hex_conversion(buffer_outside_window_h, (char **)&buffer_outside_window_b, &buffer_outside_window_len);\n    hex_conversion(buffer_good_arsn_h, (char **)&buffer_good_arsn_b, &buffer_good_arsn_len);\n    hex_conversion(buffer_good_arsn_with_gap_h, (char **)&buffer_good_arsn_with_gap_b, &buffer_good_arsn_with_gap_len);\n    // Convert/Set input ARSN\n    hex_conversion(buffer_arsn_h, (char **)&buffer_arsn_b, &buffer_arsn_len);\n    memcpy(test_association->arsn, buffer_arsn_b, buffer_arsn_len);\n    // Expect to fail on replay\n    printf(KGRN \"Checking replay - using previous received ARSN...\\n\" RESET);\n    status = Crypto_TC_ProcessSecurity(buffer_replay_b, &buffer_replay_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_ERR_ARSN_OUTSIDE_WINDOW, status);\n    // Expect to fail on counter being too high\n    printf(KGRN \"Checking replay - using ARSN outside the window...\\n\" RESET);\n    status = Crypto_TC_ProcessSecurity(buffer_outside_window_b, &buffer_outside_window_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_ERR_ARSN_OUTSIDE_WINDOW, status);\n\n    // Expect success on valid ARSN\n    printf(KGRN \"Checking next valid ARSN... should be able to receive it... \\n\" RESET);\n    status = Crypto_TC_ProcessSecurity(buffer_good_arsn_b, &buffer_good_arsn_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_SUCCESS, status);\n\n    // Expect success on valid ARSN within window, but has a gap\n    printf(KGRN \"Checking valid ARSN within window... should be able to receive it... \\n\" RESET);\n    status =\n        Crypto_TC_ProcessSecurity(buffer_good_arsn_with_gap_b, &buffer_good_arsn_with_gap_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_SUCCESS, status);\n\n    // Validate that the SA ARSN is updated to the most recently received ARSN\n    // ARSN length in this testing is 2 bytes\n    printf(KGRN \"Verifying ARSN updated correctly...\\n\" RESET);\n    printf(\"SA ARSN is now:\\t\");\n    for (int i = 0; i < test_association->shsnf_len; i++)\n    {\n        printf(\"%02X\", *(test_association->arsn + i));\n        ASSERT_EQ(*(test_association->arsn + i),\n                  *(buffer_good_arsn_with_gap_b + 8 + i)); // 8 is ARSN offset into packet\n    }\n    printf(\"\\n\");\n    Crypto_Shutdown();\n    free(tc_nist_processed_frame);\n    free(ptr_enc_frame);\n    free(buffer_nist_key_b);\n    free(buffer_replay_b);\n    free(buffer_outside_window_b);\n    free(buffer_good_arsn_b);\n    free(buffer_good_arsn_with_gap_b);\n    free(buffer_arsn_b);\n}", "target": 1}
{"idx": 131, "func": "UTEST(TC_PROCESS, EXERCISE_ARSN)\n{\n    remove(\"sa_save_file.bin\");\n    uint8_t *ptr_enc_frame = NULL;\n    // Setup & Initialize CryptoLib\n    Crypto_Config_CryptoLib(KEY_TYPE_INTERNAL, MC_TYPE_INTERNAL, SA_TYPE_INMEMORY, CRYPTOGRAPHY_TYPE_LIBGCRYPT,\n                            IV_INTERNAL, CRYPTO_TC_CREATE_FECF_TRUE, TC_PROCESS_SDLS_PDUS_TRUE, TC_HAS_PUS_HDR,\n                            TC_IGNORE_SA_STATE_FALSE, TC_IGNORE_ANTI_REPLAY_FALSE, TC_UNIQUE_SA_PER_MAP_ID_FALSE,\n                            TC_CHECK_FECF_TRUE, 0x3F, SA_INCREMENT_NONTRANSMITTED_IV_TRUE);\n    // Crypto_Config_Add_Gvcid_Managed_Parameter(0, 0x0003, 0, TC_HAS_FECF, TC_HAS_SEGMENT_HDRS, TC_OCF_NA, 1024,\n    // AOS_FHEC_NA, AOS_IZ_NA, 0); Crypto_Config_Add_Gvcid_Managed_Parameter(0, 0x0003, 1, TC_HAS_FECF,\n    // TC_HAS_SEGMENT_HDRS, TC_OCF_NA, 1024, AOS_FHEC_NA, AOS_IZ_NA, 0);\n    GvcidManagedParameters_t TC_UT_Managed_Parameters = {\n        0, 0x0003, 0, TC_HAS_FECF, AOS_FHEC_NA, AOS_IZ_NA, 0, TC_HAS_SEGMENT_HDRS, 1024, TC_OCF_NA, 1};\n    Crypto_Config_Add_Gvcid_Managed_Parameters(TC_UT_Managed_Parameters);\n    TC_UT_Managed_Parameters.vcid = 1;\n    Crypto_Config_Add_Gvcid_Managed_Parameters(TC_UT_Managed_Parameters);\n    Crypto_Init();\n    SaInterface   sa_if  = get_sa_interface_inmemory();\n    crypto_key_t *akp    = NULL;\n    int           status = 0;\n\n    // NIST supplied vectors\n    // NOTE: Added Transfer Frame header to the plaintext\n    char *buffer_nist_key_h = \"ef9f9284cf599eac3b119905a7d18851e7e374cf63aea04358586b0f757670f8\";\n    char *buffer_arsn_h     = \"0123\"; // The last valid ARSN that was seen by the SA\n    // For reference:        | Header  |SH SPI SN| Payload                       | MAC                           |FECF\n    char *buffer_replay_h =\n        \"2003002B00FF000901231224DFEFB72A20D49E09256908874979fd56ca1ffc2697a700dbe6292c10e9ef1B49\"; // ARSN is one less\n                                                                                                    // than library\n                                                                                                    // expects\n    char *buffer_outside_window_h =\n        \"2003002B00FF000904441224DFEFB72A20D49E09256908874979fd56ca1ffc2697a700dbe6292c10e9ef9C5C\"; // ARSN is outside\n                                                                                                    // the positive\n                                                                                                    // window\n    char *buffer_good_arsn_h =\n        \"2003002B00FF000901241224DFEFB72A20D49E09256908874979fd56ca1ffc2697a700dbe6292c10e9ef8A3E\"; // ARSN is the next\n                                                                                                    // one expected\n    char *buffer_good_arsn_with_gap_h =\n        \"2003002B00FF000901291224DFEFB72A20D49E09256908874979fd56ca1ffc2697a700dbe6292c10e9ef3EB4\"; // ARSN is valid,\n                                                                                                    // but not next one\n                                                                                                    // expected\n    uint8_t *buffer_replay_b, *buffer_outside_window_b, *buffer_good_arsn_b, *buffer_good_arsn_with_gap_b,\n        *buffer_arsn_b, *buffer_nist_key_b = NULL;\n    int buffer_replay_len, buffer_outside_window_len, buffer_good_arsn_len, buffer_good_arsn_with_gap_len,\n        buffer_arsn_len, buffer_nist_key_len = 0;\n\n    // Setup Processed Frame For Decryption\n    TC_t *tc_nist_processed_frame;\n    tc_nist_processed_frame = malloc(sizeof(uint8_t) * TC_SIZE);\n\n    // Expose/setup SAs for testing\n    SecurityAssociation_t *test_association;\n    // Deactivate SA 1\n    sa_if->sa_get_from_spi(1, &test_association);\n    test_association->sa_state = SA_NONE;\n    // Activate SA 9\n    sa_if->sa_get_from_spi(9, &test_association);\n    test_association->sa_state = SA_OPERATIONAL;\n    sa_if->sa_get_from_spi(9, &test_association);\n    test_association->ecs_len   = 1;\n    test_association->ecs       = CRYPTO_CIPHER_NONE;\n    test_association->acs_len   = 1;\n    test_association->acs       = CRYPTO_MAC_CMAC_AES256;\n    test_association->est       = 0;\n    test_association->ast       = 1;\n    test_association->shivf_len = 0;\n    test_association->iv_len    = 0;\n    test_association->shsnf_len = 2;\n    test_association->arsn_len  = 2;\n    test_association->arsnw     = 5;\n    test_association->abm_len   = 1024;\n    test_association->akid      = 136;\n    test_association->ekid      = 0;\n    // memset(test_association->abm, 0x00, (test_association->abm_len * sizeof(uint8_t)));\n    test_association->stmacf_len = 16;\n    // Insert key into keyring of SA 9\n    hex_conversion(buffer_nist_key_h, (char **)&buffer_nist_key_b, &buffer_nist_key_len);\n    akp = key_if->get_key(test_association->akid);\n    memcpy(akp->value, buffer_nist_key_b, buffer_nist_key_len);\n    akp->key_state = KEY_ACTIVE;\n    // Convert frames that will be processed\n    hex_conversion(buffer_replay_h, (char **)&buffer_replay_b, &buffer_replay_len);\n    hex_conversion(buffer_outside_window_h, (char **)&buffer_outside_window_b, &buffer_outside_window_len);\n    hex_conversion(buffer_good_arsn_h, (char **)&buffer_good_arsn_b, &buffer_good_arsn_len);\n    hex_conversion(buffer_good_arsn_with_gap_h, (char **)&buffer_good_arsn_with_gap_b, &buffer_good_arsn_with_gap_len);\n    // Convert/Set input ARSN\n    hex_conversion(buffer_arsn_h, (char **)&buffer_arsn_b, &buffer_arsn_len);\n    memcpy(test_association->arsn, buffer_arsn_b, buffer_arsn_len);\n    // Expect to fail on replay\n    printf(KGRN \"Checking replay - using previous received ARSN...\\n\" RESET);\n    status = Crypto_TC_ProcessSecurity(buffer_replay_b, &buffer_replay_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_ERR_ARSN_OUTSIDE_WINDOW, status);\n    // Expect to fail on counter being too high\n    printf(KGRN \"Checking replay - using ARSN outside the window...\\n\" RESET);\n    status = Crypto_TC_ProcessSecurity(buffer_outside_window_b, &buffer_outside_window_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_ERR_ARSN_OUTSIDE_WINDOW, status);\n\n    // Expect success on valid ARSN\n    printf(KGRN \"Checking next valid ARSN... should be able to receive it... \\n\" RESET);\n    status = Crypto_TC_ProcessSecurity(buffer_good_arsn_b, &buffer_good_arsn_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_SUCCESS, status);\n\n    // Expect success on valid ARSN within window, but has a gap\n    printf(KGRN \"Checking valid ARSN within window... should be able to receive it... \\n\" RESET);\n    status =\n        Crypto_TC_ProcessSecurity(buffer_good_arsn_with_gap_b, &buffer_good_arsn_with_gap_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_SUCCESS, status);\n\n    // Validate that the SA ARSN is updated to the most recently received ARSN\n    // ARSN length in this testing is 2 bytes\n    printf(KGRN \"Verifying ARSN updated correctly...\\n\" RESET);\n    printf(\"SA ARSN is now:\\t\");\n    for (int i = 0; i < test_association->shsnf_len; i++)\n    {\n        printf(\"%02X\", *(test_association->arsn + i));\n        ASSERT_EQ(*(test_association->arsn + i),\n                  *(buffer_good_arsn_with_gap_b + 8 + i)); // 8 is ARSN offset into packet\n    }\n    printf(\"\\n\");\n    Crypto_Shutdown();\n    free(tc_nist_processed_frame);\n    free(ptr_enc_frame);\n    free(buffer_nist_key_b);\n    free(buffer_replay_b);\n    free(buffer_outside_window_b);\n    free(buffer_good_arsn_b);\n    free(buffer_good_arsn_with_gap_b);\n    free(buffer_arsn_b);\n}", "target": 0}
{"idx": 132, "func": "UTEST(TC_PROCESS, EXERCISE_IV)\n{\n    remove(\"sa_save_file.bin\");\n    uint8_t *ptr_enc_frame = NULL;\n    // Setup & Initialize CryptoLib\n    Crypto_Config_CryptoLib(KEY_TYPE_INTERNAL, MC_TYPE_INTERNAL, SA_TYPE_INMEMORY, CRYPTOGRAPHY_TYPE_LIBGCRYPT,\n                            IV_INTERNAL, CRYPTO_TC_CREATE_FECF_TRUE, TC_PROCESS_SDLS_PDUS_TRUE, TC_HAS_PUS_HDR,\n                            TC_IGNORE_SA_STATE_FALSE, TC_IGNORE_ANTI_REPLAY_FALSE, TC_UNIQUE_SA_PER_MAP_ID_FALSE,\n                            TC_CHECK_FECF_TRUE, 0x3F, SA_INCREMENT_NONTRANSMITTED_IV_TRUE);\n    // Crypto_Config_Add_Gvcid_Managed_Parameter(0, 0x0003, 0, TC_HAS_FECF, TC_HAS_SEGMENT_HDRS, TC_OCF_NA, 1024,\n    // AOS_FHEC_NA, AOS_IZ_NA, 0);\n    GvcidManagedParameters_t TC_UT_Managed_Parameters = {\n        0, 0x0003, 0, TC_HAS_FECF, AOS_FHEC_NA, AOS_IZ_NA, 0, TC_HAS_SEGMENT_HDRS, 38, TC_OCF_NA, 1};\n    Crypto_Config_Add_Gvcid_Managed_Parameters(TC_UT_Managed_Parameters);\n    TC_UT_Managed_Parameters.vcid = 1;\n    Crypto_Config_Add_Gvcid_Managed_Parameters(TC_UT_Managed_Parameters);\n    // Crypto_Config_Add_Gvcid_Managed_Parameter(0, 0x0003, 1, TC_HAS_FECF, TC_HAS_SEGMENT_HDRS, TC_OCF_NA, 1024,\n    // AOS_FHEC_NA, AOS_IZ_NA, 0);\n\n    Crypto_Init();\n    SaInterface   sa_if  = get_sa_interface_inmemory();\n    crypto_key_t *ekp    = NULL;\n    int           status = 0;\n\n    // NIST supplied vectors\n    // NOTE: Added Transfer Frame header to the plaintext\n    char *buffer_nist_key_h = \"ef9f9284cf599eac3b119905a7d18851e7e374cf63aea04358586b0f757670f8\";\n    char *buffer_nist_iv_h  = \"b6ac8e4963f49207ffd6374b\"; // The last valid IV that was seen by the SA\n    char *buffer_replay_h =\n        \"2003002500FF0009B6AC8E4963F49207FFD6374B1224DFEFB72A20D49E09256908874979DFC1\"; // IV is one less than library\n                                                                                        // expects\n    char *buffer_outside_window_h =\n        \"2003002500FF0009B6AC8E4963F49207FFD6375C1224DFEFB72A20D49E09256908874979B36E\"; // IV is outside the positive\n                                                                                        // window\n    char *buffer_good_iv_h =\n        \"2003002500FF0009B6AC8E4963F49207FFD6374C1224DFEFB72A20D49E09256908874979AD6F\"; // IV is the next one expected\n    char *buffer_good_iv_with_gap_h =\n        \"2003002500FF0009B6AC8E4963F49207FFD6374F1224DFEFB72A20D49E092569088749799C49\"; // IV is valid, but not next one\n                                                                                        // expected\n    uint8_t *buffer_replay_b, *buffer_outside_window_b, *buffer_good_iv_b, *buffer_good_iv_with_gap_b,\n        *buffer_nist_iv_b, *buffer_nist_key_b = NULL;\n    int buffer_replay_len, buffer_outside_window_len, buffer_good_iv_len, buffer_good_iv_with_gap_len,\n        buffer_nist_iv_len, buffer_nist_key_len = 0;\n\n    // Setup Processed Frame For Decryption\n    TC_t *tc_nist_processed_frame;\n    tc_nist_processed_frame = malloc(sizeof(uint8_t) * TC_SIZE);\n\n    // Expose/setup SAs for testing\n    SecurityAssociation_t *test_association;\n    // Deactivate SA 1\n    sa_if->sa_get_from_spi(1, &test_association);\n    test_association->sa_state = SA_NONE;\n    // Activate SA 9\n    sa_if->sa_get_from_spi(9, &test_association);\n    test_association->sa_state  = SA_OPERATIONAL;\n    test_association->est       = 1;\n    test_association->ast       = 0;\n    test_association->ekid      = 136;\n    test_association->shivf_len = 12;\n    test_association->iv_len    = 12;\n    test_association->ecs_len   = 1;\n    test_association->shplf_len = 1;\n    test_association->arsnw_len = 1;\n    test_association->arsnw     = 5;\n    test_association->arsn_len  = 0;\n    test_association->shsnf_len = 0;\n    test_association->abm_len   = ABM_SIZE;\n    test_association->ecs       = CRYPTO_CIPHER_AES256_GCM;\n    // Insert key into keyring of SA 9\n    hex_conversion(buffer_nist_key_h, (char **)&buffer_nist_key_b, &buffer_nist_key_len);\n    ekp = key_if->get_key(test_association->ekid);\n    memcpy(ekp->value, buffer_nist_key_b, buffer_nist_key_len);\n    ekp->key_state = KEY_ACTIVE;\n\n    // Convert frames that will be processed\n    hex_conversion(buffer_replay_h, (char **)&buffer_replay_b, &buffer_replay_len);\n    hex_conversion(buffer_outside_window_h, (char **)&buffer_outside_window_b, &buffer_outside_window_len);\n    hex_conversion(buffer_good_iv_h, (char **)&buffer_good_iv_b, &buffer_good_iv_len);\n    hex_conversion(buffer_good_iv_with_gap_h, (char **)&buffer_good_iv_with_gap_b, &buffer_good_iv_with_gap_len);\n    // Convert/Set input IV\n    hex_conversion(buffer_nist_iv_h, (char **)&buffer_nist_iv_b, &buffer_nist_iv_len);\n    memcpy(test_association->iv, buffer_nist_iv_b, buffer_nist_iv_len);\n\n    // Expect to fail on replay\n    printf(KGRN \"Checking replay - using previous received IV...\\n\" RESET);\n    status = Crypto_TC_ProcessSecurity(buffer_replay_b, &buffer_replay_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_ERR_IV_OUTSIDE_WINDOW, status);\n\n    // Expect to fail on counter being too high\n    printf(KGRN \"Checking replay - using IV outside the window...\\n\" RESET);\n    status = Crypto_TC_ProcessSecurity(buffer_outside_window_b, &buffer_outside_window_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_ERR_IV_OUTSIDE_WINDOW, status);\n\n    // Expect success on valid IV\n    printf(KGRN \"Checking valid IV... should be able to receive it... \\n\" RESET);\n    status = Crypto_TC_ProcessSecurity(buffer_good_iv_b, &buffer_good_iv_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_SUCCESS, status);\n\n    // Expect success on valid IV within window, but has a gap\n    printf(KGRN \"Checking valid IV within window... should be able to receive it... \\n\" RESET);\n    status =\n        Crypto_TC_ProcessSecurity(buffer_good_iv_with_gap_b, &buffer_good_iv_with_gap_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_SUCCESS, status);\n\n    // Validate that the SA IV is updated to the most recently received IV\n    // IV length in this testing is 12 bytes\n    printf(KGRN \"Verifying IV updated correctly...\\n\" RESET);\n    printf(\"SA IV is now:\\t\");\n    for (int i = 0; i < test_association->shivf_len; i++)\n    {\n        ASSERT_EQ(*(test_association->iv + i), *(buffer_good_iv_with_gap_b + 8 + i)); // 8 is IV offset into packet\n        printf(\"%02X\", *(test_association->iv + i));\n    }\n    printf(\"\\n\");\n    Crypto_Shutdown();\n    free(buffer_replay_b);\n    free(buffer_outside_window_b);\n    free(buffer_good_iv_b);\n    free(buffer_good_iv_with_gap_b);\n    free(ptr_enc_frame);\n    free(buffer_nist_iv_b);\n    free(buffer_nist_key_b);\n    free(tc_nist_processed_frame);\n}\n\n/**\n * @brief Exercise the ARSN window checking logic using AES CMAC\n * Test Cases: Replay, outside of window\n **/", "target": 1}
{"idx": 133, "func": "UTEST(TC_PROCESS, EXERCISE_IV)\n{\n    remove(\"sa_save_file.bin\");\n    uint8_t *ptr_enc_frame = NULL;\n    // Setup & Initialize CryptoLib\n    Crypto_Config_CryptoLib(KEY_TYPE_INTERNAL, MC_TYPE_INTERNAL, SA_TYPE_INMEMORY, CRYPTOGRAPHY_TYPE_LIBGCRYPT,\n                            IV_INTERNAL, CRYPTO_TC_CREATE_FECF_TRUE, TC_PROCESS_SDLS_PDUS_TRUE, TC_HAS_PUS_HDR,\n                            TC_IGNORE_SA_STATE_FALSE, TC_IGNORE_ANTI_REPLAY_FALSE, TC_UNIQUE_SA_PER_MAP_ID_FALSE,\n                            TC_CHECK_FECF_TRUE, 0x3F, SA_INCREMENT_NONTRANSMITTED_IV_TRUE);\n    // Crypto_Config_Add_Gvcid_Managed_Parameter(0, 0x0003, 0, TC_HAS_FECF, TC_HAS_SEGMENT_HDRS, TC_OCF_NA, 1024,\n    // AOS_FHEC_NA, AOS_IZ_NA, 0);\n    GvcidManagedParameters_t TC_UT_Managed_Parameters = {\n        0, 0x0003, 0, TC_HAS_FECF, AOS_FHEC_NA, AOS_IZ_NA, 0, TC_HAS_SEGMENT_HDRS, 1024, TC_OCF_NA, 1};\n    Crypto_Config_Add_Gvcid_Managed_Parameters(TC_UT_Managed_Parameters);\n    TC_UT_Managed_Parameters.vcid = 1;\n    Crypto_Config_Add_Gvcid_Managed_Parameters(TC_UT_Managed_Parameters);\n    // Crypto_Config_Add_Gvcid_Managed_Parameter(0, 0x0003, 1, TC_HAS_FECF, TC_HAS_SEGMENT_HDRS, TC_OCF_NA, 1024,\n    // AOS_FHEC_NA, AOS_IZ_NA, 0);\n\n    Crypto_Init();\n    SaInterface   sa_if  = get_sa_interface_inmemory();\n    crypto_key_t *ekp    = NULL;\n    int           status = 0;\n\n    // NIST supplied vectors\n    // NOTE: Added Transfer Frame header to the plaintext\n    char *buffer_nist_key_h = \"ef9f9284cf599eac3b119905a7d18851e7e374cf63aea04358586b0f757670f8\";\n    char *buffer_nist_iv_h  = \"b6ac8e4963f49207ffd6374b\"; // The last valid IV that was seen by the SA\n    char *buffer_replay_h =\n        \"2003002500FF0009B6AC8E4963F49207FFD6374B1224DFEFB72A20D49E09256908874979DFC1\"; // IV is one less than library\n                                                                                        // expects\n    char *buffer_outside_window_h =\n        \"2003002500FF0009B6AC8E4963F49207FFD6375C1224DFEFB72A20D49E09256908874979B36E\"; // IV is outside the positive\n                                                                                        // window\n    char *buffer_good_iv_h =\n        \"2003002500FF0009B6AC8E4963F49207FFD6374C1224DFEFB72A20D49E09256908874979AD6F\"; // IV is the next one expected\n    char *buffer_good_iv_with_gap_h =\n        \"2003002500FF0009B6AC8E4963F49207FFD6374F1224DFEFB72A20D49E092569088749799C49\"; // IV is valid, but not next one\n                                                                                        // expected\n    uint8_t *buffer_replay_b, *buffer_outside_window_b, *buffer_good_iv_b, *buffer_good_iv_with_gap_b,\n        *buffer_nist_iv_b, *buffer_nist_key_b = NULL;\n    int buffer_replay_len, buffer_outside_window_len, buffer_good_iv_len, buffer_good_iv_with_gap_len,\n        buffer_nist_iv_len, buffer_nist_key_len = 0;\n\n    // Setup Processed Frame For Decryption\n    TC_t *tc_nist_processed_frame;\n    tc_nist_processed_frame = malloc(sizeof(uint8_t) * TC_SIZE);\n\n    // Expose/setup SAs for testing\n    SecurityAssociation_t *test_association;\n    // Deactivate SA 1\n    sa_if->sa_get_from_spi(1, &test_association);\n    test_association->sa_state = SA_NONE;\n    // Activate SA 9\n    sa_if->sa_get_from_spi(9, &test_association);\n    test_association->sa_state  = SA_OPERATIONAL;\n    test_association->est       = 1;\n    test_association->ast       = 0;\n    test_association->ekid      = 136;\n    test_association->shivf_len = 12;\n    test_association->iv_len    = 12;\n    test_association->ecs_len   = 1;\n    test_association->shplf_len = 1;\n    test_association->arsnw_len = 1;\n    test_association->arsnw     = 5;\n    test_association->arsn_len  = 0;\n    test_association->shsnf_len = 0;\n    test_association->abm_len   = ABM_SIZE;\n    test_association->ecs       = CRYPTO_CIPHER_AES256_GCM;\n    // Insert key into keyring of SA 9\n    hex_conversion(buffer_nist_key_h, (char **)&buffer_nist_key_b, &buffer_nist_key_len);\n    ekp = key_if->get_key(test_association->ekid);\n    memcpy(ekp->value, buffer_nist_key_b, buffer_nist_key_len);\n    ekp->key_state = KEY_ACTIVE;\n\n    // Convert frames that will be processed\n    hex_conversion(buffer_replay_h, (char **)&buffer_replay_b, &buffer_replay_len);\n    hex_conversion(buffer_outside_window_h, (char **)&buffer_outside_window_b, &buffer_outside_window_len);\n    hex_conversion(buffer_good_iv_h, (char **)&buffer_good_iv_b, &buffer_good_iv_len);\n    hex_conversion(buffer_good_iv_with_gap_h, (char **)&buffer_good_iv_with_gap_b, &buffer_good_iv_with_gap_len);\n    // Convert/Set input IV\n    hex_conversion(buffer_nist_iv_h, (char **)&buffer_nist_iv_b, &buffer_nist_iv_len);\n    memcpy(test_association->iv, buffer_nist_iv_b, buffer_nist_iv_len);\n\n    // Expect to fail on replay\n    printf(KGRN \"Checking replay - using previous received IV...\\n\" RESET);\n    status = Crypto_TC_ProcessSecurity(buffer_replay_b, &buffer_replay_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_ERR_IV_OUTSIDE_WINDOW, status);\n\n    // Expect to fail on counter being too high\n    printf(KGRN \"Checking replay - using IV outside the window...\\n\" RESET);\n    status = Crypto_TC_ProcessSecurity(buffer_outside_window_b, &buffer_outside_window_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_ERR_IV_OUTSIDE_WINDOW, status);\n\n    // Expect success on valid IV\n    printf(KGRN \"Checking valid IV... should be able to receive it... \\n\" RESET);\n    status = Crypto_TC_ProcessSecurity(buffer_good_iv_b, &buffer_good_iv_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_SUCCESS, status);\n\n    // Expect success on valid IV within window, but has a gap\n    printf(KGRN \"Checking valid IV within window... should be able to receive it... \\n\" RESET);\n    status =\n        Crypto_TC_ProcessSecurity(buffer_good_iv_with_gap_b, &buffer_good_iv_with_gap_len, tc_nist_processed_frame);\n    ASSERT_EQ(CRYPTO_LIB_SUCCESS, status);\n\n    // Validate that the SA IV is updated to the most recently received IV\n    // IV length in this testing is 12 bytes\n    printf(KGRN \"Verifying IV updated correctly...\\n\" RESET);\n    printf(\"SA IV is now:\\t\");\n    for (int i = 0; i < test_association->shivf_len; i++)\n    {\n        ASSERT_EQ(*(test_association->iv + i), *(buffer_good_iv_with_gap_b + 8 + i)); // 8 is IV offset into packet\n        printf(\"%02X\", *(test_association->iv + i));\n    }\n    printf(\"\\n\");\n    Crypto_Shutdown();\n    free(buffer_replay_b);\n    free(buffer_outside_window_b);\n    free(buffer_good_iv_b);\n    free(buffer_good_iv_with_gap_b);\n    free(ptr_enc_frame);\n    free(buffer_nist_iv_b);\n    free(buffer_nist_key_b);\n    free(tc_nist_processed_frame);\n}\n\n/**\n * @brief Exercise the ARSN window checking logic using AES CMAC\n * Test Cases: Replay, outside of window\n **/", "target": 0}
{"idx": 134, "func": "Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n{\n  Error eofError(heif_error_Invalid_input,\n                 heif_suberror_Invalid_grid_data,\n                 \"Overlay image data incomplete\");\n\n  if (data.size() < 2 + 4 * 2) {\n    return eofError;\n  }\n\n  m_version = data[0];\n  m_flags = data[1];\n\n  if (m_version != 0) {\n    std::stringstream sstr;\n    sstr << \"Overlay image data version \" << ((int) m_version) << \" is not implemented yet\";\n\n    return Error(heif_error_Unsupported_feature,\n                 heif_suberror_Unsupported_data_version,\n                 sstr.str());\n  }\n\n  int field_len = ((m_flags & 1) ? 4 : 2);\n  int ptr = 2;\n\n  if (ptr + 4 * 2 + 2 * field_len + num_images * 2 * field_len > data.size()) {\n    return eofError;\n  }\n\n  for (int i = 0; i < 4; i++) {\n    uint16_t color = static_cast<uint16_t>(readvec(data, ptr, 2));\n    m_background_color[i] = color;\n  }\n\n  m_width = readvec(data, ptr, field_len);\n  m_height = readvec(data, ptr, field_len);\n\n  m_offsets.resize(num_images);\n\n  for (size_t i = 0; i < num_images; i++) {\n    m_offsets[i].x = readvec_signed(data, ptr, field_len);\n    m_offsets[i].y = readvec_signed(data, ptr, field_len);\n  }\n\n  return Error::Ok;\n}", "target": 1}
{"idx": 135, "func": "Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n{\n  Error eofError(heif_error_Invalid_input,\n                 heif_suberror_Invalid_grid_data,\n                 \"Overlay image data incomplete\");\n\n  if (data.size() < 2 + 4 * 2) {\n    return eofError;\n  }\n\n  m_version = data[0];\n  m_flags = data[1];\n\n  if (m_version != 0) {\n    std::stringstream sstr;\n    sstr << \"Overlay image data version \" << ((int) m_version) << \" is not implemented yet\";\n\n    return {heif_error_Unsupported_feature,\n            heif_suberror_Unsupported_data_version,\n            sstr.str()};\n  }\n\n  int field_len = ((m_flags & 1) ? 4 : 2);\n  int ptr = 2;\n\n  if (ptr + 4 * 2 + 2 * field_len + num_images * 2 * field_len > data.size()) {\n    return eofError;\n  }\n\n  for (int i = 0; i < 4; i++) {\n    uint16_t color = static_cast<uint16_t>(readvec(data, ptr, 2));\n    m_background_color[i] = color;\n  }\n\n  m_width = readvec(data, ptr, field_len);\n  m_height = readvec(data, ptr, field_len);\n\n  if (m_width==0 || m_height==0) {\n    return {heif_error_Invalid_input,\n            heif_suberror_Invalid_overlay_data,\n            \"Overlay image with zero width or height.\"};\n  }\n\n  m_offsets.resize(num_images);\n\n  for (size_t i = 0; i < num_images; i++) {\n    m_offsets[i].x = readvec_signed(data, ptr, field_len);\n    m_offsets[i].y = readvec_signed(data, ptr, field_len);\n  }\n\n  return Error::Ok;\n}", "target": 0}
{"idx": 136, "func": "heif_colorspace get_colorspace() const { return m_colorspace; }\n\n  std::set<enum heif_channel> get_channel_set() const;\n\n  uint8_t get_storage_bits_per_pixel(enum heif_channel channel) const;\n\n  uint8_t get_bits_per_pixel(enum heif_channel channel) const;\n\n  uint8_t* get_plane(enum heif_channel channel, int* out_stride);\n\n  const uint8_t* get_plane(enum heif_channel channel, int* out_stride) const;\n\n  void copy_new_plane_from(const std::shared_ptr<const HeifPixelImage>& src_image,\n                           heif_channel src_channel,\n                           heif_channel dst_channel);\n\n  void fill_new_plane(heif_channel dst_channel, uint16_t value, int width, int height, int bpp);\n\n  void transfer_plane_from_image_as(const std::shared_ptr<HeifPixelImage>& source,\n                                    heif_channel src_channel,\n                                    heif_channel dst_channel);\n\n  Error rotate_ccw(int angle_degrees,\n                   std::shared_ptr<HeifPixelImage>& out_img);\n\n  Error mirror_inplace(heif_transform_mirror_direction);\n\n  Error crop(int left, int right, int top, int bottom,\n             std::shared_ptr<HeifPixelImage>& out_img) const;\n\n  Error fill_RGB_16bit(uint16_t r, uint16_t g, uint16_t b, uint16_t a);\n\n  Error overlay(std::shared_ptr<HeifPixelImage>& overlay, int dx, int dy);\n\n  Error scale_nearest_neighbor(std::shared_ptr<HeifPixelImage>& output, int width, int height) const;", "target": 1}
{"idx": 137, "func": "heif_colorspace get_colorspace() const { return m_colorspace; }\n\n  std::set<enum heif_channel> get_channel_set() const;\n\n  uint8_t get_storage_bits_per_pixel(enum heif_channel channel) const;\n\n  uint8_t get_bits_per_pixel(enum heif_channel channel) const;\n\n  uint8_t* get_plane(enum heif_channel channel, int* out_stride);\n\n  const uint8_t* get_plane(enum heif_channel channel, int* out_stride) const;\n\n  void copy_new_plane_from(const std::shared_ptr<const HeifPixelImage>& src_image,\n                           heif_channel src_channel,\n                           heif_channel dst_channel);\n\n  void fill_new_plane(heif_channel dst_channel, uint16_t value, int width, int height, int bpp);\n\n  void transfer_plane_from_image_as(const std::shared_ptr<HeifPixelImage>& source,\n                                    heif_channel src_channel,\n                                    heif_channel dst_channel);\n\n  Error rotate_ccw(int angle_degrees,\n                   std::shared_ptr<HeifPixelImage>& out_img);\n\n  Error mirror_inplace(heif_transform_mirror_direction);\n\n  Error crop(int left, int right, int top, int bottom,\n             std::shared_ptr<HeifPixelImage>& out_img) const;\n\n  Error fill_RGB_16bit(uint16_t r, uint16_t g, uint16_t b, uint16_t a);\n\n  Error overlay(std::shared_ptr<HeifPixelImage>& overlay, int32_t dx, int32_t dy);\n\n  Error scale_nearest_neighbor(std::shared_ptr<HeifPixelImage>& output, int width, int height) const;", "target": 0}
{"idx": 138, "func": "void ASEImporter::BuildUniqueRepresentation(ASE::Mesh &mesh) {\n    // allocate output storage\n    std::vector<aiVector3D> mPositions;\n    std::vector<aiVector3D> amTexCoords[AI_MAX_NUMBER_OF_TEXTURECOORDS];\n    std::vector<aiColor4D> mVertexColors;\n    std::vector<aiVector3D> mNormals;\n    std::vector<BoneVertex> mBoneVertices;\n\n    unsigned int iSize = (unsigned int)mesh.mFaces.size() * 3;\n    mPositions.resize(iSize);\n\n    // optional texture coordinates\n    for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i) {\n        if (!mesh.amTexCoords[i].empty()) {\n            amTexCoords[i].resize(iSize);\n        }\n    }\n    // optional vertex colors\n    if (!mesh.mVertexColors.empty()) {\n        mVertexColors.resize(iSize);\n    }\n\n    // optional vertex normals (vertex normals can simply be copied)\n    if (!mesh.mNormals.empty()) {\n        mNormals.resize(iSize);\n    }\n    // bone vertices. There is no need to change the bone list\n    if (!mesh.mBoneVertices.empty()) {\n        mBoneVertices.resize(iSize);\n    }\n\n    // iterate through all faces in the mesh\n    unsigned int iCurrent = 0, fi = 0;\n    for (std::vector<ASE::Face>::iterator i = mesh.mFaces.begin(); i != mesh.mFaces.end(); ++i, ++fi) {\n        for (unsigned int n = 0; n < 3; ++n, ++iCurrent) {\n            mPositions[iCurrent] = mesh.mPositions[(*i).mIndices[n]];\n\n            // add texture coordinates\n            for (unsigned int c = 0; c < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++c) {\n                if (mesh.amTexCoords[c].empty()) break;\n                amTexCoords[c][iCurrent] = mesh.amTexCoords[c][(*i).amUVIndices[c][n]];\n            }\n            // add vertex colors\n            if (!mesh.mVertexColors.empty()) {\n                mVertexColors[iCurrent] = mesh.mVertexColors[(*i).mColorIndices[n]];\n            }\n            // add normal vectors\n            if (!mesh.mNormals.empty()) {\n                mNormals[iCurrent] = mesh.mNormals[fi * 3 + n];\n                mNormals[iCurrent].Normalize();\n            }\n\n            // handle bone vertices\n            if ((*i).mIndices[n] < mesh.mBoneVertices.size()) {\n                // (sometimes this will cause bone verts to be duplicated\n                //  however, I' quite sure Schrompf' JoinVerticesStep\n                //  will fix that again ...)\n                mBoneVertices[iCurrent] = mesh.mBoneVertices[(*i).mIndices[n]];\n            }\n            (*i).mIndices[n] = iCurrent;\n        }\n    }\n\n    // replace the old arrays\n    mesh.mNormals = mNormals;\n    mesh.mPositions = mPositions;\n    mesh.mVertexColors = mVertexColors;\n\n    for (unsigned int c = 0; c < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++c)\n        mesh.amTexCoords[c] = amTexCoords[c];\n}\n\n// ------------------------------------------------------------------------------------------------\n// Copy a texture from the ASE structs to the output material", "target": 1}
{"idx": 139, "func": "void ASEImporter::BuildUniqueRepresentation(ASE::Mesh &mesh) {\n    // allocate output storage\n    std::vector<aiVector3D> mPositions;\n    std::vector<aiVector3D> amTexCoords[AI_MAX_NUMBER_OF_TEXTURECOORDS];\n    std::vector<aiColor4D> mVertexColors;\n    std::vector<aiVector3D> mNormals;\n    std::vector<BoneVertex> mBoneVertices;\n\n    unsigned int iSize = (unsigned int)mesh.mFaces.size() * 3;\n    mPositions.resize(iSize);\n\n    // optional texture coordinates\n    for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i) {\n        if (!mesh.amTexCoords[i].empty()) {\n            amTexCoords[i].resize(iSize);\n        }\n    }\n    // optional vertex colors\n    if (!mesh.mVertexColors.empty()) {\n        mVertexColors.resize(iSize);\n    }\n\n    // optional vertex normals (vertex normals can simply be copied)\n    if (!mesh.mNormals.empty()) {\n        mNormals.resize(iSize);\n    }\n    // bone vertices. There is no need to change the bone list\n    if (!mesh.mBoneVertices.empty()) {\n        mBoneVertices.resize(iSize);\n    }\n\n    // iterate through all faces in the mesh\n    unsigned int iCurrent = 0, fi = 0;\n    for (std::vector<ASE::Face>::iterator i = mesh.mFaces.begin(); i != mesh.mFaces.end(); ++i, ++fi) {\n        for (unsigned int n = 0; n < 3; ++n, ++iCurrent) {\n            const uint32_t curIndex = (*i).mIndices[n];\n            if (curIndex >= mesh.mPositions.size()) {\n                throw DeadlyImportError(\"ASE: Invalid vertex index in face \", fi, \".\");\n            }\n            mPositions[iCurrent] = mesh.mPositions[(*i).mIndices[n]];\n\n            // add texture coordinates\n            for (unsigned int c = 0; c < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++c) {\n                if (mesh.amTexCoords[c].empty()) break;\n                amTexCoords[c][iCurrent] = mesh.amTexCoords[c][(*i).amUVIndices[c][n]];\n            }\n            // add vertex colors\n            if (!mesh.mVertexColors.empty()) {\n                mVertexColors[iCurrent] = mesh.mVertexColors[(*i).mColorIndices[n]];\n            }\n            // add normal vectors\n            if (!mesh.mNormals.empty()) {\n                mNormals[iCurrent] = mesh.mNormals[fi * 3 + n];\n                mNormals[iCurrent].Normalize();\n            }\n\n            // handle bone vertices\n            if ((*i).mIndices[n] < mesh.mBoneVertices.size()) {\n                // (sometimes this will cause bone verts to be duplicated\n                //  however, I' quite sure Schrompf' JoinVerticesStep\n                //  will fix that again ...)\n                mBoneVertices[iCurrent] = mesh.mBoneVertices[(*i).mIndices[n]];\n            }\n            (*i).mIndices[n] = iCurrent;\n        }\n    }\n\n    // replace the old arrays\n    mesh.mNormals = mNormals;\n    mesh.mPositions = mPositions;\n    mesh.mVertexColors = mVertexColors;\n\n    for (unsigned int c = 0; c < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++c)\n        mesh.amTexCoords[c] = amTexCoords[c];\n}\n\n// ------------------------------------------------------------------------------------------------\n// Copy a texture from the ASE structs to the output material", "target": 0}
{"idx": 140, "func": "static inline bool RegionsIntersect(const StreamingBufferConfig *cfg,\n        const StreamingBufferRegion *r, const uint64_t offset, const uint64_t re)\n{\n    /* create the data range for the region, adding the max gap */\n    const uint64_t reg_o =\n            r->stream_offset > cfg->region_gap ? (r->stream_offset - cfg->region_gap) : 0;\n    const uint64_t reg_re = r->stream_offset + r->buf_size + cfg->region_gap;\n    SCLogDebug(\"r %p: %\" PRIu64 \"/%\" PRIu64 \" - adjusted %\" PRIu64 \"/%\" PRIu64, r, r->stream_offset,\n            r->stream_offset + r->buf_size, reg_o, reg_re);\n    /* check if data range intersects with region range */\n    if (offset >= reg_o && offset <= reg_re) {\n        SCLogDebug(\"r %p is in-scope\", r);\n        return true;\n    }\n    if (re >= reg_o && re <= reg_re) {\n        SCLogDebug(\"r %p is in-scope: %\" PRIu64 \" >= %\" PRIu64 \" && %\" PRIu64 \" <= %\" PRIu64, r, re,\n                reg_o, re, reg_re);\n        return true;\n    }\n    SCLogDebug(\"r %p is out of scope: %\" PRIu64 \"/%\" PRIu64, r, offset, re);\n    return false;\n}\n\n/** \\internal\n *  \\brief find the first region for merging.\n */", "target": 1}
{"idx": 141, "func": "static inline bool RegionsIntersect(const StreamingBufferConfig *cfg,\n        const StreamingBufferRegion *r, const uint64_t offset, const uint64_t re)\n{\n    /* create the data range for the region, adding the max gap */\n    const uint64_t reg_o =\n            r->stream_offset > cfg->region_gap ? (r->stream_offset - cfg->region_gap) : 0;\n    const uint64_t reg_re = r->stream_offset + r->buf_size + cfg->region_gap;\n    SCLogDebug(\"r %p: %\" PRIu64 \"/%\" PRIu64 \" - adjusted %\" PRIu64 \"/%\" PRIu64, r, r->stream_offset,\n            r->stream_offset + r->buf_size, reg_o, reg_re);\n    /* check if data range intersects with region range */\n    /* [offset:re] and [reg_o:reg_re] do not intersect if and only if\n     * re < reg_o or if reg_re < offset (one segment is strictly before the other)\n     * trusting that offset<=re and reg_o<=reg_re\n     */\n    if (re < reg_o || reg_re < offset) {\n        return false;\n    }\n    return true;\n}\n\n/** \\internal\n *  \\brief find the first region for merging.\n */", "target": 0}
{"idx": 142, "func": "static VALUE json_string_unescape(JSON_ParserState *state, const char *string, const char *stringEnd, bool is_name, bool intern, bool symbolize)\n{\n    size_t bufferSize = stringEnd - string;\n    const char *p = string, *pe = string, *unescape, *bufferStart;\n    char *buffer;\n    int unescape_len;\n    char buf[4];\n\n    if (is_name && state->in_array) {\n        VALUE cached_key;\n        if (RB_UNLIKELY(symbolize)) {\n            cached_key = rsymbol_cache_fetch(&state->name_cache, string, bufferSize);\n        } else {\n            cached_key = rstring_cache_fetch(&state->name_cache, string, bufferSize);\n        }\n\n        if (RB_LIKELY(cached_key)) {\n            return cached_key;\n        }\n    }\n\n    VALUE result = rb_str_buf_new(bufferSize);\n    rb_enc_associate_index(result, utf8_encindex);\n    buffer = RSTRING_PTR(result);\n    bufferStart = buffer;\n\n    while ((pe = memchr(pe, '\\\\', stringEnd - pe))) {\n        unescape = (char *) \"?\";\n        unescape_len = 1;\n        if (pe > p) {\n          MEMCPY(buffer, p, char, pe - p);\n          buffer += pe - p;\n        }\n        switch (*++pe) {\n            case 'n':\n                unescape = (char *) \"\\n\";\n                break;\n            case 'r':\n                unescape = (char *) \"\\r\";\n                break;\n            case 't':\n                unescape = (char *) \"\\t\";\n                break;\n            case '\"':\n                unescape = (char *) \"\\\"\";\n                break;\n            case '\\\\':\n                unescape = (char *) \"\\\\\";\n                break;\n            case 'b':\n                unescape = (char *) \"\\b\";\n                break;\n            case 'f':\n                unescape = (char *) \"\\f\";\n                break;\n            case 'u':\n                if (pe > stringEnd - 5) {\n                  raise_parse_error(\"incomplete unicode character escape sequence at '%s'\", p);\n                } else {\n                    uint32_t ch = unescape_unicode((unsigned char *) ++pe);\n                    pe += 3;\n                    /* To handle values above U+FFFF, we take a sequence of\n                     * \\uXXXX escapes in the U+D800..U+DBFF then\n                     * U+DC00..U+DFFF ranges, take the low 10 bits from each\n                     * to make a 20-bit number, then add 0x10000 to get the\n                     * final codepoint.\n                     *\n                     * See Unicode 15: 3.8 \"Surrogates\", 5.3 \"Handling\n                     * Surrogate Pairs in UTF-16\", and 23.6 \"Surrogates\n                     * Area\".\n                     */\n                    if ((ch & 0xFC00) == 0xD800) {\n                        pe++;\n                        if (pe > stringEnd - 6) {\n                          raise_parse_error(\"incomplete surrogate pair at '%s'\", p);\n                        }\n                        if (pe[0] == '\\\\' && pe[1] == 'u') {\n                            uint32_t sur = unescape_unicode((unsigned char *) pe + 2);\n                            ch = (((ch & 0x3F) << 10) | ((((ch >> 6) & 0xF) + 1) << 16)\n                                    | (sur & 0x3FF));\n                            pe += 5;\n                        } else {\n                            unescape = (char *) \"?\";\n                            break;\n                        }\n                    }\n                    unescape_len = convert_UTF32_to_UTF8(buf, ch);\n                    unescape = buf;\n                }\n                break;\n            default:\n                p = pe;\n                continue;\n        }\n        MEMCPY(buffer, unescape, char, unescape_len);\n        buffer += unescape_len;\n        p = ++pe;\n    }\n\n    if (stringEnd > p) {\n      MEMCPY(buffer, p, char, stringEnd - p);\n      buffer += stringEnd - p;\n    }\n    rb_str_set_len(result, buffer - bufferStart);\n\n    if (symbolize) {\n        result = rb_str_intern(result);\n    } else if (intern) {\n        result = rb_funcall(rb_str_freeze(result), i_uminus, 0);\n    }\n\n    return result;\n}\n\n#define MAX_FAST_INTEGER_SIZE 18", "target": 1}
{"idx": 143, "func": "static VALUE json_string_unescape(JSON_ParserState *state, const char *string, const char *stringEnd, bool is_name, bool intern, bool symbolize)\n{\n    size_t bufferSize = stringEnd - string;\n    const char *p = string, *pe = string, *unescape, *bufferStart;\n    char *buffer;\n    int unescape_len;\n    char buf[4];\n\n    if (is_name && state->in_array) {\n        VALUE cached_key;\n        if (RB_UNLIKELY(symbolize)) {\n            cached_key = rsymbol_cache_fetch(&state->name_cache, string, bufferSize);\n        } else {\n            cached_key = rstring_cache_fetch(&state->name_cache, string, bufferSize);\n        }\n\n        if (RB_LIKELY(cached_key)) {\n            return cached_key;\n        }\n    }\n\n    VALUE result = rb_str_buf_new(bufferSize);\n    rb_enc_associate_index(result, utf8_encindex);\n    buffer = RSTRING_PTR(result);\n    bufferStart = buffer;\n\n    while (pe < stringEnd && (pe = memchr(pe, '\\\\', stringEnd - pe))) {\n        unescape = (char *) \"?\";\n        unescape_len = 1;\n        if (pe > p) {\n          MEMCPY(buffer, p, char, pe - p);\n          buffer += pe - p;\n        }\n        switch (*++pe) {\n            case 'n':\n                unescape = (char *) \"\\n\";\n                break;\n            case 'r':\n                unescape = (char *) \"\\r\";\n                break;\n            case 't':\n                unescape = (char *) \"\\t\";\n                break;\n            case '\"':\n                unescape = (char *) \"\\\"\";\n                break;\n            case '\\\\':\n                unescape = (char *) \"\\\\\";\n                break;\n            case 'b':\n                unescape = (char *) \"\\b\";\n                break;\n            case 'f':\n                unescape = (char *) \"\\f\";\n                break;\n            case 'u':\n                if (pe > stringEnd - 5) {\n                  raise_parse_error(\"incomplete unicode character escape sequence at '%s'\", p);\n                } else {\n                    uint32_t ch = unescape_unicode((unsigned char *) ++pe);\n                    pe += 3;\n                    /* To handle values above U+FFFF, we take a sequence of\n                     * \\uXXXX escapes in the U+D800..U+DBFF then\n                     * U+DC00..U+DFFF ranges, take the low 10 bits from each\n                     * to make a 20-bit number, then add 0x10000 to get the\n                     * final codepoint.\n                     *\n                     * See Unicode 15: 3.8 \"Surrogates\", 5.3 \"Handling\n                     * Surrogate Pairs in UTF-16\", and 23.6 \"Surrogates\n                     * Area\".\n                     */\n                    if ((ch & 0xFC00) == 0xD800) {\n                        pe++;\n                        if (pe > stringEnd - 6) {\n                          raise_parse_error(\"incomplete surrogate pair at '%s'\", p);\n                        }\n                        if (pe[0] == '\\\\' && pe[1] == 'u') {\n                            uint32_t sur = unescape_unicode((unsigned char *) pe + 2);\n                            ch = (((ch & 0x3F) << 10) | ((((ch >> 6) & 0xF) + 1) << 16)\n                                    | (sur & 0x3FF));\n                            pe += 5;\n                        } else {\n                            unescape = (char *) \"?\";\n                            break;\n                        }\n                    }\n                    unescape_len = convert_UTF32_to_UTF8(buf, ch);\n                    unescape = buf;\n                }\n                break;\n            default:\n                p = pe;\n                continue;\n        }\n        MEMCPY(buffer, unescape, char, unescape_len);\n        buffer += unescape_len;\n        p = ++pe;\n    }\n\n    if (stringEnd > p) {\n      MEMCPY(buffer, p, char, stringEnd - p);\n      buffer += stringEnd - p;\n    }\n    rb_str_set_len(result, buffer - bufferStart);\n\n    if (symbolize) {\n        result = rb_str_intern(result);\n    } else if (intern) {\n        result = rb_funcall(rb_str_freeze(result), i_uminus, 0);\n    }\n\n    return result;\n}\n\n#define MAX_FAST_INTEGER_SIZE 18", "target": 0}
{"idx": 144, "func": "int LibRaw::phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, sum;\n#if 0\n  int val[4], dev[4], max;\n#endif\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {\n      {-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n      {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n  std::vector<unsigned> badCols;\n\n  if (!meta_length)\n    return 0;\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n  try\n  {\n    while (entries--)\n    {\n      checkCancel();\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n#if 1\n\t  if (ifp->eof())\n\t  {\n\t\t  // skip bad or unknown tag\n\t\t  fseek(ifp, save, SEEK_SET);\n\t\t  continue;\n\t  }\n#endif\n      if (tag == 0x0400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n#if 0\n            // Original code by Dave Coffin - it works better by\n            // not employing special logic for G1 channel below.\n            // Alternatively this column remap (including G1 channel\n            // logic) should be called prior to black subtraction\n            // unlike other corrections\n            for (row = 0; row < raw_height; row++)\n            {\n              if (FC(row - top_margin, col - left_margin)==1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = p1raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += p1raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) =\n                  0.5 + sum * 0.0732233 +\n                  (p1raw(row, col - 2) + p1raw(row, col + 2)) * 0.3535534;\n              }\n            }\n#else\n            // accumulae bad columns to be sorted later\n            badCols.push_back(col);\n#endif\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            unsigned count = 0;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += p1rawc(row + dir[i][0], col + dir[i][1], count);\n            if (count)\n              RAW(row, col) = (sum + (count >> 1)) / count;\n          }\n        }\n      }\n      else if (tag == 0x0419)\n      { /* Polynomial curve - output calibraion */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x041a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x0401)\n      { /* All-color flat fields - luma calibration*/\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x0416 || tag == 0x0410)\n      {\n        // 0x410 - luma calibration\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x040b)\n      { /* Red+blue flat field - croma calibration */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x0412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x041f && !qlin_applied)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n\t\tbool baddiv = false;\n        for (qr = 0; qr < 2; qr++)\n\t\t\tfor (qc = 0; qc < 2; qc++)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\t\tlc[qr][qc][i] = get4();\n\t\t\t\tif (lc[qr][qc][15] == 0)\n\t\t\t\t\tbaddiv = true;\n\t\t\t}\n\t\tif(baddiv)\n\t\t\tcontinue;\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x041e && !qmult_applied)\n      { /* Quadrant multipliers - output calibraion */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= (unsigned)ph1.split_row][col >= (unsigned)ph1.split_col] *\n                RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x0431 && !qmult_applied)\n      { /* Quadrant combined - four tile gain calibration */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (!badCols.empty())\n    {\n      qsort(badCols.data(), badCols.size(), sizeof(unsigned), unsigned_cmp);\n      bool prevIsolated = true;\n      for (i = 0; i < (int)badCols.size(); ++i)\n      {\n        bool nextIsolated = i == ((int)(badCols.size()-1)) || badCols[i+1]>badCols[i]+4;\n        for (row = 0; row < raw_height; ++row)\n          if (prevIsolated && nextIsolated)\n            phase_one_fix_pixel_grad(row,badCols[i]);\n          else\n            phase_one_fix_col_pixel_avg(row,badCols[i]);\n        prevIsolated = nextIsolated;\n      }\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n\t  unsigned w0 = head[1] * head[3], w1 = head[2] * head[4];\n\t  if (w0 > 10240000 || w1 > 10240000)\n\t\t  throw LIBRAW_EXCEPTION_ALLOC;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n        checkCancel();\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n\t\t\tif (j == 0 || j == head[1] || k < 1 || k >= w0+w1)\n\t\t\t\tfrac = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint xdiv = (xval[0][k] - xval[0][k - 1]);\n\t\t\t\tfrac = xdiv ? (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]) : 0;\n\t\t\t}\n\t\t\tif (k < w0 + w1)\n\t\t\t\tmult[i - cip] = yval[0][k > 0 ? k - 1 : 0] * frac + yval[0][k] * (1 - frac);\n\t\t\telse\n\t\t\t\tmult[i - cip] = 0;\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n  return 0;\n}", "target": 1}
{"idx": 145, "func": "int LibRaw::phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, sum;\n#if 0\n  int val[4], dev[4], max;\n#endif\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {\n      {-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n      {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n  std::vector<unsigned> badCols;\n\n  if (!meta_length)\n    return 0;\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n  try\n  {\n    while (entries--)\n    {\n      checkCancel();\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n#if 1\n\t  if (ifp->eof())\n\t  {\n\t\t  // skip bad or unknown tag\n\t\t  fseek(ifp, save, SEEK_SET);\n\t\t  continue;\n\t  }\n#endif\n      if (tag == 0x0400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n#if 0\n            // Original code by Dave Coffin - it works better by\n            // not employing special logic for G1 channel below.\n            // Alternatively this column remap (including G1 channel\n            // logic) should be called prior to black subtraction\n            // unlike other corrections\n            for (row = 0; row < raw_height; row++)\n            {\n              if (FC(row - top_margin, col - left_margin)==1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = p1raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += p1raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) =\n                  0.5 + sum * 0.0732233 +\n                  (p1raw(row, col - 2) + p1raw(row, col + 2)) * 0.3535534;\n              }\n            }\n#else\n            // accumulae bad columns to be sorted later\n            badCols.push_back(col);\n#endif\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            unsigned count = 0;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += p1rawc(row + dir[i][0], col + dir[i][1], count);\n            if (count)\n              RAW(row, col) = (sum + (count >> 1)) / count;\n          }\n        }\n      }\n      else if (tag == 0x0419)\n      { /* Polynomial curve - output calibraion */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x041a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x0401)\n      { /* All-color flat fields - luma calibration*/\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x0416 || tag == 0x0410)\n      {\n        // 0x410 - luma calibration\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x040b)\n      { /* Red+blue flat field - croma calibration */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x0412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x041f && !qlin_applied && ph1.split_col > 0 && ph1.split_col < raw_width\n\t\t&& ph1.split_row > 0 && ph1.split_row < raw_height)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n\t\tbool baddiv = false;\n        for (qr = 0; qr < 2; qr++)\n\t\t\tfor (qc = 0; qc < 2; qc++)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\t\tlc[qr][qc][i] = get4();\n\t\t\t\tif (lc[qr][qc][15] == 0)\n\t\t\t\t\tbaddiv = true;\n\t\t\t}\n\t\tif(baddiv)\n\t\t\tcontinue;\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x041e && !qmult_applied)\n      { /* Quadrant multipliers - output calibraion */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n        for (row = 0; row < raw_height; row++)\n        {\n          checkCancel();\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= (unsigned)ph1.split_row][col >= (unsigned)ph1.split_col] *\n                RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x0431 && !qmult_applied && ph1.split_col > 0 && ph1.split_col < raw_width \n\t\t&& ph1.split_row > 0 && ph1.split_row < raw_height)\n      { /* Quadrant combined - four tile gain calibration */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0);\n                 row < unsigned(qr ? raw_height : ph1.split_row); row++)\n            {\n              checkCancel();\n              for (col = (qc ? ph1.split_col : 0);\n                   col < unsigned(qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (!badCols.empty())\n    {\n      qsort(badCols.data(), badCols.size(), sizeof(unsigned), unsigned_cmp);\n      bool prevIsolated = true;\n      for (i = 0; i < (int)badCols.size(); ++i)\n      {\n        bool nextIsolated = i == ((int)(badCols.size()-1)) || badCols[i+1]>badCols[i]+4;\n        for (row = 0; row < raw_height; ++row)\n          if (prevIsolated && nextIsolated)\n            phase_one_fix_pixel_grad(row,badCols[i]);\n          else\n            phase_one_fix_col_pixel_avg(row,badCols[i]);\n        prevIsolated = nextIsolated;\n      }\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n\t  unsigned w0 = head[1] * head[3], w1 = head[2] * head[4];\n\t  if (w0 > 10240000 || w1 > 10240000)\n\t\t  throw LIBRAW_EXCEPTION_ALLOC;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n        checkCancel();\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n\t\t\tif (j == 0 || j == head[1] || k < 1 || k >= w0+w1)\n\t\t\t\tfrac = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint xdiv = (xval[0][k] - xval[0][k - 1]);\n\t\t\t\tfrac = xdiv ? (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]) : 0;\n\t\t\t}\n\t\t\tif (k < w0 + w1)\n\t\t\t\tmult[i - cip] = yval[0][k > 0 ? k - 1 : 0] * frac + yval[0][k] * (1 - frac);\n\t\t\telse\n\t\t\t\tmult[i - cip] = 0;\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n  return 0;\n}", "target": 0}
